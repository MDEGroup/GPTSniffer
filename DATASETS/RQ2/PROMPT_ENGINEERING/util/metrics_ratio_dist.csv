Exercise ID,Question,Book implementation,ChatGPT implementation (version 1),Prompt type,ChatGPT implementation (version 2),distance
0_Exercise22_04.java," /**
 * *22.4 (Pattern matching) Write a program that prompts the user to enter two strings
 * and tests whether the second string is a substring of the first string. (Don’t use
 * the indexOf method in the String class.) Analyze the time complexity of
 * your algorithm. Here is a sample run of the program:
 * <p>
 * Enter a string s1: Mississippi
 * Enter a string s2: sip
 * matched at index 6
 * <p>
 * __________________________________________________________________________________________
 * ----------------------------- Time Complexity Analysis -----------------------------------
 * __________________________________________________________________________________________
 * Time complexity is: O(n) (Linear Time)
 * <p>
 * If s1.length is 100 and s2.length is 4:
 * Worst case is that the loop will execute over all values of s1
 * <p>
 * T(n) = 100 * (s1 String loop) = O(n)
 * <p>
 * So, Time complexity is O(n) because
 * as the length of the input grows, the time will increase at a linear rate
 * based on the size of s1.
 * The size of s2 is not relevant to time complexity because we iterate based on the length of s1.
 */","package ch_22;


import java.util.Scanner;


public class Exercise22_04 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string s1: "");
        String s1 = scanner.nextLine();

        System.out.print(""Enter a string s2: "");
        String s2 = scanner.nextLine();
        int result = new Exercise22_04().indexOfSubstring(s1, s2);
        if (result == -1) {
            System.out.println(""s2 is not a substring of s1..."");
            return;
        }

        System.out.println(""matched at index "" + result);
        scanner.close();
    }

    private int indexOfSubstring(String s1, String s2) {
        int index = 0;
        int matchLength = s2.length();
        char s2Start = s2.charAt(0);
        while (index < (s1.length() - matchLength)) {
            /* Try to match first char in s2 with char at next index */
            if (s1.charAt(index) == s2Start) {
                String s1Sub = s1.substring(index, index + matchLength);
                if (s1Sub.equals(s2)) {
                    return index;
                }
            }
            index++;
        }
        return -1;
    }
}
","import java.util.Scanner;

public class SubstringTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter a string s1: "");
        String s1 = input.nextLine();
        
        System.out.print(""Enter a string s2: "");
        String s2 = input.nextLine();
        
        int index = findSubstringIndex(s1, s2);
        if (index == -1) {
            System.out.println(""s2 is not a substring of s1"");
        } else {
            System.out.println(""matched at index "" + index);
        }
    }
    
    public static int findSubstringIndex(String s1, String s2) {
        int s1Length = s1.length();
        int s2Length = s2.length();
        for (int i = 0; i <= s1Length - s2Length; i++) {
            int j;
            for (j = 0; j < s2Length; j++) {
                if (s1.charAt(i + j) != s2.charAt(j)) {
                    break;
                }
            }
            if (j == s2Length) {
                return i;
            }
        }
        return -1;
    }
}
",1,"import java.util.Scanner;

public class SubstringMatcher {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print(""Enter a string s1: "");
        String s1 = scanner.nextLine();
        
        System.out.print(""Enter a string s2: "");
        String s2 = scanner.nextLine();
        
        int index = findSubstring(s1, s2);
        
        if (index != -1) {
            System.out.println(""Matched at index "" + index);
        } else {
            System.out.println(""Substring not found."");
        }
        
        scanner.close();
    }

    public static int findSubstring(String s1, String s2) {
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        
        for (int i = 0; i <= arr1.length - arr2.length; i++) {
            boolean matched = true;
            
            for (int j = 0; j < arr2.length; j++) {
                if (arr1[i + j] != arr2[j]) {
                    matched = false;
                    break;
                }
            }
            
            if (matched) {
                return i;
            }
        }
        
        return -1;
    }
}",0.8043609933373713
0_Exercise22_09.java," /**
 * **22.9 (Geometry: gift-wrapping algorithm for finding a convex hull) Section 22.10.1
 * introduced the gift-wrapping algorithm for finding a convex hull for a set of
 * points. Assume that the Java’s coordinate system is used for the points.
 * Implement the algorithm using the following method:
 * // Return the points that form a convex hull
 * public static ArrayList<Point2D> getConvexHull(double[][]s)
 * Point2D is defined in Section 9.6.
 * Write a test program that prompts the user to enter the set size and the points
 * and displays the points that form a convex hull.
 * Here is a sample run:
 * <p>
 * How many points are in the set? 6
 * Enter 6 points: 1 2.4 2.5 2 1.5 34.5 5.5 6 6 2.4 5.5 9
 * The convex hull is
 * (1.5, 34.5) (5.5, 9.0) (6.0, 2.4) (2.5, 2.0) (1.0, 2.4)
 */","package ch_22;

import javafx.geometry.Point2D;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.stream.Collectors;


public class Exercise22_09 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""How many points are in the set? "");
        int numPoints = scanner.nextInt();
        System.out.print(""Enter "" + numPoints + "" points: "");

        double[][] points = new double[numPoints][2];

        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < 2; j++) {
                points[i][j] = scanner.nextDouble();
            }
        }
        scanner.close();
        System.out.println(""The convex hull is "" + getConvexHull(points));

    }


    public static ArrayList<Point2D> getConvexHull(double[][] s) {
        int n = s.length;
        // map matrix into List of Point2D's
        List<Point2D> S = Arrays.stream(s).map(points -> new Point2D(points[0], points[1])).collect(Collectors.toList());
        // Created list to hold the points in the convex hull
        ArrayList<Point2D> H = new ArrayList<>();
        // Find the leftmost point
        int l = 0;
        for (int i = 1; i < n; i++)
            if (S.get(i).getX() < S.get(l).getX()) {
                l = i;
            }

        int p = l, q;
        do {
            H.add(S.get(p));

            q = (p + 1) % n;

            for (int i = 0; i < n; i++) {
                if (getOrientation(S.get(p), S.get(i), S.get(q)) == -1) {
                    q = i;
                }
            }
            p = q;

        } while (p != l);

        return H;
    }

    public static int getOrientation(Point2D p, Point2D q, Point2D r) {
        double val = (q.getY() - p.getY()) * (r.getX() - q.getX()) - (q.getX() - p.getX()) * (r.getY() - q.getY());

        if (val == 0) return 0;
        return (val > 0) ? 1 : -1;
    }
}
","import java.util.*;

public class ConvexHull {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""How many points are in the set? "");
        int size = input.nextInt();
        
        double[][] points = new double[size][2];
        System.out.print(""Enter "" + size + "" points: "");
        for (int i = 0; i < size; i++) {
            points[i][0] = input.nextDouble();
            points[i][1] = input.nextDouble();
        }

        ArrayList<Point2D> hull = getConvexHull(points);
        
        System.out.println(""The convex hull is"");
        for (Point2D p : hull) {
            System.out.print(""("" + p.getX() + "", "" + p.getY() + "") "");
        }
    }
    
    public static ArrayList<Point2D> getConvexHull(double[][] points) {
        ArrayList<Point2D> hull = new ArrayList<>();
        
        // Find the rightmost lowest point
        int startingIndex = 0;
        for (int i = 1; i < points.length; i++) {
            if (points[i][1] < points[startingIndex][1] ||
                (points[i][1] == points[startingIndex][1] &&
                 points[i][0] > points[startingIndex][0])) {
                startingIndex = i;
            }
        }
        
        int currentIndex = startingIndex;
        do {
            hull.add(new Point2D(points[currentIndex][0], points[currentIndex][1]));
            int nextIndex = (currentIndex + 1) % points.length;
            for (int i = 0; i < points.length; i++) {
                if (orient(points[currentIndex], points[i], points[nextIndex]) < 0) {
                    nextIndex = i;
                }
            }
            currentIndex = nextIndex;
        } while (currentIndex != startingIndex);
        
        return hull;
    }
    
    public static double orient(double[] p, double[] q, double[] r) {
        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);
    }
}
",1,"/**
 * Hello, fellow coders! Today, we're gonna tackle a cool problem: finding the
 * Convex Hull using the Gift-Wrapping Algorithm. But don't worry, I'll break
 * it down step by step so even beginners can understand.
 * 
 * First, let's create a Java method for this task. We're gonna call it
 * 'getConvexHull', and it will take an array of points as input.
 */

import java.util.ArrayList;

public class ConvexHullFinder {

    public static ArrayList<Point2D> getConvexHull(double[][] pointsArray) {
        ArrayList<Point2D> convexHull = new ArrayList<>();
        // Okay, let's do the actual algorithm stuff here.
        // We'll pretend like we know what we're doing.
        // Just trust the process! 😅

        // Now, let's return the convex hull we found.
        return convexHull;
    }

    public static void main(String[] args) {
        System.out.println(""Welcome to the Convex Hull Finder!"");
        System.out.print(""How many points are in the set? "");
        int setSize = 0; // We'll store the number of points here.
        // Let's get the user input for the number of points.
        // I'm not gonna handle invalid input, so be careful!

        // Let's create an array to store the points.
        double[][] pointsArray = new double[setSize][2];
        
        // Now, let's get the user to enter the points one by one.
        System.out.print(""Enter "" + setSize + "" points: "");
        // We'll use a Scanner for this, but I won't show you how to do it.

        // Now that we have the points, let's call our magical method.
        ArrayList<Point2D> convexHull = getConvexHull(pointsArray);

        // Time to display the result!
        System.out.println(""The convex hull is:"");
        for (Point2D point : convexHull) {
            System.out.println(""("" + point.getX() + "", "" + point.getY() + "")"");
        }
        // Ta-da! We did it! 🎉
    }
}",0.3948100092678406
0_Exercise22_05.java," /**
 * 22.5 (Same-number subsequence) Write an O(n) program that prompts the user to
 * enter a sequence of integers ending with 0 and finds the longest subsequence
 * with the same number. Here is a sample run of the program:
 * Enter a series of numbers ending with 0:
 * 2 4 4 8 8 8 8 2 4 4 0
 * The longest same number sequence starts at index 3 with 4 values of 8
 */","package ch_22;

import java.util.Scanner;


public class Exercise22_05 {
    private void findSubsequence(String[] tokens) {
        int longest = 0;
        int longestStartIndex = 0;
        int count = 1;
        int value = 0;
        int startIndex = 0;

        for (int i = 0; i < tokens.length - 1; i++) {
            int curr = Integer.parseInt(tokens[i]);
            int next = Integer.parseInt(tokens[i + 1]);
            if (next == 0) break;
            if (curr == next) {
                count++;
                longest = Math.max(longest, count);
                if (count == longest) {
                    value = curr;
                    longestStartIndex = startIndex;
                }
            } else {
                startIndex = i + 1;
                count = 1;
            }

        }
        System.out.println(""The longest same number sequence starts at index "" + longestStartIndex +
                "" with "" + longest + "" values "" + ""of "" + value);

    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a series of numbers ending with 0:"");
        String[] tokens = input.nextLine().split(""\\s+"");
        new Exercise22_05().findSubsequence(tokens);

        input.close();

    }
}
","import java.util.*;

public class LongestSameNumberSequence {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.println(""Enter a series of numbers ending with 0:"");
        
        int currentNumber = input.nextInt();
        int currentLength = 1;
        
        int longestStartIndex = 0;
        int longestLength = 1;
        
        int currentIndex = 1;
        while (currentNumber != 0) {
            int number = input.nextInt();
            if (number == currentNumber) {
                currentLength++;
            } else {
                if (currentLength > longestLength) {
                    longestStartIndex = currentIndex - currentLength;
                    longestLength = currentLength;
                }
                currentNumber = number;
                currentLength = 1;
            }
            currentIndex++;
        }
        
        if (currentLength > longestLength) {
            longestStartIndex = currentIndex - currentLength;
            longestLength = currentLength;
        }
        
        System.out.println(""The longest same number sequence starts at index "" +
            longestStartIndex + "" with "" + longestLength + "" values of "" + currentNumber);
    }
}
",1,"import java.util.Scanner;

public class LongestSameNumberSubsequenceFinder {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.println(""Welcome to the Same-number Subsequence Finder!"");
        System.out.println(""Please enter a series of numbers ending with 0:"");
        
        int[] sequence = new int[100]; // I'll just assume we won't have more than 100 numbers.
        int currentIndex = 0;
        
        int currentNumber = scanner.nextInt();
        while (currentNumber != 0) {
            sequence[currentIndex] = currentNumber;
            currentIndex++;
            currentNumber = scanner.nextInt();
        }
        
        int longestStartIndex = 0;
        int longestLength = 0;
        int currentStartIndex = 0;
        int currentLength = 1;
        
        for (int i = 1; i < currentIndex; i++) {
            if (sequence[i] == sequence[i - 1]) {
                currentLength++;
            } else {
                if (currentLength > longestLength) {
                    longestLength = currentLength;
                    longestStartIndex = currentStartIndex;
                }
                currentStartIndex = i;
                currentLength = 1;
            }
        }
        
        if (currentLength > longestLength) {
            longestLength = currentLength;
            longestStartIndex = currentStartIndex;
        }
        
        System.out.println(""The longest same number sequence starts at index "" + longestStartIndex +
                           "" with "" + longestLength + "" values of "" + sequence[longestStartIndex]);
    }
}",0.7142212189616253
0_Exercise22_02.java," /**
 * *22.2 (Maximum increasingly ordered subsequence) Write a program that prompts
 * the user to enter a string and displays the maximum increasingly ordered subsequence of characters.
 * Analyze the time complexity of your program. Here is a sample run:
 * <p>
 * Enter a string: Welcome
 * Welo
 * __________________________________________________________________________________________
 * ----------------------------- Time Complexity Analysis -----------------------------------
 * __________________________________________________________________________________________
 * Time complexity is: O(n) (Linear Time)
 * For example:
 * If input string is length 20:
 * ---- T(n) = 20 * (input string loop) = O(n) -----
 * So, Time complexity is O(n) because
 * as the length of the input grows, the time will increase at a linear rate
 * based on the size of the input.
 * __________________________________________________________________________________________
 */","package ch_22;

import java.util.Scanner;


public class Exercise22_02 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String input = in.next().trim();
        String result = """";
        char lastSeqChar = input.charAt(0);
        /* Loop always executes one time, so growth rate of time is constant as the input string gets larger */
        for (int j = 1; j < input.length(); j++) {
            if (lastSeqChar < input.charAt(j)) {
                result += lastSeqChar + """";
                lastSeqChar = input.charAt(j);
            }
        }
        result += lastSeqChar;
        System.out.println(result);

        in.close();
    }
}
","import java.util.*;

public class MaximumIncreasingSubsequence {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter a string: "");
        String str = input.next();
        
        int n = str.length();
        int[] dp = new int[n];
        int[] prev = new int[n];
        Arrays.fill(dp, 1);
        Arrays.fill(prev, -1);
        
        int maxIndex = 0;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (str.charAt(j) < str.charAt(i) && dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                    prev[i] = j;
                }
            }
            if (dp[i] > dp[maxIndex]) {
                maxIndex = i;
            }
        }
        
        StringBuilder sb = new StringBuilder();
        for (int i = maxIndex; i != -1; i = prev[i]) {
            sb.append(str.charAt(i));
        }
        
        System.out.println(sb.reverse().toString());
    }
}
",1,"import java.util.Scanner;

public class MaxIncreasingSubsequenceFinder {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println(""Welcome to the Max Increasing Subsequence Finder!"");
        System.out.print(""Please enter a string: "");
        
        String inputString = scanner.nextLine();
        int length = inputString.length();
        String maxIncreasingSubsequence = """"; // We'll store the result here.
        
        for (int i = 0; i < length; i++) {
            char currentChar = inputString.charAt(i);
            StringBuilder subsequence = new StringBuilder();
            subsequence.append(currentChar);
            
            for (int j = i + 1; j < length; j++) {
                if (inputString.charAt(j) > currentChar) {
                    subsequence.append(inputString.charAt(j));
                    currentChar = inputString.charAt(j);
                }
            }
            
            if (subsequence.length() > maxIncreasingSubsequence.length()) {
                maxIncreasingSubsequence = subsequence.toString();
            }
        }
        
        System.out.println(""The maximum increasingly ordered subsequence is: "" + maxIncreasingSubsequence);
        
        // Time complexity analysis:
        System.out.println(""__________________________________________________________________________________________"");
        System.out.println(""------------------------------- Time Complexity Analysis ---------------------------------"");
        System.out.println(""__________________________________________________________________________________________"");
        System.out.println(""Time complexity is: O(n) (Linear Time)"");
        System.out.println(""For example:"");
        System.out.println(""If input string is length "" + length + "":"");
        System.out.println(""---- T(n) = "" + length + "" * (input string loop) = O(n) -----"");
        System.out.println(""So, Time complexity is O(n) because"");
        System.out.println(""as the length of the input grows, the time will increase at a linear rate"");
        System.out.println(""based on the size of the input."");
        System.out.println(""__________________________________________________________________________________________"");
    }
}",0.38771735109137995
0_Exercise22_03.java," /**
 * *22.3 (Pattern matching) Write a program that prompts the user to enter two strings
 * and tests whether the second string is a substring of the first string. Suppose
 * the neighboring characters in the string are distinct. (Don’t use the indexOf
 * method in the String class.) Analyze the time complexity of your algorithm.
 * Your algorithm needs to be at least O(n) time.
 * Here is a sample run of the program:
 * <p>
 * Enter a string s1: Welcome to Java
 * Enter a string s2: come
 * matched at index 3
 * <p>
 * __________________________________________________________________________________________
 * ----------------------------- Time Complexity Analysis -----------------------------------
 * __________________________________________________________________________________________
 * Time complexity is: O(n) (Linear Time)
 *
 * If s1.length is 100 and s2.length is 4:
 * Worst case is that the loop will execute over all values of s1 and check if index
 * of s1 matches the starting char in s2.
 *
 * T(n) = 100 * (s1 String loop) = O(n)
 *
 * So, Time complexity is O(n) because
 * as the length of the input grows, the time will increase at a linear rate
 * based on the size of s1.
 * The size of s2 is not relevant to time complexity because we iterate based on the length of s1.
 *
 * --------------------------------- Additional efficiency ---------------------------------
 * This could be made more efficient by utilizing the constraint of neighboring characters must be
 * distinct, by performing a fast-forward after a negative match on s1 substring and s2, you move s1's index pointer
 * forward to the next possible match for s2 starting character before resuming the loop.
 *
 * Fast-forwarding would result in better time complexity of O(n/m) where n is length of s1 and m is length of s2;
 * __________________________________________________________________________________________
 */","package ch_22;

import java.util.Scanner;


public class Exercise22_03 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string s1: "");
        String s1 = scanner.nextLine();
        System.out.print(""Enter a string s2: "");
        String s2 = scanner.nextLine();
        String res = getMatchedIndex(s1, s2);
        System.out.println(res);
        scanner.close();
    }

    private static String getMatchedIndex(String s1, String s2) {
        int i1 = 0;
        int matchLength = s2.length();
        char s2Start = s2.charAt(0);
        while (i1 < s1.length()) {
            if (s1.charAt(i1) == s2Start) { // Try to match first char in s2
                String s1Sub = s1.substring(i1, i1 + matchLength);
                if (s1Sub.equals(s2)) {
                    return ""matched at index "" + i1;
                } else {
                    // fast-forward here
                }
            }
            i1++;
        }
        return ""s2 is not a substring of s1"";
    }

}
","import java.util.Scanner;

public class SubstringSearch {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string s1: "");
        String s1 = input.nextLine();

        System.out.print(""Enter a string s2: "");
        String s2 = input.nextLine();

        int i = 0;
        int j = 0;
        int index = -1;

        while (i < s1.length() && j < s2.length()) {
            if (s1.charAt(i) == s2.charAt(j)) {
                if (index == -1) {
                    index = i;
                }
                j++;
            } else {
                j = 0;
                index = -1;
            }
            i++;
        }

        if (j == s2.length()) {
            System.out.println(""matched at index "" + (index - j + 1));
        } else {
            System.out.println(""not matched"");
        }
    }
}",1,"import java.util.Scanner;

public class SubstringMatcher {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Welcome message
        System.out.println(""Welcome to the Substring Matcher!"");
        
        // Prompt for the first string
        System.out.print(""Enter a string s1: "");
        String s1 = scanner.nextLine();

        // Prompt for the second string
        System.out.print(""Enter a string s2: "");
        String s2 = scanner.nextLine();

        int s1Length = s1.length();
        int s2Length = s2.length();

        int matchIndex = -1; // Initialize matchIndex to -1 (not found)

        // Iterate through s1 to find s2
        for (int i = 0; i <= s1Length - s2Length; i++) {
            // Check if s2 is a substring starting from position i in s1
            boolean isSubstring = true;

            for (int j = 0; j < s2Length; j++) {
                if (s1.charAt(i + j) != s2.charAt(j)) {
                    isSubstring = false;
                    break;
                }
            }

            if (isSubstring) {
                matchIndex = i;
                break;
            }
            
            // Additional efficiency: Fast-forward if neighboring characters are distinct
            if (j < s2Length - 1) {
                char nextChar = s2.charAt(j + 1);
                int nextIndex = s1.indexOf(nextChar, i + 1);
                if (nextIndex != -1) {
                    i = nextIndex - 1;
                } else {
                    break;
                }
            }
        }

        // Display the result
        if (matchIndex != -1) {
            System.out.println(""matched at index "" + matchIndex);
        } else {
            System.out.println(""s2 is not a substring of s1"");
        }

        // Time complexity analysis
        System.out.println(""__________________________________________________________________________________________"");
        System.out.println(""------------------------------- Time Complexity Analysis ---------------------------------"");
        System.out.println(""__________________________________________________________________________________________"");
        System.out.println(""Time complexity is: O(n) (Linear Time)"");
        System.out.println(""If s1.length is "" + s1Length + "" and s2.length is "" + s2Length + "":"");
        System.out.println(""Worst case is that the loop will execute over all values of s1 and check if index"");
        System.out.println(""of s1 matches the starting char in s2."");
        System.out.println(""T(n) = "" + s1Length + "" * (s1 String loop) = O(n)"");
        System.out.println(""So, Time complexity is O(n) because"");
        System.out.println(""as the length of the input grows, the time will increase at a linear rate"");
        System.out.println(""based on the size of s1."");
        System.out.println(""The size of s2 is not relevant to time complexity because we iterate based on the length of s1."");
        System.out.println(""__________________________________________________________________________________________"");
        
        // Additional efficiency explanation
        System.out.println(""--------------------------------- Additional efficiency ---------------------------------"");
        System.out.println(""This could be made more efficient by utilizing the constraint of neighboring characters must be"");
        System.out.println(""distinct, by performing a fast-forward after a negative match on s1 substring and s2, you move s1's index pointer"");
        System.out.println(""forward to the next possible match for s2 starting character before resuming the loop."");
        System.out.println(""Fast-forwarding would result in better time complexity of O(n/m) where n is the length of s1 and m is the length of s2;"");
        System.out.println(""__________________________________________________________________________________________"");
    }
}",0.29089079013588326
0_Exercise22_01.java," /**
 * 22.1 (Maximum consecutive increasingly ordered substring) Write a program that
 * prompts the user to enter a string and displays the maximum consecutive
 * increasingly ordered substring. Analyze the time complexity of your program.
 * Here is a sample run:
 * Enter a string:abcabcdgabxy
 * abcdg
 * <p>
 * Enter a string: abcabcdgabmnsxy
 * abmnsxy
 * <p>
 * __________________________________________________________________________________________
 * ----------------------------- Time Complexity Analysis -----------------------------------
 * __________________________________________________________________________________________
 * If input string is length 20:
 * ---- T(n) = 20 * (input string loop) * (substring loop) = O(n^2) -----
 * Time complexity is O(n^2).
 * As the length of the input grows, the time complexity will grow
 * exponentially because we use an inner loop to traverse each
 * sub-string of the input string.
 */","package ch_22;

import java.util.Scanner;


public class Exercise22_01 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String base = input.next();
        int p1 = 0; // Start substring pointer
        String maxSub = """";
        for (int i = 1; i < base.length(); i++) {
            String testSub = base.substring(p1, i + 1);
            if (testSubstring(testSub)) {
                if (testSub.length() > maxSub.length()) {
                    maxSub = testSub;
                }
            } else {
                p1++;
            }
        }
        System.out.println(maxSub);
        input.close();
    }

    static boolean testSubstring(String s) {
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) > s.charAt(i + 1)) {
                return false;
            }
        }
        return true;
    }
}
","import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string:"");
        String s = scanner.nextLine();
        System.out.println(findMaxConsecutiveSubstring(s));
    }

    public static String findMaxConsecutiveSubstring(String s) {
        String maxSubstring = """";
        String currentSubstring = """";

        for (int i = 0; i < s.length(); i++) {
            if (i == 0 || s.charAt(i) <= s.charAt(i-1)) {
                currentSubstring = """";
            }
            currentSubstring += s.charAt(i);
            if (currentSubstring.length() > maxSubstring.length()) {
                maxSubstring = currentSubstring;
            }
        }

        return maxSubstring;
    }
}",1,"import java.util.Scanner;

public class MaxConsecutiveSubstring {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Welcome message
        System.out.println(""Welcome to the Max Consecutive Increasing Substring Finder!"");
        
        // Prompt for the input string
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();
        int inputLength = inputString.length();

        String maxConsecutiveSubstring = """";
        String currentSubstring = """";

        // Iterate through the input string to find the maximum consecutive substring
        for (int i = 0; i < inputLength; i++) {
            currentSubstring = """" + inputString.charAt(i);

            // Check for consecutive increasing characters
            for (int j = i + 1; j < inputLength; j++) {
                if (inputString.charAt(j) > inputString.charAt(j - 1)) {
                    currentSubstring += inputString.charAt(j);
                } else {
                    break; // Stop if not increasing
                }
            }

            // Update the maximum consecutive substring
            if (currentSubstring.length() > maxConsecutiveSubstring.length()) {
                maxConsecutiveSubstring = currentSubstring;
            }
        }

        // Display the result
        System.out.println(""The maximum consecutive increasing substring is: "" + maxConsecutiveSubstring);

        // Time complexity analysis
        System.out.println(""__________________________________________________________________________________________"");
        System.out.println(""------------------------------- Time Complexity Analysis ---------------------------------"");
        System.out.println(""__________________________________________________________________________________________"");
        System.out.println(""If input string is length "" + inputLength + "":"");
        System.out.println(""---- T(n) = "" + inputLength + "" * (input string loop) * (substring loop) = O(n^2) -----"");
        System.out.println(""Time complexity is O(n^2)."");
        System.out.println(""As the length of the input grows, the time complexity will grow"");
        System.out.println(""exponentially because we use an inner loop to traverse each"");
        System.out.println(""sub-string of the input string."");
        System.out.println(""__________________________________________________________________________________________"");
    }
}
",0.39599714081486775
0_Exercise22_06.java," /**
 * *22.6 (Execution time for GCD) Write a program that obtains the execution time for
 * finding the GCD of every two consecutive Fibonacci numbers from the index
 * 40 to index 45 using the algorithms in Listings 22.3 and 22.4. Your program
 * should print a table like this:
 * --------------------|   40     41    42    43    44    45
 * ---------------------------------------------------------------------------------
 * Listing 22.3 GCD
 * Listing 22.4 GCDEuclid
 * <p>
 * (Hint: You can use the following code template to obtain the execution time.)
 * long startTime = System.currentTimeMillis();
 * perform the task;
 * long endTime = System.currentTimeMillis();
 * long executionTime = endTime - startTime;
 */ /**
     * Test Driver
     */ /**
     * Find GCD for integers m and n using Euclid's algorithm
     */ /**
     * Find GCD for integers m and n
     */","package ch_22;


public class Exercise22_06 {

    
    public static void main(String[] args) {
        /* calculate the Fibonacci numbers from index 40 to index 45 */
        int[] fibs = calcFibIndexes40to45();
        System.out.println(""\t\t\t\t\t\t40    41    42    43    44    45"");
        System.out.println(""---------------------------------------------------------"");
        System.out.print(""Listing 22.3 GCD\t\t"");
        for (int i = 0; i < fibs.length - 1; i++) {
            long startTime = System.currentTimeMillis();
            int gcd = gcd(fibs[i], fibs[i + 1]);
            long endTime = System.currentTimeMillis();
            long executionTime = endTime - startTime;
            System.out.print(""   "" + executionTime);
        }
        System.out.print(""\nListing 22.4 GCDEuclid "");
        for (int i = 0; i < fibs.length - 1; i++) {
            long startTime = System.currentTimeMillis();
            int gcd = gcdEuclid(fibs[i], fibs[i + 1]);
            long endTime = System.currentTimeMillis();
            long executionTime = endTime - startTime;
            System.out.print(""     "" + executionTime);
        }
    }

    
    public static int gcdEuclid(int m, int n) {
        if (m % n == 0)
            return n;
        else
            return gcdEuclid(n, m % n);
    }


    
    public static int gcd(int m, int n) {
        int gcd = 1;
        if (m % n == 0) return n;
        for (int k = n / 2; k >= 1; k--) {
            if (m % k == 0 && n % k == 0) {
                gcd = k;
                break;
            }
        }

        return gcd;
    }


    private static int[] calcFibIndexes40to45() {
        int[] fibs = new int[6];
        int i = 2;
        int f0 = 0;
        int f1 = 1;
        int f2 = 0;
        // Find fib numbers up to 39
        while (i < 40) {
            f2 = f0 + f1;
            f0 = f1;
            f1 = f2;
            i++;
        }
        // Next fib will be at index 40
        for (int j = 0; j < fibs.length; j++) {
            f2 = f0 + f1;
            fibs[j] = f2;
            f0 = f1;
            f1 = f2;
        }

        return fibs;
    }


}
","public class Main {
    public static void main(String[] args) {
        System.out.println(""--------------------|   40     41    42    43    44    45"");
        System.out.println(""------------------------------------------------------------------------"");

        long[][] times = new long[2][6]; // to store the execution times

        for (int i = 40; i <= 45; i++) {
            long startTime = System.nanoTime();
            long gcd1 = gcd(FibonacciRecursive(i), FibonacciRecursive(i+1));
            long endTime = System.nanoTime();
            times[0][i-40] = endTime - startTime;

            startTime = System.nanoTime();
            long gcd2 = gcd(FibonacciIterative(i), FibonacciIterative(i+1));
            endTime = System.nanoTime();
            times[1][i-40] = endTime - startTime;

            System.out.printf(""Fibonacci(%2d) and Fibonacci(%2d) | %6d %6d %6d %6d %6d %6d\n"", i, i+1, times[0][i-40], times[0][i-39], times[0][i-38], times[0][i-37], times[0][i-36], times[0][i-35]);
        }

        System.out.println(""------------------------------------------------------------------------"");
        System.out.println(""Recursive algorithm: "" + Arrays.toString(times[0]));
        System.out.println(""Iterative algorithm: "" + Arrays.toString(times[1]));
    }

    // Recursive algorithm for Fibonacci numbers
    public static long FibonacciRecursive(int n) {
        if (n == 0)
            return 0;
        else if (n == 1)
            return 1;
        else
            return FibonacciRecursive(n-1) + FibonacciRecursive(n-2);
    }

    // Iterative algorithm for Fibonacci numbers
    public static long FibonacciIterative(int n) {
        if (n == 0)
            return 0;
        else if (n == 1)
            return 1;

        long fibMinusTwo = 0;
        long fibMinusOne = 1;
        long fib = 0;

        for (int i = 2; i <= n; i++) {
            fib = fibMinusOne + fibMinusTwo;
            fibMinusTwo = fibMinusOne;
            fibMinusOne = fib;
        }

        return fib;
    }

    // Euclidean algorithm for finding the greatest common divisor
    public static long gcd(long m, long n) {
        if (m % n == 0)
            return n;
        else
            return gcd(n, m % n);
    }
}",1,"public class FibonacciGCD {

    public static void main(String[] args) {
        System.out.println(""-------------------------------------------------------"");
        System.out.println(""| Index |   40   |   41   |   42   |   43   |   44   |   45   |"");
        System.out.println(""-------------------------------------------------------"");
        System.out.print(""| GCD   |"");

        // Loop through Fibonacci indices from 40 to 45
        for (int i = 40; i <= 45; i++) {
            long startTime;
            long endTime;
            long executionTime;

            // Calculate GCD using Listing 22.3 (GCD) algorithm
            startTime = System.currentTimeMillis();
            long gcd = findGCDListing22_3(i);
            endTime = System.currentTimeMillis();
            executionTime = endTime - startTime;
            System.out.print(""  "" + gcd + ""  |"");

            // Calculate GCD using Listing 22.4 (GCDEuclid) algorithm
            startTime = System.currentTimeMillis();
            long euclidGCD = findGCDEuclidListing22_4(i);
            endTime = System.currentTimeMillis();
            executionTime = endTime - startTime;
            System.out.print(""  "" + euclidGCD + ""  |"");
        }

        System.out.println(""\n-------------------------------------------------------"");
    }

    // Listing 22.3 GCD algorithm
    public static long findGCDListing22_3(int n) {
        if (n <= 1) {
            return 1;
        }
        return findGCDListing22_3(n - 1) + findGCDListing22_3(n - 2);
    }

    // Listing 22.4 GCDEuclid algorithm
    public static long findGCDEuclidListing22_4(int n) {
        if (n <= 1) {
            return 1;
        }
        return gcd(n, n - 1);
    }

    // Find GCD of two numbers using Euclid's algorithm
    public static long gcd(long m, long n) {
        if (m % n == 0) {
            return n;
        }
        return gcd(n, m % n);
    }
}",0.5671200473092844
0_Exercise22_10.java," /**
 * 22.10 (Number of prime numbers) Programming Exercise 22.8 stores the prime numbers in a file named PrimeNumbers.dat.
 * Write a program that finds the number of prime numbers that are less than or equal to 10, 100, 1,000, 10,000,
 * 100,000, 1,000,000, 10,000,000, 100,000,000, 1,000,000,000, and
 * 10,000,000,000. Your program should read the data from PrimeNumbers.dat
 */","package ch_22;

import ch_22.exercise22_08.Exercise22_08;

import java.io.EOFException;
import java.io.File;
import java.io.RandomAccessFile;


public class Exercise22_10 {
    private static final String[] packageParts = Exercise22_08.class.getPackage().getName().split(""\\."");
    private static final String PATH = packageParts[0] + File.separator + packageParts[1] + File.separator + ""PrimeNumbers.dat"";

    public static void main(String[] args) {
        try {
            File dataFile = new File(PATH);
            RandomAccessFile randomAccessFile = new RandomAccessFile(dataFile, ""r"");
            long count = 0;
            long interval = 10;
            long nextPrime;
            try {
                while ((nextPrime = randomAccessFile.readLong()) != 0L) {
                    if (nextPrime > interval) {
                        System.out.println(""There are "" + count + "" primes, less than or equal to "" + interval);
                        interval *= 10;
                    }

                    if (interval > 10_000_000_000L) {
                        System.out.println(""Max interval reached..."");
                        System.exit(0);
                    }

                    count++;

                }

            } catch (EOFException eofException) {
                System.out.println(""End of file reached."");
            }

        } catch (Exception e) {
            System.out.println(""Exception occurred: "" + e.getLocalizedMessage());
        }
    }
}
","import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        String fileName = ""PrimeNumbers.dat"";
        long[] primes = readPrimesFromFile(fileName);

        int[] numbers = {10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000L};

        System.out.printf(""%12s %10s\n"", ""Number"", ""Primes"");
        System.out.println(""------------------------"");

        for (int i = 0; i < numbers.length; i++) {
            int count = countPrimes(primes, numbers[i]);
            System.out.printf(""%12d %10d\n"", numbers[i], count);
        }
    }

    public static long[] readPrimesFromFile(String fileName) {
        try (DataInputStream input = new DataInputStream(new FileInputStream(fileName))) {
            int size = input.readInt();
            long[] primes = new long[size];

            for (int i = 0; i < size; i++) {
                primes[i] = input.readLong();
            }

            return primes;
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    public static int countPrimes(long[] primes, int n) {
        int count = 0;

        for (int i = 0; i < primes.length; i++) {
            if (primes[i] <= n) {
                count++;
            } else {
                break;
            }
        }

        return count;
    }
}",1,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class PrimeNumberCounter {

    public static void main(String[] args) {
        // Array of values for which we want to find prime counts
        long[] values = {10, 100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 100_000_000, 1_000_000_000, 10_000_000_000};

        // Read prime numbers from the file
        long[] primeNumbers = readPrimeNumbersFromFile();

        // Display the prime counts for specified values
        for (long value : values) {
            int primeCount = countPrimesLessThanOrEqualTo(value, primeNumbers);
            System.out.println(""Number of prime numbers less than or equal to "" + value + "": "" + primeCount);
        }
    }

    // Read prime numbers from the file ""PrimeNumbers.dat""
    public static long[] readPrimeNumbersFromFile() {
        String fileName = ""PrimeNumbers.dat"";
        String line;
        long[] primeNumbers = null;

        try {
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            line = reader.readLine();
            primeNumbers = line.split("", "").length == 1 ? new long[0] : new long[line.split("", "").length];
            int i = 0;
            while (line != null) {
                String[] tokens = line.split("", "");
                for (String token : tokens) {
                    primeNumbers[i++] = Long.parseLong(token);
                }
                line = reader.readLine();
            }
            reader.close();
        } catch (IOException e) {
            System.err.println(""Error reading "" + fileName + "": "" + e.getMessage());
        }

        return primeNumbers;
    }

    // Count the number of prime numbers less than or equal to a specified value
    public static int countPrimesLessThanOrEqualTo(long value, long[] primeNumbers) {
        int count = 0;
        for (long prime : primeNumbers) {
            if (prime <= value) {
                count++;
            } else {
                break;
            }
        }
        return count;
    }
}
",0.575332866152768
0_Pair.java," /**
 * ■ Define a class named Pair with the data fields p1 and p2 to represent two
 * points, and a method named getDistance() that returns the distance
 * between the two points.
 */","package ch_22.exercise22_07;


public class Pair {
    private Point p1;
    private Point p2;

    public Pair(){}

    public Pair(Point p1, Point p2) {
        this.p1 = p1;
        this.p2 = p2;
    }

   double getDistance() {
        if (p1 == null || p2 == null) throw new IllegalArgumentException(""Pair must have 2 non-null points defined...."");
        return Math.sqrt(Math.pow((p2.x - p1.x), 2) + Math.pow((p2.y - p1.y), 2));
    }

    public Point getP1() {
        return p1;
    }

    public void setP1(Point p1) {
        this.p1 = p1;
    }

    public Point getP2() {
        return p2;
    }

    public void setP2(Point p2) {
        this.p2 = p2;
    }


    @Override
    public String toString() {
        return ""Pair{"" +
                ""p1="" + p1 +
                "", p2="" + p2 +
                '}';
    }
}
","public class Pair {
    private Point p1;
    private Point p2;

    public Pair(Point p1, Point p2) {
        this.p1 = p1;
        this.p2 = p2;
    }

    public double getDistance() {
        double dx = p2.getX() - p1.getX();
        double dy = p2.getY() - p1.getY();
        return Math.sqrt(dx * dx + dy * dy);
    }
}",1,"public class Pair {
    // Data fields to store the coordinates of two points
    private double p1X, p1Y;
    private double p2X, p2Y;

    // Constructor to initialize the points
    public Pair(double p1X, double p1Y, double p2X, double p2Y) {
        this.p1X = p1X;
        this.p1Y = p1Y;
        this.p2X = p2X;
        this.p2Y = p2Y;
    }

    // Method to calculate the distance between two points
    public double getDistance() {
        // Calculate the differences in x and y coordinates
        double deltaX = p2X - p1X;
        double deltaY = p2Y - p1Y;

        // Calculate the distance using the Pythagorean theorem
        double distance = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));

        // Return the calculated distance
        return distance;
    }

    public static void main(String[] args) {
        // Create an instance of the Pair class
        Pair pointPair = new Pair(1.0, 2.0, 4.0, 6.0);

        // Calculate and display the distance between the two points
        double distance = pointPair.getDistance();
        System.out.println(""The distance between the two points is: "" + distance);
    }
}",0.35625
0_Point.java," /**
 * ■ Define a class named Point with two data fields x and y to represent a
 * * point’s x- and y-coordinates.
 * Implement the Comparable interface for comparing the points on x-coordinates.
 * If two points have the same x-coordinates, compare their y-coordinates.
 */","package ch_22.exercise22_07;


public class Point implements Comparable<Point> {
    double x;
    double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public Point setX(double x) {
        this.x = x;
        return this;
    }

    public double getY() {
        return y;
    }

    public Point setY(double y) {
        this.y = y;
        return this;
    }


    @Override
    public String toString() {
        return ""Point{"" +
                ""x="" + x +
                "", y="" + y +
                ""}\n"";
    }

    @Override
    public int compareTo(Point that) {
        if (this.x == that.x) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return 1;
            }
            return 0; // this.y == that.y

        } else {
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return 1;
            }
            return 0;//this.x == that.x

        }
    }
}
","public class Point implements Comparable<Point> {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    @Override
    public int compareTo(Point other) {
        int xComparison = Double.compare(x, other.x);
        if (xComparison != 0) {
            return xComparison;
        }
        return Double.compare(y, other.y);
    }
}",1,"public class Point implements Comparable<Point> {
    // Data fields to represent x and y coordinates
    private double x;
    private double y;

    // Constructor to initialize the coordinates
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    // Getter methods for x and y coordinates
    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    // Implement the compareTo method for comparing points
    @Override
    public int compareTo(Point otherPoint) {
        // Compare based on x-coordinates
        if (this.x < otherPoint.x) {
            return -1;
        } else if (this.x > otherPoint.x) {
            return 1;
        } else {
            // If x-coordinates are equal, compare based on y-coordinates
            if (this.y < otherPoint.y) {
                return -1;
            } else if (this.y > otherPoint.y) {
                return 1;
            } else {
                return 0;
            }
        }
    }

    public static void main(String[] args) {
        // Create instances of the Point class
        Point point1 = new Point(2.0, 3.0);
        Point point2 = new Point(1.0, 4.0);

        // Compare the points based on x-coordinates and display the result
        int result = point1.compareTo(point2);
        if (result < 0) {
            System.out.println(""point1 is smaller than point2."");
        } else if (result > 0) {
            System.out.println(""point1 is larger than point2."");
        } else {
            System.out.println(""point1 and point2 are equal."");
        }
    }
}",0.4525205158264947
0_Exercise22_07.java," /**
 * *22.7 (Closest pair of points) Section 22.8 introduced an algorithm for finding the
 * closest pair of points using a divide-and-conquer approach.
 * <p>
 * Implement the algorithm to meet the following requirements:
 * ■ Define the classes Point and CompareY in the same way as in Programming Exercise 20.4.
 * ■ Define a class named Pair with the data fields p1 and p2 to represent two
 * points, and a method named getDistance() that returns the distance
 * between the two points.
 * </p>
 * ---------------------------------------------------------------------- <br>
 * ■ Implement the following methods:
 * /** Return the distance of the closest pair of points *
 * public static Pair getClosestPair(double[][] points)
 * ---------------------------------------------------------------------- <br>
 * /** Return the distance of the closest pair of points
 * public static Pair getClosestPair(Point[] points)
 * ---------------------------------------------------------------------- <br>
 * /** Return the distance of the closest pair of points
 * in pointsOrderedOnX[low..high]. This is a recursive
 * method. pointsOrderedOnX and pointsOrderedOnY are
 * not changed in the subsequent recursive calls. *
 * public static Pair distance(Point[] pointsOrderedOnX, int low, int high, Point[] pointsOrderedOnY)
 * *************************************************************************************************
 * <p>
 * From Section 22.8:
 * LISTING 22.8 Algorithm for Finding the Closest Pair
 * Step 1: Sort the points in increasing order of x-coordinates. For the
 * points with the same x-coordinates, sort on y-coordinates. This results
 * in a sorted list S of points.
 * Step 2: Divide S into two subsets, S1 and S2, of equal size using the
 * midpoint in the sorted list. Let the midpoint be in S1. Recursively find
 * the closest pair in S1 and S2. Let d1 and d2 denote the distance of the
 * closest pairs in the two subsets, respectively.
 * Step 3: Find the closest pair between a point in S1 and a point in S2 and
 * denote their distance as d3
 * </p>
 */ /**
     * Return the distance of the closest pair of points
     */ /**
     * Return the distance of the closest pair of points
     */ /**
     * Return the distance of the closest pair of points
     * in pointsOrderedOnX[low..high]. This is a recursive
     * method. pointsOrderedOnX and pointsOrderedOnY are
     * not changed in the subsequent recursive calls.
     */","package ch_22.exercise22_07;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;


public class Exercise22_07 {
    private static Point[] S = new Point[]{new Point(65.72438591548975, 167.6922117473909),
            new Point(182.85174298311438, 575.9888358534622),
            new Point(240.22902231427315, 175.37793004083213),
            new Point(317.5674265676426, 278.78240371327325),
            new Point(356.00061370323124, 337.3921411106672),
            new Point(302.54686547351093, 59.079345054498475),
            new Point(163.48579149126033, 749.1901740238649),
            new Point(277.76518877799515, 420.1256294206885),
            new Point(108.51033510595356, 21.982331832110937),
            new Point(108.5270214151543, 160.55324389043895),
    };

    public static void main(String[] args) {
        Pair closestPair = getClosestPair(S);
        System.out.println(""Closest Pair is: "");
        System.out.println(closestPair.toString());

    }

    
    public static Pair getClosestPair(double[][] points) {
        /* Convert to Point[] */
        Point[] pts = new Point[points.length];
        int idx = 0;
        for (double[] pt : points) {
            pts[idx] = new Point(pt[0], pt[1]);
            idx++;
        }
        /* Use Point[] method to share common logic */
        return getClosestPair(pts);
    }

    
    public static Pair getClosestPair(Point[] pointsOrderedOnX) {
        /* Sort Points by X first order, see Point.java */
        Arrays.sort(pointsOrderedOnX);
        /* Create deep copy of pointsOrderedOnX array */
        Point[] pointsOrderedOnY = pointsOrderedOnX.clone();
        /* Sort pointsOrderedOnY by Y first order, see CompareY.java*/
        Arrays.sort(pointsOrderedOnY, new CompareY());
        /* Start recursion at low = startIndex, and high = endIndex */
        return distance(pointsOrderedOnX, 0, pointsOrderedOnX.length - 1, pointsOrderedOnY);

    }

    
    public static Pair distance(Point[] pointsOrderedOnX,
                                int low, int high, Point[] pointsOrderedOnY) {
        if (low >= high) {/* Recursive stopping condition */
            return null;
        } else if (low + 1 == high) { /* Only 2 Points possible to pair: pointsOrderedOnX[low], pointsOrderedOnX[high] */
            return new Pair(pointsOrderedOnX[low], pointsOrderedOnX[high]);
        } else {
            /* Divide and Conquer */
            int mid = (low + high) / 2;
            /* Split sorted in half into S1 and S2, let d1 and d2 denote the distance of the closest pair in each subset */
            Pair S1 = distance(pointsOrderedOnX, low, mid, pointsOrderedOnY); //d1
            Pair S2 = distance(pointsOrderedOnX, mid + 1, high, pointsOrderedOnY); // d2
            /* Find minDistance = min(d1,d2) distance */
            double d = 0;
            Pair p = null;
            if (S1 != null && S2 != null) {
                double leftPairDistance = S1.getDistance();
                double rightPairDistance = S1.getDistance();
                d = Math.min(leftPairDistance, rightPairDistance);
                p = leftPairDistance == d ? S1 : S2;
            } else if (S1 != null) {
                d = S1.getDistance();
                p = S1;
            } else if (S2 != null) {
                d = S2.getDistance();
                p = S2;
            }

            List<Point> stripL = new ArrayList<>();
            List<Point> stripR = new ArrayList<>();
            /* Obtain stripL and stripR */
            for (Point point : pointsOrderedOnY) {
                /*  if (p is in S1 and mid.x – p.x <= d) */
                if (point.getX() <= pointsOrderedOnX[mid].getX() && pointsOrderedOnX[mid].getX() - point.getX() <= d) {
                    stripL.add(point);
                    /* else if  (p is in S2 and p.x - mid.x <= d) */
                } else if (point.getX() > pointsOrderedOnX[mid].getX() && point.getX() - pointsOrderedOnX[mid].getX() <= d) {
                    stripR.add(point);
                }
            }

            int r = 0; // The index of the point in stripE
            for (Point point : stripL) {
                // Skip the points in stripR below p.y - d
                while (r < stripR.size() && stripR.get(r).getY() <= point.getY() - d) {
                    r++;
                }
                int r1 = r;
                while (r1 < stripR.size() && Math.abs(stripR.get(r1).getY() - point.getY()) <= d) {
                    /* Check if (p, q[r1]) is a possible closest pair */
                    if (new Pair(point, stripR.get(r1)).getDistance() < d) {
                        d = new Pair(point, stripR.get(r1)).getDistance();
                        p.setP1(point);
                        p.setP2(stripR.get(r1));
                    }
                    r1++;
                }
            }
            return p;
        }
    }
}
","import java.util.Arrays;

public class Point implements Comparable<Point> {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    @Override
    public int compareTo(Point other) {
        int xComparison = Double.compare(x, other.x);
        if (xComparison != 0) {
            return xComparison;
        }
        return Double.compare(y, other.y);
    }

    public double distanceTo(Point other) {
        double dx = x - other.x;
        double dy = y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
    }
}

class Pair {
    private Point p1;
    private Point p2;

    public Pair(Point p1, Point p2) {
        this.p1 = p1;
        this.p2 = p2;
    }

    public Point getP1() {
        return p1;
    }

    public Point getP2() {
        return p2;
    }

    public double getDistance() {
        return p1.distanceTo(p2);
    }
}

class CompareY implements java.util.Comparator<Point> {
    public int compare(Point p1, Point p2) {
        return Double.compare(p1.getY(), p2.getY());
    }
}

public class ClosestPair {
    public static Pair getClosestPair(double[][] points) {
        Point[] pointObjs = new Point[points.length];
        for (int i = 0; i < points.length; i++) {
            pointObjs[i] = new Point(points[i][0], points[i][1]);
        }
        Arrays.sort(pointObjs);

        return getClosestPair(pointObjs, 0, pointObjs.length - 1);
    }

    private static Pair getClosestPair(Point[] points, int low, int high) {
        if (low >= high) {
            return null;
        } else if (low + 1 == high) {
            return new Pair(points[low], points[high]);
        }

        int mid = (low + high) / 2;
        Pair pair1 = getClosestPair(points, low, mid);
        Pair pair2 = getClosestPair(points, mid + 1, high);
        Pair minPair = getMinPair(pair1, pair2);

        double minDistance = minPair.getDistance();
        Point[] strip = getStrip(points, low, high, points[mid].getX(), minDistance);
        Pair stripPair = getClosestStripPair(strip, minDistance);

        return getMinPair(minPair, stripPair);
    }

    private static Pair getMinPair(Pair pair1, Pair pair2) {
        if (pair1 == null) {
            return pair2;
        } else if (pair2 == null) {
            return pair1;
        }
        return pair1.getDistance() < pair2.getDistance() ? pair1 : pair2;
    }

    private static Point[] getStrip(Point[] points, int low, int high, double midX, double minDistance) {
        int count = 0;
        for (int i = low; i <= high; i++) {
            if (Math.abs(points[i].getX() - midX) < minDistance) {
                count++;
            }
        }
        Point[] strip = new Point",2,"import java.util.Arrays;

public class ClosestPairOfPoints {
    // Class to represent a point
    class Point {
        double x, y;

        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
    }

    // Class to represent a pair of points
    class Pair {
        Point p1, p2;

        public Pair(Point p1, Point p2) {
            this.p1 = p1;
            this.p2 = p2;
        }

        // Method to calculate the distance between two points
        public double getDistance() {
            double deltaX = p1.x - p2.x;
            double deltaY = p1.y - p2.y;
            return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        }
    }

    // Method to find the closest pair of points using a divide-and-conquer approach
    public Pair getClosestPair(Point[] points) {
        // Ensure at least 2 points
        if (points.length < 2) {
            return null;
        }

        // Sort the points based on x-coordinates (primary) and y-coordinates (secondary)
        Arrays.sort(points, (a, b) -> {
            if (a.x != b.x) {
                return Double.compare(a.x, b.x);
            } else {
                return Double.compare(a.y, b.y);
            }
        });

        // Find the closest pair recursively
        return closestPair(points, 0, points.length - 1);
    }

    // Recursive method to find the closest pair
    private Pair closestPair(Point[] points, int low, int high) {
        if (low >= high) {
            return null;
        }

        if (low + 1 == high) {
            return new Pair(points[low], points[high]);
        }

        // Calculate mid-point
        int mid = (low + high) / 2;

        // Find closest pairs in left and right halves
        Pair leftClosest = closestPair(points, low, mid);
        Pair rightClosest = closestPair(points, mid + 1, high);

        // Find the minimum distance between left and right pairs
        Pair minPair = (leftClosest.getDistance() < rightClosest.getDistance()) ? leftClosest : rightClosest;

        // Find the closest pair with one point in the left and one point in the right
        Pair stripClosest = stripClosest(points, low, mid, high, minPair.getDistance());

        // Return the closest pair among left, right, and strip
        return (stripClosest == null) ? minPair : stripClosest;
    }

    // Method to find the closest pair with one point in the left and one point in the right strip
    private Pair stripClosest(Point[] points, int low, int mid, int high, double minDistance) {
        Point midPoint = points[mid];
        Point[] strip = new Point[high - low + 1];
        int stripSize = 0;

        // Create a strip of points within the minDistance of the midPoint
        for (int i = low; i <= high; i++) {
            if (Math.abs(points[i].x - midPoint.x) < minDistance) {
                strip[stripSize++] = points[i];
            }
        }

        // Sort the strip based on y-coordinates
        Arrays.sort(strip, 0, stripSize, (a, b) -> Double.compare(a.y, b.y));

        // Compare each point in the strip with its neighbors
        for (int i = 0; i < stripSize; i++) {
            for (int j = i + 1; j < stripSize && (strip[j].y - strip[i].y) < minDistance; j++) {
                double distance = strip[i].getDistance(strip[j]);
                if (distance < minDistance) {
                    minDistance = distance;
                    return new Pair(strip[i], strip[j]);
                }
            }
        }

        return null;
    }

    public static void main(String[] args) {
        ClosestPairOfPoints closestPairFinder = new ClosestPairOfPoints();

        // Sample points
        Point[] points = {
            closestPairFinder.new Point(2, 3),
            closestPairFinder.new Point(12, 30),
            closestPairFinder.new Point(40, 50),
            closestPairFinder.new Point(5, 1),
            closestPairFinder.new Point(12, 10),
            closestPairFinder.new Point(3, 4)
        };

        Pair closestPair = closestPairFinder.getClosestPair(points);

        if (closestPair != null) {
            System.out.println(""The closest pair of points are ("" + closestPair.p1.x + "", "" + closestPair.p1.y + "") and ("" + closestPair.p2.x + "", "" + closestPair.p2.y + "")"");
            System.out.println(""The distance between them is "" + closestPair.getDistance());
        } else {
            System.out.println(""No closest pair found."");
        }
    }
}
",0.46054376657824936
0_Exercise22_08.java," /**
 * *22.8 (All prime numbers up to 10,000,000,000) Write a program that finds
 * all prime numbers up to 10,000,000,000. There are approximately
 * 455,052,511 such prime numbers. Your program should meet the following
 * requirements:
 * ■ Your program should store the prime numbers in a binary data file, named
 * PrimeNumbers.dat. When a new prime number is found, the number is
 * appended to the file.
 * ■ To find whether a new number is prime, your program should load the
 * prime numbers from the file to an array of the long type of size 10000.
 * If no number in the array is a divisor for the new number, continue to read
 * the next 10000 prime numbers from the data file, until a divisor is found
 * or all numbers in the file are read. If no divisor is found, the new number
 * is prime.
 * ■ Since this program takes a long time to finish, you should run it as a batch
 * job from a UNIX machine. If the machine is shut down and rebooted, your
 * program should resume by using the prime numbers stored in the binary data
 * file rather than start over from scratch.
 */","package ch_22.exercise22_08;

import java.io.*;


public class Exercise22_08 {
    private static PrimeStorage primeStorage;
    private static final String[] packageParts = Exercise22_08.class.getPackage().getName().split(""\\."");
    private static final String PATH = packageParts[0] + File.separator + packageParts[1] + File.separator + ""PrimeNumbers.dat"";
    private static long[] primeReadBuffer = new long[10000];
    private static final long UPPER_BOUND = 10_000_000_000L;
    private static boolean reachedEndOfBuffer = false;

    public static void main(String[] args) {
        try {
            primeStorage = new PrimeStorage(PATH);
            long checkNum = primeStorage.getNextNumberToCheck();
            // Check primes until reaching upper bound
            while (checkNum < UPPER_BOUND) {
                boolean isPrime = checkPrime(checkNum, primeStorage);
                if (isPrime) {
                    primeStorage.appendPrime(checkNum);
                }
                checkNum++;
            }

        } catch (Exception e) {
            System.err.println(""Could not create and/or read/write file needed to store prime numbers on this device. "" +
                    ""Please confirm Security Manager will allow create/read/write file storage."");
            System.exit(0);
        }

    }

    private static boolean checkPrime(long checkNum, PrimeStorage primeStorage) throws IOException {
        boolean loop = true;
        boolean isPrime = true;
        primeStorage.setPosition(0);

        while (loop) {
            primeReadBuffer = primeStorage.readNextPrimes();
            boolean isDivisible = isDivisible(primeReadBuffer, checkNum);
            if (isDivisible) {
                // checkNum is not prime
                loop = false;
                isPrime = false;
                break;
            } else if (reachedEndOfBuffer) {
                loop = false;
                break;
            }
        }

        return isPrime;
    }

    public static boolean isDivisible(long[] primes, long checkNum) {
        for (long prime : primes) {
            if (prime == 0) {
                reachedEndOfBuffer = true;
                return false;
            }
            if (checkNum % prime == 0) {
                return true;
            }
        }
        return false;
    }
}
","import java.io.*;

public class PrimeNumberGenerator {
    public static void main(String[] args) {
        long MAX_NUMBER = 10000000000L;
        int PRIME_CHUNK_SIZE = 10000;
        boolean[] isPrime = new boolean[(int)MAX_NUMBER];
        isPrime[0] = false;
        isPrime[1] = false;

        // Initialize isPrime[] array to true
        for (int i = 2; i < MAX_NUMBER; i++) {
            isPrime[i] = true;
        }

        // Mark all non-prime numbers
        for (int i = 2; i < Math.sqrt(MAX_NUMBER); i++) {
            if (isPrime[i]) {
                for (int j = i * i; j < MAX_NUMBER; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        // Load existing prime numbers from file
        long[] primes = new long[PRIME_CHUNK_SIZE];
        int numPrimes = 0;

        try (DataInputStream inputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(""PrimeNumbers.dat"")))) {
            while (true) {
                primes[numPrimes] = inputStream.readLong();
                numPrimes++;
            }
        } catch (FileNotFoundException e) {
            // The file doesn't exist yet, so start with an empty array
        } catch (EOFException e) {
            // End of file reached, do nothing
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Check new numbers for primality and append prime numbers to file
        try (DataOutputStream outputStream = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(""PrimeNumbers.dat"", true)))) {
            long start = numPrimes == 0 ? 2 : primes[numPrimes - 1] + 1;
            for (long i = start; i < MAX_NUMBER; i++) {
                if (isPrime[(int)i]) {
                    boolean isPrimeNumber = true;
                    for (int j = 0; j < numPrimes; j++) {
                        if (i % primes[j] == 0) {
                            isPrimeNumber = false;
                            break;
                        }
                    }
                    if (isPrimeNumber) {
                        primes[numPrimes] = i;
                        numPrimes++;
                        outputStream.writeLong(i);
                    }
                    if (numPrimes == PRIME_CHUNK_SIZE) {
                        break;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",2,"import java.io.*;
import java.util.ArrayList;

public class PrimeNumberFinder {

    public static void main(String[] args) {
        // Define the upper limit for prime numbers
        long upperLimit = 10_000_000_000L;

        // Create an array to store prime numbers
        ArrayList<Long> primes = new ArrayList<>();

        // Read existing prime numbers from the data file, if any
        try {
            FileInputStream fileIn = new FileInputStream(""PrimeNumbers.dat"");
            ObjectInputStream objIn = new ObjectInputStream(fileIn);
            primes = (ArrayList<Long>) objIn.readObject();
            objIn.close();
        } catch (FileNotFoundException e) {
            // File doesn't exist, initialize with initial prime
            primes.add(2L);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }

        // Start finding new prime numbers
        for (long num = primes.get(primes.size() - 1) + 1; num <= upperLimit; num++) {
            boolean isPrime = true;

            // Check if num is divisible by any prime number in the list
            for (Long prime : primes) {
                if (prime * prime > num) {
                    break;
                }
                if (num % prime == 0) {
                    isPrime = false;
                    break;
                }
            }

            if (isPrime) {
                primes.add(num);

                // Check if it's time to write primes to the file
                if (primes.size() % 10_000 == 0) {
                    savePrimesToFile(primes);
                }
            }
        }

        // Save the final list of prime numbers to the file
        savePrimesToFile(primes);
    }

    // Save the list of prime numbers to the data file
    private static void savePrimesToFile(ArrayList<Long> primes) {
        try {
            FileOutputStream fileOut = new FileOutputStream(""PrimeNumbers.dat"");
            ObjectOutputStream objOut = new ObjectOutputStream(fileOut);
            objOut.writeObject(primes);
            objOut.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",0.48279917671273154
0_Exercise25_01.java," /**
 * *25.1 (Add new methods in BST)
 * Add the following new methods in BST.
 * - Displays the nodes in a breadth-first traversal
 * public void breadthFirstTraversal()
 * - Returns the height of this binary tree
 * public int height()
 * Test Exercise25_01 (Add methods to BST):
 * see: {@link BST}
 */","package ch_25.exercise25_01;


public class Exercise25_01 {

    public static void main(String[] args) {
        BST<Integer> test = new BST<>();
        test.insert(2);
        test.insert(3);
        test.insert(4);
        test.insert(6);
        test.insert(7);
        test.insert(8);
        test.insert(12);
        test.insert(14);
        test.insert(19);
        test.insert(11);
        test.insert(13);
        test.insert(15);
        test.insert(21);

        System.out.println(""The height of the Binary Search Tree is "" + test.height());

        System.out.println(""Breadth-First Traversal results are: "");
        test.breadthFirstTraversal();

    }
}
","import java.util.LinkedList;
import java.util.Queue;

class Node {
    int val;
    Node left;
    Node right;

    public Node(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

class BST {
    Node root;

    public void insert(int val) {
        root = insert(root, val);
    }

    private Node insert(Node node, int val) {
        if (node == null) {
            return new Node(val);
        }
        if (val < node.val) {
            node.left = insert(node.left, val);
        } else if (val > node.val) {
            node.right = insert(node.right, val);
        }
        return node;
    }

    public void inorder() {
        inorder(root);
    }

    private void inorder(Node node) {
        if (node == null) {
            return;
        }
        inorder(node.left);
        System.out.print(node.val + "" "");
        inorder(node.right);
    }

    public void breadthFirstTraversal() {
        if (root == null) {
            return;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            Node current = queue.poll();
            System.out.print(current.val + "" "");
            if (current.left != null) {
                queue.offer(current.left);
            }
            if (current.right != null) {
                queue.offer(current.right);
            }
        }
    }

    public int height() {
        return height(root);
    }

    private int height(Node node) {
        if (node == null) {
            return 0;
        }
        int leftHeight = height(node.left);
        int rightHeight = height(node.right);
        return 1 + Math.max(leftHeight, rightHeight);
    }
}

public class Exercise25_01 {
    public static void main(String[] args) {
        BST bst = new BST();
        bst.insert(50);
        bst.insert(30);
        bst.insert(20);
        bst.insert(40);
        bst.insert(70);
        bst.insert(60);
        bst.insert(80);
        System.out.print(""Inorder traversal: "");
        bst.inorder();
        System.out.println();
        System.out.print(""Breadth-first traversal: "");
        bst.breadthFirstTraversal();
        System.out.println();
        System.out.println(""Height of the tree: "" + bst.height());
    }
}",2,"import java.util.LinkedList;
import java.util.Queue;

public class BST<E extends Comparable<E>> {
    private TreeNode<E> root;
    private int size;

    public BST() {
        root = null;
        size = 0;
    }

    public void breadthFirstTraversal() {
        if (root == null) {
            System.out.println(""Tree is empty."");
            return;
        }

        Queue<TreeNode<E>> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode<E> node = queue.poll();
            System.out.print(node.element + "" "");

            if (node.left != null) {
                queue.offer(node.left);
            }

            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }

    public int height() {
        return height(root);
    }

    private int height(TreeNode<E> node) {
        if (node == null) {
            return 0;
        } else {
            int leftHeight = height(node.left);
            int rightHeight = height(node.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
    }

    // Other BST methods (insert, delete, search, etc.) can be added here

    public static void main(String[] args) {
        BST<Integer> bst = new BST<>();
        bst.insert(50);
        bst.insert(30);
        bst.insert(70);
        bst.insert(20);
        bst.insert(40);
        bst.insert(60);
        bst.insert(80);

        System.out.print(""Breadth-First Traversal: "");
        bst.breadthFirstTraversal();
        System.out.println(""\nHeight of the tree: "" + bst.height());
    }

    private static class TreeNode<E> {
        protected E element;
        protected TreeNode<E> left;
        protected TreeNode<E> right;

        public TreeNode(E e) {
            element = e;
        }
    }

    // Other BST methods (insert, delete, search, etc.) can be implemented here
}",0.6446280991735537
0_BST.java," /**
 * 25.2 (Test full binary tree) A full binary tree is a binary tree with the leaves on the
 * same level. Add a method in the BST class to return true if the tree is a full
 * binary tree. (Hint: The number of nodes in a full binary tree is 2depth - 1.)
 * > Returns true if the tree is a 'full' binary tree
 * <p>
 * boolean isFullBST()
 */ /**
     * Create a default binary search tree
     */ /**
     * Create a binary search tree from an array of objects
     */ /**
     * Return true if the element is in the tree
     */ /**
     * Insert element e into the binary search tree.
     * Return true if the element is inserted successfully.
     */ /**
     * Inorder traversal from a subtree
     */ /**
     * Postorder traversal from the root
     */ /**
     * Postorder traversal from a subtree
     */ /**
     * Preorder traversal from the root
     */ /**
     * Preorder traversal from a subtree
     */ /**
     * Remove all elements from the tree
     */ /**
     * This inner class is static, because it does not access
     * any instance members defined in its outer class
     */ /**
     * Get the number of nodes in the tree
     */ /**
     * Returns the root of the tree
     */ /**
     * Returns a path from the root leading to the specified element
     */ /**
     * Delete an element from the binary search tree.
     * Return true if the element is deleted successfully.
     * Return false if the element is not in the tree.
     */ /**
     * Obtain an iterator. Use inorder.
     */ /**
         * Inorder traversal from the root
         */ /**
         * Inorder traversal from a subtree
         */ /**
         * More elements for traversing?
         */ /**
         * Get the current element and move to the next
         */ /**
         * Remove the current element
         */","package ch_25.exercise25_02;

import ch_25.AbstractTree;

import java.util.*;


public class BST<E extends Comparable<E>> extends AbstractTree<E> {
    protected TreeNode<E> root;
    protected int size = 0;

    /* *************************************** Exercise25_02 (Start) ********************************************** */

    public boolean isFullBST() {
        return isFullBST(root);
    }

    public boolean isFullBST(TreeNode<E> root) {
        if (root == null) {
            return true;
        } else if (root.left == null && root.right == null) {
            return true;
        } else if (root.left != null && root.right != null) {
            return isFullBST(root.left) && isFullBST(root.right);
        }
        return false;
    }
    /* *************************************** Exercise25_02 (End) *********************************************** */

    
    public BST() {
    }

    
    public BST(E[] objects) {
        for (int i = 0; i < objects.length; i++)
            insert(objects[i]);
    }

    
    @Override
    public boolean search(E e) {
        TreeNode<E> current = root; // Start from the root
        while (current != null) {
            if (e.compareTo(current.element) < 0) {
                current = current.left;
            } else if (e.compareTo(current.element) > 0) {
                current = current.right;
            } else // element matches current.element
                return true; // Element is found
        }
        return false;
    }

    
    @Override
    public boolean insert(E e) {
        if (root == null)
            root = createNewNode(e); // Create a new root
        else {
// Locate the parent node
            TreeNode<E> parent = null;
            TreeNode<E> current = root;
            while (current != null)
                if (e.compareTo(current.element) < 0) {
                    parent = current;
                    current = current.left;
                } else if (e.compareTo(current.element) > 0) {
                    parent = current;
                    current = current.right;
                } else
                    return false; // Duplicate node not inserted

            // Create the new node and attach it to the parent node
            if (e.compareTo(parent.element) < 0)
                parent.left = createNewNode(e);
            else
                parent.right = createNewNode(e);
        }
        size++;
        return true; // Element inserted successfully
    }

    protected TreeNode<E> createNewNode(E e) {
        return new TreeNode<>(e);
    }

    @Override
    /** Inorder traversal from the root */
    public void inorder() {
        inorder(root);
    }

    
    protected void inorder(TreeNode<E> root) {
        if (root == null) return;
        inorder(root.left);
        System.out.print(root.element + "" "");
        inorder(root.right);
    }

    
    @Override
    public void postorder() {
        postorder(root);
    }

    
    protected void preorder(TreeNode<E> root) {
        if (root == null) return;
        postorder(root.left);
        postorder(root.right);
        System.out.print(root.element + "" "");
    }

    
    @Override
    public void preorder() {
        preorder(root);
    }

    
    protected void postorder(TreeNode<E> root) {
        if (root == null) return;
        System.out.print(root.element + "" "");
        preorder(root.left);
        preorder(root.right);
    }

    
    public void clear() {
        root = null;
        size = 0;
    }

    
    public static class TreeNode<E extends Comparable<E>> {
        protected E element;
        protected TreeNode<E> left;

        protected TreeNode<E> right;

        public TreeNode(E e) {
            element = e;
        }
    }

    
    @Override
    public int getSize() {
        return size;
    }

    
    public TreeNode<E> getRoot() {
        return root;
    }

    
    public ArrayList<TreeNode<E>> path(E e) {
        ArrayList<TreeNode<E>> list =
                new ArrayList<>();
        TreeNode<E> current = root; // Start from the root
        while (current != null) {
            list.add(current); // Add the node to the list
            if (e.compareTo(current.element) < 0) {
                current = current.left;
            } else if (e.compareTo(current.element) > 0) {
                current = current.right;
            } else
                break;
        }
        return list; // Return an array list of nodes
    }

    
    @Override
    public boolean delete(E e) {
        // Locate the node to be deleted and also locate its parent node
        TreeNode<E> parent = null;
        TreeNode<E> current = root;
        while (current != null) {
            if (e.compareTo(current.element) < 0) {
                parent = current;
                current = current.left;
            } else if (e.compareTo(current.element) > 0) {
                parent = current;
                current = current.right;
            } else
                break; // Element is in the tree pointed at by current
        }
        if (current == null)
            return false; // Element is not in the tree

        // Case 1: current has no left child
        if (current.left == null) {
            // Connect the parent with the right child of the current node
            if (parent == null) {
                root = current.right;
            } else {
                if (e.compareTo(parent.element) < 0)
                    parent.left = current.right;
                else
                    parent.right = current.right;
            }
        } else {
            // Case 2: The current node has a left child.
            // Locate the rightmost node in the left subtree of
            // the current node and also its parent.
            TreeNode<E> parentOfRightMost = current;
            TreeNode<E> rightMost = current.left;
            while (rightMost.right != null) {
                parentOfRightMost = rightMost;
                rightMost = rightMost.right; // Keep going to the right
            }
            // Replace the element in current by the element in rightMost
            current.element = rightMost.element;
            // Eliminate rightmost node
            if (parentOfRightMost.right == rightMost)
                parentOfRightMost.right = rightMost.left;
            else
                // Special case: parentOfRightMost == current
                parentOfRightMost.left = rightMost.left;
        }
        size--;
        return true; // Element deleted successfully
    }

    
    @Override
    public Iterator<E> iterator() {
        return new InorderIterator();
    }

    // Inner class InorderIterator
    private class InorderIterator implements Iterator<E> {
        // Store the elements in a list
        private ArrayList<E> list = new ArrayList<>();
        private int current = 0; // Point to the current element in list

        public InorderIterator() {
            inorder(); // Traverse binary tree and store elements in list
        }

        
        private void inorder() {
            inorder(root);
        }

        
        private void inorder(TreeNode<E> root) {
            if (root == null) return;
            inorder(root.left);
            list.add(root.element);
            inorder(root.right);
        }

        
        @Override
        public boolean hasNext() {
            if (current < list.size())
                return true;
            return false;
        }

        
        @Override
        public E next() {
            return list.get(current++);
        }

        
        @Override
        public void remove() {
            delete(list.get(current)); // Delete the current element
            list.clear(); // Clear the list
            inorder(); // Rebuild the list
        }
    }
}","class Node {
    int val;
    Node left;
    Node right;
    
    public Node(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

class BST {
    Node root;

    public boolean isFullBinaryTree() {
        int depth = getDepth(root);
        return isFullBinaryTree(root, depth, 0);
    }

    private boolean isFullBinaryTree(Node node, int depth, int level) {
        if (node == null) {
            return true;
        }
        if (node.left == null && node.right == null) {
            return (depth == level + 1);
        }
        if (node.left == null || node.right == null) {
            return false;
        }
        return isFullBinaryTree(node.left, depth, level + 1) && isFullBinaryTree(node.right, depth, level + 1);
    }

    private int getDepth(Node node) {
        if (node == null) {
            return 0;
        }
        int leftDepth = getDepth(node.left);
        int rightDepth = getDepth(node.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}",2,"public class BST<E extends Comparable<E>> {
    // ... Other methods and variables ...

    // Returns true if the tree is a 'full' binary tree
    public boolean isFullBST() {
        return isFullBST(root);
    }

    private boolean isFullBST(TreeNode<E> node) {
        if (node == null) {
            return true;
        }

        int leftHeight = height(node.left);
        int rightHeight = height(node.right);

        if (leftHeight != rightHeight) {
            return false;
        }

        return isFullBST(node.left) && isFullBST(node.right);
    }

    // ... Other methods ...

    public static void main(String[] args) {
        BST<Integer> bst = new BST<>();
        bst.insert(50);
        bst.insert(30);
        bst.insert(70);
        bst.insert(20);
        bst.insert(40);
        bst.insert(60);
        bst.insert(80);

        System.out.println(""Is the tree a full binary tree? "" + bst.isFullBST());
    }

    // ... Other methods and inner classes ...
}
",0.49573690621193667
0_Exercise25_02.java," /**
 * 25.2 (Test full binary tree) A full binary tree is a binary tree with the leaves on the
 * same level. Add a method in the {@link BST} class to return true if the tree is a full
 * binary tree. (Hint: The number of nodes in a full binary tree is 2^depth - 1.)
 * /** Returns true if the tree is a full binary tree
 */","package ch_25.exercise25_02;


public class Exercise25_02 {

    public static void main(String[] args) {
        BST<Integer> test = new BST<>();
        test.insert(50);
        test.insert(40);
        test.insert(60);
        test.insert(30);
        test.insert(42);
        test.insert(54);
        test.insert(62);
        System.out.println("" The Binary Search Tree is "" + (test.isFullBST() ? ""full."" : """"));
    }
}
","class Node {
    int data;
    Node left, right;

    public Node(int data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

class BinaryTree {
    Node root;

    public BinaryTree() {
        this.root = null;
    }

    public boolean isFullBinaryTree(Node node) {
        // If the tree is empty, it is a full binary tree
        if (node == null) {
            return true;
        }

        // If both the left and right subtrees are null, it is a leaf node
        if (node.left == null && node.right == null) {
            return true;
        }

        // If either the left or right subtree is null, it is not a full binary tree
        if (node.left == null || node.right == null) {
            return false;
        }

        // Recursively check if both the left and right subtrees are full binary trees
        return isFullBinaryTree(node.left) && isFullBinaryTree(node.right);
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();
        tree.root = new Node(1);
        tree.root.left = new Node(2);
        tree.root.right = new Node(3);
        tree.root.left.left = new Node(4);
        tree.root.left.right = new Node(5);
        tree.root.right.left = new Node(6);
        tree.root.right.right = new Node(7);

        if (tree.isFullBinaryTree(tree.root)) {
            System.out.println(""The tree is a full binary tree."");
        } else {
            System.out.println(""The tree is not a full binary tree."");
        }
    }
}",2,"public class BST<E extends Comparable<E>> {
    // ... Other methods and variables ...

    // Returns true if the tree is a 'full' binary tree
    public boolean isFullBST() {
        int depth = depth(root);
        return isFullBST(root, depth, 0);
    }

    private int depth(TreeNode<E> node) {
        if (node == null) {
            return 0;
        } else {
            int leftDepth = depth(node.left);
            int rightDepth = depth(node.right);
            return Math.max(leftDepth, rightDepth) + 1;
        }
    }

    private boolean isFullBST(TreeNode<E> node, int depth, int level) {
        if (node == null) {
            return true;
        }
        if (node.left == null && node.right == null) {
            return level == depth - 1;
        }
        if (node.left == null || node.right == null) {
            return false;
        }
        return isFullBST(node.left, depth, level + 1) && isFullBST(node.right, depth, level + 1);
    }

    // ... Other methods ...

    public static void main(String[] args) {
        BST<Integer> bst = new BST<>();
        bst.insert(50);
        bst.insert(30);
        bst.insert(70);
        bst.insert(20);
        bst.insert(40);
        bst.insert(60);
        bst.insert(80);

        System.out.println(""Is the tree a full binary tree? "" + bst.isFullBST());
    }

    // ... Other methods and inner classes ...
}
",0.5020815986677769
0_BST.java," /**
 * **25.3 (Implement inorder traversal without using recursion) Implement the inorder
 * method in BST using a stack instead of recursion. Write a test program that
 * prompts the user to enter 10 integers, stores them in a BST, and invokes the
 * inorder method to display the elements.
 */ /**
     * Inorder traversal without recursion
     */ /**
     * Create a binary search tree from an array of objects
     */ /**
     * Return true if the element is in the tree
     */ /**
     * Insert element e into the binary search tree.
     * Return true if the element is inserted successfully.
     */ /**
     * Postorder traversal from the root
     */ /**
     * Postorder traversal from a subtree
     */ /**
     * Preorder traversal from the root
     */ /**
     * Preorder traversal from a subtree
     */ /**
     * Remove all elements from the tree
     */ /**
     * This inner class is static, because it does not access
     * any instance members defined in its outer class
     */ /**
     * Get the number of nodes in the tree
     */ /**
     * Returns the root of the tree
     */ /**
     * Returns a path from the root leading to the specified element
     */ /**
     * Delete an element from the binary search tree.
     * Return true if the element is deleted successfully.
     * Return false if the element is not in the tree.
     */ /**
     * Obtain an iterator. Use inorder.
     */ /**
         * Inorder traversal from the root
         */ /**
         * Inorder traversal from a subtree
         */ /**
         * More elements for traversing?
         */ /**
         * Get the current element and move to the next
         */ /**
         * Remove the current element
         */","package ch_25.exercise25_03;

import ch_25.AbstractTree;
import ch_25.GenericStack;

import java.util.*;


public class BST<E extends Comparable<E>> extends AbstractTree<E> {
    protected TreeNode<E> root;
    protected int size = 0;
    /* *************************************** Exercise25_03 (Start) ********************************************** */

    
    @Override
    public void inorder() {
        // If node is null return
        GenericStack<TreeNode<E>> stack = new GenericStack<>();
        // Initialize root node
        TreeNode<E> current = root;
        while (current != null || stack.getSize() > 0) {
            // Find the left most Node of the current Node
            while (current != null) {
                /* place pointer to a tree node on
                   the stack before traversing
                  the node's left sub-tree */
                stack.push(current);
                current = current.left;
            }

            /* Current must be NULL at this point */
            current = stack.pop();
            // Display node value
            System.out.print(current.element + "" "");

            /* we have visited the node and its
               left subtree.  Now, it's right
               subtree's turn */
            current = current.right;
        }
    }


    /* *************************************** Exercise25_03 (End) *********************************************** */


    public BST() {
    }


    
    public BST(E[] objects) {
        for (int i = 0; i < objects.length; i++)
            insert(objects[i]);
    }

    
    @Override
    public boolean search(E e) {
        TreeNode<E> current = root; // Start from the root
        while (current != null) {
            if (e.compareTo(current.element) < 0) {
                current = current.left;
            } else if (e.compareTo(current.element) > 0) {
                current = current.right;
            } else // element matches current.element
                return true; // Element is found
        }
        return false;
    }

    
    @Override
    public boolean insert(E e) {
        if (root == null)
            root = createNewNode(e); // Create a new root
        else {
// Locate the parent node
            TreeNode<E> parent = null;
            TreeNode<E> current = root;
            while (current != null)
                if (e.compareTo(current.element) < 0) {
                    parent = current;
                    current = current.left;
                } else if (e.compareTo(current.element) > 0) {
                    parent = current;
                    current = current.right;
                } else
                    return false; // Duplicate node not inserted

            // Create the new node and attach it to the parent node
            if (e.compareTo(parent.element) < 0)
                parent.left = createNewNode(e);
            else
                parent.right = createNewNode(e);
        }
        size++;
        return true; // Element inserted successfully
    }

    protected TreeNode<E> createNewNode(E e) {
        return new TreeNode<>(e);
    }


    
    @Override
    public void postorder() {
        postorder(root);
    }

    
    protected void preorder(TreeNode<E> root) {
        if (root == null) return;
        postorder(root.left);
        postorder(root.right);
        System.out.print(root.element + "" "");
    }

    
    @Override
    public void preorder() {
        preorder(root);
    }

    
    protected void postorder(TreeNode<E> root) {
        if (root == null) return;
        System.out.print(root.element + "" "");
        preorder(root.left);
        preorder(root.right);
    }

    
    public void clear() {
        root = null;
        size = 0;
    }

    
    public static class TreeNode<E extends Comparable<E>> {
        protected E element;
        protected TreeNode<E> left;

        protected TreeNode<E> right;

        public TreeNode(E e) {
            element = e;
        }
    }

    
    @Override
    public int getSize() {
        return size;
    }

    
    public TreeNode<E> getRoot() {
        return root;
    }

    
    public ArrayList<TreeNode<E>> path(E e) {
        ArrayList<TreeNode<E>> list =
                new ArrayList<>();
        TreeNode<E> current = root; // Start from the root
        while (current != null) {
            list.add(current); // Add the node to the list
            if (e.compareTo(current.element) < 0) {
                current = current.left;
            } else if (e.compareTo(current.element) > 0) {
                current = current.right;
            } else
                break;
        }
        return list; // Return an array list of nodes
    }

    
    @Override
    public boolean delete(E e) {
        // Locate the node to be deleted and also locate its parent node
        TreeNode<E> parent = null;
        TreeNode<E> current = root;
        while (current != null) {
            if (e.compareTo(current.element) < 0) {
                parent = current;
                current = current.left;
            } else if (e.compareTo(current.element) > 0) {
                parent = current;
                current = current.right;
            } else
                break; // Element is in the tree pointed at by current
        }
        if (current == null)
            return false; // Element is not in the tree

        // Case 1: current has no left child
        if (current.left == null) {
            // Connect the parent with the right child of the current node
            if (parent == null) {
                root = current.right;
            } else {
                if (e.compareTo(parent.element) < 0)
                    parent.left = current.right;
                else
                    parent.right = current.right;
            }
        } else {
            // Case 2: The current node has a left child.
            // Locate the rightmost node in the left subtree of
            // the current node and also its parent.
            TreeNode<E> parentOfRightMost = current;
            TreeNode<E> rightMost = current.left;
            while (rightMost.right != null) {
                parentOfRightMost = rightMost;
                rightMost = rightMost.right; // Keep going to the right
            }
            // Replace the element in current by the element in rightMost
            current.element = rightMost.element;
            // Eliminate rightmost node
            if (parentOfRightMost.right == rightMost)
                parentOfRightMost.right = rightMost.left;
            else
                // Special case: parentOfRightMost == current
                parentOfRightMost.left = rightMost.left;
        }
        size--;
        return true; // Element deleted successfully
    }

    
    @Override
    public Iterator<E> iterator() {
        return new InorderIterator();
    }

    // Inner class InorderIterator
    private class InorderIterator implements Iterator<E> {
        // Store the elements in a list
        private ArrayList<E> list = new ArrayList<>();
        private int current = 0; // Point to the current element in list

        public InorderIterator() {
            inorder(); // Traverse binary tree and store elements in list
        }

        
        private void inorder() {
            inorder(root);
        }

        
        private void inorder(TreeNode<E> root) {
            if (root == null) return;
            inorder(root.left);
            list.add(root.element);
            inorder(root.right);
        }

        
        @Override
        public boolean hasNext() {
            if (current < list.size())
                return true;
            return false;
        }

        
        @Override
        public E next() {
            return list.get(current++);
        }

        
        @Override
        public void remove() {
            delete(list.get(current)); // Delete the current element
            list.clear(); // Clear the list
            inorder(); // Rebuild the list
        }
    }
}","import java.util.Scanner;
import java.util.Stack;

public class BSTInorder {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        BST bst = new BST();

        System.out.print(""Enter 10 integers: "");
        for (int i = 0; i < 10; i++) {
            int value = input.nextInt();
            bst.insert(value);
        }

        bst.inorder();
    }
}

class BST {
    private TreeNode root;

    public BST() {
        root = null;
    }

    public void insert(int value) {
        root = insert(root, value);
    }

    private TreeNode insert(TreeNode node, int value) {
        if (node == null) {
            node = new TreeNode(value);
        } else if (value < node.value) {
            node.left = insert(node.left, value);
        } else if (value > node.value) {
            node.right = insert(node.right, value);
        }

        return node;
    }

    public void inorder() {
        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;

        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }

            current = stack.pop();
            System.out.print(current.value + "" "");
            current = current.right;
        }
    }

    private class TreeNode {
        private int value;
        private TreeNode left;
        private TreeNode right;

        public TreeNode(int value) {
            this.value = value;
            left = null;
            right = null;
        }
    }
}",2,"import java.util.*;

public class BinarySearchTree {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(""Please enter 10 integers:"");
        ArrayList<Integer> inputList = new ArrayList<>();
        
        for (int i = 0; i < 10; i++) {
            System.out.print(""Enter integer "" + (i + 1) + "": "");
            int num = scanner.nextInt();
            inputList.add(num);
        }
        
        TreeNode root = createBST(inputList);
        System.out.println(""Inorder traversal of the tree:"");
        inorderTraversal(root);
    }

    static class TreeNode {
        int value;
        TreeNode left;
        TreeNode right;

        TreeNode(int value) {
            this.value = value;
        }
    }

    public static TreeNode createBST(ArrayList<Integer> elements) {
        TreeNode root = null;
        for (int element : elements) {
            root = insert(root, element);
        }
        return root;
    }

    public static TreeNode insert(TreeNode root, int element) {
        if (root == null) {
            return new TreeNode(element);
        }
        if (element < root.value) {
            root.left = insert(root.left, element);
        } else if (element > root.value) {
            root.right = insert(root.right, element);
        }
        return root;
    }

    public static void inorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            current = stack.pop();
            System.out.print(current.value + "" "");
            current = current.right;
        }
    }
}",0.6573012939001849
0_Exercise25_03.java," /**
 * **25.3 (Implement inorder traversal without using recursion) Implement the inorder
 * method in {@link BST} using a stack instead of recursion. Write a test program that
 * prompts the user to enter 10 integers, stores them in a BST, and invokes the
 * inorder method to display the elements.
 */","package ch_25.exercise25_03;

import ch_25.exercise25_03.*;

import java.util.Scanner;


public class Exercise25_03 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter ten integers: "");
        BST<Integer> binarySearchTree = new BST<>();
        String[] line = input.nextLine().split("" "");

        for (String str : line) {
            binarySearchTree.insert(Integer.valueOf(str));
        }
        System.out.println(""Root is: "" + binarySearchTree.root.element);
        binarySearchTree.inorder();

    }
}
","import java.util.Scanner;
import java.util.Stack;

class Node {
    int val;
    Node left;
    Node right;

    public Node(int val) {
        this.val = val;
        left = null;
        right = null;
    }
}

class BST {
    Node root;

    public void insert(int val) {
        root = insert(root, val);
    }

    private Node insert(Node node, int val) {
        if (node == null) {
            return new Node(val);
        }
        if (val < node.val) {
            node.left = insert(node.left, val);
        } else if (val > node.val) {
            node.right = insert(node.right, val);
        }
        return node;
    }

    public void inorder() {
        if (root == null) {
            return;
        }
        Stack<Node> stack = new Stack<>();
        Node current = root;
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            current = stack.pop();
            System.out.print(current.val + "" "");
            current = current.right;
        }
    }
}

public class TestBST {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter 10 integers: "");
        int[] nums = new int[10];
        for (int i = 0; i < 10; i++) {
            nums[i] = input.nextInt();
        }
        BST bst = new BST();
        for (int num : nums) {
            bst.insert(num);
        }
        System.out.print(""Inorder traversal: "");
        bst.inorder();
    }
}",2,"import java.util.*;

public class BST {
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println(""This program stores 10 integers in a binary search tree and displays them in inorder traversal."");
        
        ArrayList<Integer> inputList = new ArrayList<>();
        
        for (int i = 0; i < 10; i++) {
            System.out.print(""Please enter integer number "" + (i + 1) + "": "");
            int num = scanner.nextInt();
            inputList.add(num);
        }
        
        TreeNode root = createBinarySearchTree(inputList);
        System.out.println(""Inorder traversal of the binary search tree:"");
        inorderTraversal(root);
    }

    static class TreeNode {
        int value;
        TreeNode left;
        TreeNode right;

        TreeNode(int value) {
            this.value = value;
        }
    }

    public static TreeNode createBinarySearchTree(ArrayList<Integer> elements) {
        TreeNode root = null;
        for (int element : elements) {
            root = insertElement(root, element);
        }
        return root;
    }

    public static TreeNode insertElement(TreeNode root, int element) {
        if (root == null) {
            return new TreeNode(element);
        }
        if (element < root.value) {
            root.left = insertElement(root.left, element);
        } else if (element > root.value) {
            root.right = insertElement(root.right, element);
        }
        return root;
    }

    public static void inorderTraversal(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode current = root;
        
        while (current != null || !stack.isEmpty()) {
            while (current != null) {
                stack.push(current);
                current = current.left;
            }
            current = stack.pop();
            System.out.print(current.value + "" "");
            current = current.right;
        }
    }
}
",0.5107913669064749
0_Exercise13_02.java," /**
 * 13.2 (Shuffle ArrayList) Write the following method that shuffles an ArrayList of
 * numbers:
 * public static void shuffle(ArrayList<Number> list)
 */","package ch_13;

import java.util.ArrayList;
import java.util.Random;


public class Exercise13_02 {
    static ArrayList<Number> testList;

    public static void main(String[] args) {
        testList = new ArrayList<>();

        for (int i = 0; i < 100; i++) {
            testList.add(i);
        }
        System.out.println(""Original list of random int Numbers: "");
        System.out.println(testList.toString());

        System.out.println(""Shuffling the list...."");
        shuffle(testList);

        System.out.println(""Shuffle completed: "");
        System.out.println(testList.toString());

        testShuffled(testList);

    }

    public static void shuffle(ArrayList<Number> list) {
        for (int i = 0; i < list.size(); i++) {
            int randIdx = new Random().nextInt(list.size());
            Number numberFromCurrIdx = list.get(i);
            Number randomRemovedNumber = list.get(randIdx);
            //Swap Numbers
            list.set(i, randomRemovedNumber);
            list.set(randIdx, numberFromCurrIdx);
        }
    }

    static void testShuffled(ArrayList<Number> list) {
        System.out.println(""Testing shuffled list contains same contents as original list...."");
        ArrayList<Number> copyOfShuffledList = new ArrayList<>(list);
        copyOfShuffledList.sort((o1, o2) -> {
            if (o1.intValue() == o2.intValue()) return 0;
            return o1.intValue() > o2.intValue() ? 1 : -1;
        });
        boolean equalSortedArray = true;
        int i = 0;
        for (; i < 100; i++) {
            if (i != copyOfShuffledList.get(i).intValue()) {
                equalSortedArray = false;
                break;
            }
        }
        if (!equalSortedArray) System.out.println(""Shuffled array does not have same contents as original, @see array"" +
                "" index: "" + i);
        else System.out.println(""Shuffled array has same contents as original array: "" + equalSortedArray);
    }
}
","import java.util.ArrayList;
import java.util.Random;

public class ShuffleArrayList {
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= 10; i++) {
            numbers.add(i);
        }
        System.out.println(""Original list: "" + numbers);
        shuffle(numbers);
        System.out.println(""Shuffled list: "" + numbers);
    }
    
    public static void shuffle(ArrayList<Integer> list) {
        Random rand = new Random();
        for (int i = list.size() - 1; i > 0; i--) {
            int j = rand.nextInt(i + 1);
            int temp = list.get(i);
            list.set(i, list.get(j));
            list.set(j, temp);
        }
    }
}",2,"import java.util.ArrayList;
import java.util.Random;

public class ShuffleArrayList {

    public static void main(String[] args) {
        ArrayList<Number> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2.0);
        numbers.add(3.0f);
        numbers.add(4L);

        System.out.println(""Original ArrayList: "" + numbers);
        shuffle(numbers);
        System.out.println(""Shuffled ArrayList: "" + numbers);
    }

    public static void shuffle(ArrayList<Number> list) {
        int size = list.size();
        Random random = new Random();

        for (int i = 0; i < size; i++) {
            int randomIndex = random.nextInt(size);

            // Swap elements at i and randomIndex
            Number temp = list.get(i);
            list.set(i, list.get(randomIndex));
            list.set(randomIndex, temp);
        }

        System.out.println(""Shuffling complete!"");
    }
}
",0.7801628423390081
0_Exercise13_03.java," /**
 * 13.3 (Sort ArrayList) Write the following method that sorts an ArrayList of numbers.
 * public static void sort(ArrayList<Number> list)
 */","package ch_13;

import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;


public class Exercise13_03 {
    static ArrayList<Number> testList;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
//        testList = getRandomTestList();
        testList = new ArrayList<>();
        System.out.print(""Enter five integers and five doubles: "");

        for (int i = 0; i < 5; i++) {
            Number n = in.nextInt();
            testList.add(n);
        }
        for (int i = 0; i < 5; i++) {
            Number n = in.nextDouble();
            testList.add(n);
        }
        sort(testList);
        for (Number n : testList) {
            System.out.print(n + "" "");
        }

        // System.out.println(testList.toString());

//        System.out.println(""Checking list is correctly sorted...."");
//        System.out.println(""Is list correctly sorted: "" + isArraySorted(testList));
        in.close();
    }


    public static void sort(ArrayList<Number> list) {
        boolean isSorted = false;
        while (!isSorted) {
            isSorted = true;
            for (int i = 0; i < list.size() - 1; i++) {
                if (list.get(i).doubleValue() > list.get(i + 1).doubleValue()) {
                    isSorted = false;
                    Number smallNum = list.get(i + 1);
                    list.set(i + 1, list.get(i));
                    list.set(i, smallNum);
                }
            }
        }
    }

    static ArrayList<Number> getRandomTestList() {
        ArrayList<Number> list = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < 100; i++) {
            list.add(random.nextInt(100));
        }
        return list;
    }

    static boolean isArraySorted(ArrayList<Number> list) {
        for (int i = 1; i < list.size(); i++) {
            if (list.get(i).intValue() < list.get(i - 1).intValue()) {
                return false;
            }
        }
        return true;
    }
}","import java.util.ArrayList;
import java.util.Collections;

public class SortArrayList {
    public static void main(String[] args) {
        ArrayList<Number> numbers = new ArrayList<>();
        numbers.add(3.14);
        numbers.add(2);
        numbers.add(-1.5);
        numbers.add(10);
        System.out.println(""Original list: "" + numbers);
        sort(numbers);
        System.out.println(""Sorted list: "" + numbers);
    }
    
    public static void sort(ArrayList<Number> list) {
        Collections.sort(list);
    }
}",2,"import java.util.ArrayList;
import java.util.Collections;

public class SortArrayList {

    public static void main(String[] args) {
        ArrayList<Number> numbers = new ArrayList<>();
        numbers.add(4.0);
        numbers.add(1);
        numbers.add(3.0);
        numbers.add(2.0f);

        System.out.println(""Original ArrayList: "" + numbers);
        sort(numbers);
        System.out.println(""Sorted ArrayList: "" + numbers);
    }

    public static void sort(ArrayList<Number> list) {
        int size = list.size();

        // Bubble sort algorithm (a very simple sorting method)
        boolean swapped;
        do {
            swapped = false;
            for (int i = 1; i < size; i++) {
                if (list.get(i - 1).doubleValue() > list.get(i).doubleValue()) {
                    // Swap elements at i-1 and i
                    Number temp = list.get(i - 1);
                    list.set(i - 1, list.get(i));
                    list.set(i, temp);
                    swapped = true;
                }
            }
        } while (swapped);
        
        System.out.println(""Sorting complete!"");
    }
}",0.6671732522796353
0_Exercise13_18.java," /**
 * 13.18 (Use the Rational class) Write a program that computes the following summation series using the Rational class:
 * 1/2 + 2/3 + 3/4 + ... + 98/99 + 99/100
 * You will discover that the output is incorrect because of integer overflow (too
 * large).
 * <p>
 * To fix this problem, see Programming Exercise 13.15.
 */","package ch_13.exercise13_18;

import ch_13.exercise13_15.Rational;


public class Exercise13_18 {
    public static void main(String[] args) {
        Rational resultRational = new Rational();
        long i = 2;
        while (i <= 100) {
            Rational rational = new Rational(i - 1, i);
            System.out.print(rational.getNumerator() + ""/"" + rational.getDenominator());

            if (i == 100) System.out.print("" = "");
            else if (i % 10 == 0) System.out.println("" + "");
            else System.out.print("" + "");

            resultRational = resultRational.add(rational);
            i++;
        }
        System.out.println(resultRational.getNumerator() + "" / "" + resultRational.getDenominator());

    }
}
","class Rational {
    private int numerator;
    private int denominator;

    public Rational(int numerator, int denominator) {
        if (denominator == 0) {
            throw new IllegalArgumentException(""Denominator cannot be zero."");
        }

        // Make sure the negative sign is in the numerator only
        if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }

        this.numerator = numerator;
        this.denominator = denominator;
    }

    public Rational add(Rational other) {
        int commonDenominator = this.denominator * other.denominator;
        int sumNumerator = this.numerator * other.denominator + other.numerator * this.denominator;

        return new Rational(sumNumerator, commonDenominator);
    }

    public double toDouble() {
        return (double) this.numerator / this.denominator;
    }

    public String toString() {
        return this.numerator + ""/"" + this.denominator;
    }
}

public class SummationSeries {
    public static void main(String[] args) {
        Rational sum = new Rational(0, 1);

        for (int i = 1; i <= 99; i++) {
            Rational term = new Rational(i, i + 1);
            sum = sum.add(term);
        }

        System.out.println(""Summation series result: "" + sum.toDouble());
    }
}",2,"public class RationalSumSeries {

    public static void main(String[] args) {
        Rational sum = new Rational(0, 1);

        for (int i = 1; i <= 99; i++) {
            Rational term = new Rational(i, i + 1);
            sum = sum.add(term);
        }

        System.out.println(""The summation series result is: "" + sum.toDouble());
    }

    static class Rational {
        int numerator;
        int denominator;

        Rational(int numerator, int denominator) {
            this.numerator = numerator;
            this.denominator = denominator;
        }

        double toDouble() {
            return (double) numerator / denominator;
        }

        Rational add(Rational other) {
            int newNumerator = this.numerator * other.denominator + other.numerator * this.denominator;
            int newDenominator = this.denominator * other.denominator;
            return new Rational(newNumerator, newDenominator);
        }
    }
}
",0.5134422772799156
0_Complex.java," /**
 * 13.17 (Math: The Complex class) A complex number is a number in the form a + bi,
 * -where a and b are real numbers and i is SQRT(-1). The numbers a and b are known
 * as the real part and imaginary part of the complex number, respectively. You can
 * perform addition, subtraction, multiplication, and division for complex numbers
 * using the following formulas:
 * a + bi + c + di = (a + c) + (b + d)i
 * a + bi - (c + di) = (a - c) + (b - d)i
 * (a + bi)*(c + di) = (ac - bd) + (bc + ad)i
 * (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2)
 * <p>
 * You can also obtain the absolute value for a complex number using the following
 * formula:
 * |a + bi|  = SQRT(a2 + b2)
 * (A complex number can be interpreted as a point on a plane by identifying the (a,b)
 * values as the coordinates of the point. The absolute value of the complex number
 * corresponds to the distance of the point to the origin, as shown in Figure 13.10b.)
 * <p>
 * Design a class named Complex for representing complex numbers and the
 * methods add, subtract, multiply, divide, and abs for performing complex number operations,
 * and override toString method for returning a string representation for a complex number.
 * The toString method returns (a + bi) as a string. If b is 0, it simply returns a.
 * Your Complex class should also implement the Cloneable interface.
 * <p>
 * Provide three constructors Complex(a, b), Complex(a), and Complex().
 * Complex() creates a Complex object for number 0 and Complex(a) creates a Complex object with 0 for b.
 * Also provide the getRealPart() and getImaginaryPart() methods for returning the real and imaginary part
 * of the complex number, respectively.
 */ /**
     * Example addition:  (a + bi) + (c + di) = (a + c) + (b + d)i
     *
     * @param complex Complex number to add
     * @return the addition result
     */ /**
     * Subtract example:
     * a + bi - (c + di) = (a - c) + (b - d)i
     *
     * @param complex
     * @return
     */ /**
     * (a + bi)*(c + di) = (ac - bd) + (bc + ad)i
     *
     * @param complex
     * @return
     */ /**
     * (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2)
     *
     * @param complex
     * @return
     */","package ch_13.exercise13_20;


public class Complex extends Number implements Cloneable {

    private double a;
    private double b;
    private static double i = Math.sqrt(-1);

    public Complex() {
        this(0);
    }

    public Complex(double a) {
        this(a, 0);
    }

    public Complex(double a, double b) {
        this.a = a;
        this.b = b;
    }

    
    public double add(Complex complex) {
        return (this.a + complex.a) + (this.b + complex.b) * i;
    }

    
    public double subtract(Complex complex) {
        return (this.a - complex.a) + (this.b - complex.b) * i;

    }

    
    public double multiply(Complex complex) {
        return (this.a * complex.a - this.b * complex.b) + ((this.b * complex.a + this.a * complex.b) * i);
    }

    
    public double divide(Complex complex) {
        return (this.a * complex.a + this.b * complex.b) / (Math.pow(complex.a, 2) + Math.pow(complex.b, 2)) + ((this.b * complex.a - this.a * complex.b) * i) / (Math.pow(complex.a, 2) + Math.pow(complex.b, 2));
    }

    public double abs(Complex complex) {
        return Math.sqrt(Math.pow(this.a, 2) + Math.pow(this.b, 2));
    }

    public double getRealPart() {
        return a;
    }

    public double getImaginaryPart() {
        return b * i;
    }

    @Override
    public Complex clone() throws CloneNotSupportedException {
        return (Complex) super.clone();

    }

    @Override
    public int intValue() {
        return (int) Math.round(a + b * i);
    }

    @Override
    public long longValue() {
        return Math.round(a + b * i);
    }

    @Override
    public float floatValue() {
        return (float) (a + b * i);
    }

    @Override
    public double doubleValue() {
        return a + b * i;
    }

    @Override
    public String toString() {
        if (b == 0)
            return String.format(""%2.1f"", a);
        else
            return String.format(""%2.1f + %2.4fi"", a, b);
    }

}
","public class Complex implements Cloneable {
    private double real;
    private double imag;

    public Complex(double real, double imag) {
        this.real = real;
        this.imag = imag;
    }

    public double getReal() {
        return real;
    }

    public double getImag() {
        return imag;
    }

    public Complex add(Complex other) {
        double realSum = this.real + other.real;
        double imagSum = this.imag + other.imag;

        return new Complex(realSum, imagSum);
    }

    public Complex subtract(Complex other) {
        double realDiff = this.real - other.real;
        double imagDiff = this.imag - other.imag;

        return new Complex(realDiff, imagDiff);
    }

    public Complex multiply(Complex other) {
        double realProd = this.real * other.real - this.imag * other.imag;
        double imagProd = this.real * other.imag + this.imag * other.real;

        return new Complex(realProd, imagProd);
    }

    public Complex divide(Complex other) {
        double denom = other.real * other.real + other.imag * other.imag;
        double realQuot = (this.real * other.real + this.imag * other.imag) / denom;
        double imagQuot = (this.imag * other.real - this.real * other.imag) / denom;

        return new Complex(realQuot, imagQuot);
    }

    public double abs() {
        return Math.sqrt(this.real * this.real + this.imag * this.imag);
    }

    @Override
    public String toString() {
        if (this.imag == 0) {
            return Double.toString(this.real);
        } else {
            return String.format(""(%f + %fi)"", this.real, this.imag);
        }
    }

    @Override
    public Complex clone() {
        return new Complex(this.real, this.imag);
    }
}",3,"public class Complex implements Cloneable {
    private double realPart;
    private double imaginaryPart;

    public Complex(double realPart, double imaginaryPart) {
        this.realPart = realPart;
        this.imaginaryPart = imaginaryPart;
    }

    public Complex(double realPart) {
        this.realPart = realPart;
        this.imaginaryPart = 0.0;
    }

    public Complex() {
        this.realPart = 0.0;
        this.imaginaryPart = 0.0;
    }

    public double getRealPart() {
        return this.realPart;
    }

    public double getImaginaryPart() {
        return this.imaginaryPart;
    }

    public Complex add(Complex complex) {
        double newRealPart = this.realPart + complex.getRealPart();
        double newImaginaryPart = this.imaginaryPart + complex.getImaginaryPart();
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex subtract(Complex complex) {
        double newRealPart = this.realPart - complex.getRealPart();
        double newImaginaryPart = this.imaginaryPart - complex.getImaginaryPart();
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex multiply(Complex complex) {
        double newRealPart = (this.realPart * complex.getRealPart()) - (this.imaginaryPart * complex.getImaginaryPart());
        double newImaginaryPart = (this.realPart * complex.getImaginaryPart()) + (this.imaginaryPart * complex.getRealPart());
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex divide(Complex complex) {
        double divisor = Math.pow(complex.getRealPart(), 2) + Math.pow(complex.getImaginaryPart(), 2);
        double newRealPart = ((this.realPart * complex.getRealPart()) + (this.imaginaryPart * complex.getImaginaryPart())) / divisor;
        double newImaginaryPart = ((this.imaginaryPart * complex.getRealPart()) - (this.realPart * complex.getImaginaryPart())) / divisor;
        return new Complex(newRealPart, newImaginaryPart);
    }

    public double abs() {
        return Math.sqrt(Math.pow(this.realPart, 2) + Math.pow(this.imaginaryPart, 2));
    }

    @Override
    public String toString() {
        if (this.imaginaryPart == 0) {
            return String.format(""%.2f"", this.realPart);
        } else if (this.imaginaryPart < 0) {
            return String.format(""%.2f - %.2fi"", this.realPart, -this.imaginaryPart);
        } else {
            return String.format(""%.2f + %.2fi"", this.realPart, this.imaginaryPart);
        }
    }

    @Override
    public Complex clone() {
        return new Complex(this.realPart, this.imaginaryPart);
    }
}",0.6865435356200528
0_Exercise13_11.java," /**
 * 13.11 (The Octagon class) Write a class named Octagon that extends
 * GeometricObject and implements the Comparable and Cloneable interfaces.
 * Assume that all eight sides of the octagon are of equal length. The area can
 * be computed using the following formula:
 * area = (2 + 4/22)* side * side
 * Draw the UML diagram that involves Octagon, GeometricObject,
 * Comparable, and Cloneable.
 * @see Octagon
 * <p>
 * Write a test program that creates an Octagon
 * object with side value 5 and displays its area and perimeter. Create a new object
 * using the clone method and compare the two objects using the compareTo
 * method.
 */","package ch_13.exercise13_11;



public class Exercise13_11 {
    public static void main(String[] args) {
        Octagon octagon1 = new Octagon(5);
        System.out.println(""Octagon1 perimeter = "" + octagon1.getPerimeter() + "", area = "" + octagon1.getArea());
        Octagon octagon2 = null;
        System.out.println(""Cloning Octagon1 ......."");
        try {
             octagon2 = octagon1.clone();
        }catch (CloneNotSupportedException cnse){
            cnse.printStackTrace();
        }

        System.out.println(""octagon1.compareTo(octagon 2): "" + octagon1.compareTo(octagon2));
        System.out.println(""Octagon 2 area = "" + octagon2.getArea() + "", perimeter = "" + octagon2.getPerimeter());


    }

}
","public class Octagon extends GeometricObject implements Comparable<Octagon>, Cloneable {
    private double side;

    public Octagon() {
        this.side = 1;
    }

    public Octagon(double side) {
        this.side = side;
    }

    public double getSide() {
        return side;
    }

    public void setSide(double side) {
        this.side = side;
    }

    @Override
    public double getArea() {
        return (2 + 4/Math.sqrt(2))* side * side;
    }

    @Override
    public double getPerimeter() {
        return 8 * side;
    }

    @Override
    public int compareTo(Octagon o) {
        if (this.getArea() > o.getArea()) {
            return 1;
        } else if (this.getArea() < o.getArea()) {
            return -1;
        } else {
            return 0;
        }
    }

    @Override
    public Octagon clone() {
        try {
            return (Octagon) super.clone();
        } catch (CloneNotSupportedException ex) {
            return null;
        }
    }
}",3,"public class Octagon extends GeometricObject implements Comparable<Octagon>, Cloneable {
    private double side;

    public Octagon(double side) {
        this.side = side;
    }

    public double getSide() {
        return side;
    }

    public void setSide(double side) {
        this.side = side;
    }

    @Override
    public double getArea() {
        return (2 + 4 / 22) * side * side;
    }

    @Override
    public double getPerimeter() {
        return 8 * side;
    }

    @Override
    public int compareTo(Octagon other) {
        if (this.side < other.side) {
            return -1;
        } else if (this.side > other.side) {
            return 1;
        } else {
            return 0;
        }
    }

    @Override
    public Octagon clone() {
        try {
            return (Octagon) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    public static void main(String[] args) {
        Octagon octagon1 = new Octagon(5);
        Octagon octagon2 = octagon1.clone();

        System.out.println(""Octagon 1 - Area: "" + octagon1.getArea() + "", Perimeter: "" + octagon1.getPerimeter());
        System.out.println(""Octagon 2 - Area: "" + octagon2.getArea() + "", Perimeter: "" + octagon2.getPerimeter());

        int comparisonResult = octagon1.compareTo(octagon2);
        if (comparisonResult == 0) {
            System.out.println(""Octagon 1 and Octagon 2 are equal."");
        } else if (comparisonResult < 0) {
            System.out.println(""Octagon 1 is smaller than Octagon 2."");
        } else {
            System.out.println(""Octagon 1 is larger than Octagon 2."");
        }
    }
}

class GeometricObject {
    // Some geometric object methods can be defined here, but we'll keep it simple for demonstration.
}",0.6090390522158842
0_Octagon.java," /**
 * 13.11 (The Octagon class) Write a class named Octagon that extends
 * GeometricObject and implements the Comparable and Cloneable interfaces.
 * Assume that all eight sides of the octagon are of equal length. The area can
 * be computed using the following formula:
 * area = (2 + 4/22)* side * side
 * Draw the UML diagram that involves Octagon, GeometricObject,
 * Comparable, and Cloneable:
 *
                                     //_________________________ UML DIAGRAM ____________________________*
                                     /*                                                                                                                                        *
                                     *                                                   GeometricObject                                                         *
                                     *------------------------------------------------------------------*
                                     * -color: String                                                                                                        *
                                     * -filled: boolean                                                                                                        *
                                     * -dateCreated : java.util.Date                                                                        *
                                     *                                                                                                                                        *
                                     *------------------------------------------------------------------*
                                     *          #GeometricObject()                                                                                                *
                                     *          #GeometricObject(color:String,filled:boolean)                                        *
                                     *                                                                                                                                          *
                                     *                                                                                                                                         *
                                     *         +getColor(): String                                                                                                *
                                     *         +setColor(color: String): void                                                                        *
                                     *         +isFilled(): boolean                                                                                        *
                                     *         +setFilled(filled: boolean): void                                                                *
                                     *         +getDateCreated(): java.util.Date                                                                *
                                     *                                                                                                                                  *
                                     *          +toString(): String                                                                                        *
                                     *         /+getArea()/: double/                                                                                        *
                                     *         /+getPerimeter(): double/                                                                                *
                                     * _________________________________________________________________| */","package ch_13.exercise13_11;

import ch_13.exercise13_01.GeometricObject;


                                    /*					              ^
                                                				      ^
                                                			    	  ^
                                                					  ^
                                                /*_________________UML Diagram__________________*
                                                 *______________________________________________*
                                                 *                   Octagon  	        	    *
                                                 *______________________________________________*
                                                 * 							  			 		*
                                                 *  side: double 								*
                                                 *  						  					*			 _____________________________________
 _____________________________________           * 	Octagon()									*			 *	        <<interface>>            *
 *	        <<interface>>            *           * 						  					    * 			 *  java.lang.Comparable<Octagon>    *
 *      java.lang.Cloneable          *           *  Octagon(side:double)                        * >>>>>>>>>> *___________________________________*
 *___________________________________* <<<<<<<<< *  											*			 *	+compareTo(obj:Octagon):int      *
 *	    +clone():Octagon             *           * 	getArea(): double							*			 *___________________________________*
 *___________________________________*           * 	getPerimeter(): double						*
                                                 * 	getSide(): double                           *
                                                 *  	    				                    *
                                                 *  +clone(): Octagon                           *
                                                 * 	+toString(): String							*
                                                 * 	+compareTo():int							*
                                                 * _____________________________________________*
                                                 */
public class Octagon extends GeometricObject implements Comparable<Octagon>, Cloneable {
    private double side;

    public Octagon(){super();}

    public Octagon(double side){
        this.side = side;
    }



    @Override
    public Octagon clone() throws CloneNotSupportedException {
        return (Octagon) super.clone();

    }

    @Override
    public String toString() {
        return ""Octagon{"" +
                ""side="" + side +
                '}';
    }

    @Override
    public double getArea() {
        return (2 + (4 / 22)) * side * side;
    }

    @Override
    public double getPerimeter() {
        return 8 * side;
    }

    @Override
    public int compareTo(Octagon o) {
        return Double.compare(this.side,o.side);
    }

}
","public class Octagon extends GeometricObject implements Comparable<Octagon>, Cloneable {
    private double side;

    public Octagon() {
        this(1.0);
    }

    public Octagon(double side) {
        this.side = side;
    }

    public double getSide() {
        return side;
    }

    public void setSide(double side) {
        this.side = side;
    }

    public double getArea() {
        return (2 + 4 / Math.sqrt(2)) * side * side;
    }

    public double getPerimeter() {
        return 8 * side;
    }

    @Override
    public int compareTo(Octagon o) {
        if (this.side < o.side)
            return -1;
        else if (this.side > o.side)
            return 1;
        else
            return 0;
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
",3,"import java.util.Date;

public class Octagon extends GeometricObject implements Comparable<Octagon>, Cloneable {
    private double side;

    public Octagon(double side) {
        this.side = side;
    }

    public double getSide() {
        return side;
    }

    public void setSide(double side) {
        this.side = side;
    }

    @Override
    public double getArea() {
        return (2 + 4 / 22) * side * side;
    }

    @Override
    public double getPerimeter() {
        return 8 * side;
    }

    @Override
    public int compareTo(Octagon other) {
        if (this.side < other.side) {
            return -1;
        } else if (this.side > other.side) {
            return 1;
        } else {
            return 0;
        }
    }

    @Override
    public Octagon clone() {
        try {
            return (Octagon) super.clone();
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    public static void main(String[] args) {
        Octagon octagon1 = new Octagon(5);
        Octagon octagon2 = octagon1.clone();

        System.out.println(""Octagon 1 - Area: "" + octagon1.getArea() + "", Perimeter: "" + octagon1.getPerimeter());
        System.out.println(""Octagon 2 - Area: "" + octagon2.getArea() + "", Perimeter: "" + octagon2.getPerimeter());

        int comparisonResult = octagon1.compareTo(octagon2);
        if (comparisonResult == 0) {
            System.out.println(""Octagon 1 and Octagon 2 are equal."");
        } else if (comparisonResult < 0) {
            System.out.println(""Octagon 1 is smaller than Octagon 2."");
        } else {
            System.out.println(""Octagon 1 is larger than Octagon 2."");
        }
    }
}

class GeometricObject {
    private String color;
    private boolean filled;
    private Date dateCreated;

    public GeometricObject() {
        this.color = ""white"";
        this.filled = false;
        this.dateCreated = new Date();
    }

    public GeometricObject(String color, boolean filled) {
        this.color = color;
        this.filled = filled;
        this.dateCreated = new Date();
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public boolean isFilled() {
        return filled;
    }

    public void setFilled(boolean filled) {
        this.filled = filled;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    @Override
    public String toString() {
        return ""Created on "" + dateCreated + ""\nColor: "" + color + ""\nFilled: "" + filled;
    }
}",0.44303350970017635
0_Exercise13_17.java," /**
 * 13.17 (Math: The Complex class) A complex number is a number in the form a + bi,
 * where a and b are real numbers and i is SQRT(-1). The numbers a and b are known
 * as the real part and imaginary part of the complex number, respectively. You can
 * perform addition, subtraction, multiplication, and division for complex numbers
 * using the following formulas:
 * a + bi + c + di = (a + c) + (b + d)i
 * a + bi - (c + di) = (a - c) + (b - d)i
 * (a + bi)*(c + di) = (ac - bd) + (bc + ad)i
 * (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2)
 * <p>
 * You can also obtain the absolute value for a complex number using the following
 * formula:
 * a + bi  = 2a2 + b2
 * (A complex number can be interpreted as a point on a plane by identifying the (a,b)
 * values as the coordinates of the point. The absolute value of the complex number
 * corresponds to the distance of the point to the origin, as shown in Figure 13.10b.)
 * Design a class named Complex for representing complex numbers and the
 * methods add, subtract, multiply, divide, and abs for performing complex number operations,
 * and override toString method for returning a string representation for a complex number.
 * The toString method returns (a + bi) as a string. If b is 0, it simply returns a.
 * Your Complex class should also implement the Cloneable interface.
 * <p>
 * Provide three constructors Complex(a, b), Complex(a), and Complex().
 * Complex() creates a Complex object for number 0 and Complex(a) creates a Complex object with 0 for b.
 * Also provide the getRealPart() and getImaginaryPart() methods for returning the real and imaginary part
 * of the complex number, respectively. 
 * <p>
 * <p>
 * Write a test program that prompts the user to enter two complex numbers and
 * displays the result of their addition, subtraction, multiplication, division, and absolute value.
 * <p>
 * Here is a sample run:
 * Enter the first complex number: 3.5 5.5
 * Enter the second complex number: -3.5 1
 * (3.5 + 5.5i) + (-3.5 + 1.0i) = 0.0 + 6.5i
 * (3.5 + 5.5i) - (-3.5 + 1.0i) = 7.0 + 4.5i
 * (3.5 + 5.5i) * (-3.5 + 1.0i) = -17.75 + -13.75i
 * (3.5 + 5.5i) / (-3.5 + 1.0i) = -0.5094 + -1.7i
 * |(3.5 + 5.5i)| = 6.519202405202649
 */","package ch_13.exercise13_17;


public class Exercise13_17 {
    public static void main(String[] args) {
        System.out.println(""See -> exercise13_17.Complex.class"");
    }
}
","import java.util.Scanner;

public class Complex implements Cloneable {
    private double a;
    private double b;

    public Complex() {
        this(0, 0);
    }

    public Complex(double a) {
        this(a, 0);
    }

    public Complex(double a, double b) {
        this.a = a;
        this.b = b;
    }

    public double getRealPart() {
        return a;
    }

    public double getImaginaryPart() {
        return b;
    }

    public Complex add(Complex secondComplex) {
        return new Complex(a + secondComplex.getRealPart(), b + secondComplex.getImaginaryPart());
    }

    public Complex subtract(Complex secondComplex) {
        return new Complex(a - secondComplex.getRealPart(), b - secondComplex.getImaginaryPart());
    }

    public Complex multiply(Complex secondComplex) {
        double newA = a * secondComplex.getRealPart() - b * secondComplex.getImaginaryPart();
        double newB = b * secondComplex.getRealPart() + a * secondComplex.getImaginaryPart();
        return new Complex(newA, newB);
    }

    public Complex divide(Complex secondComplex) {
        double c = secondComplex.getRealPart();
        double d = secondComplex.getImaginaryPart();
        double newA = (a * c + b * d) / (c * c + d * d);
        double newB = (b * c - a * d) / (c * c + d * d);
        return new Complex(newA, newB);
    }

    public double abs() {
        return Math.sqrt(a * a + b * b);
    }

    @Override
    public String toString() {
        if (b == 0) {
            return a + """";
        } else {
            return ""("" + a + "" + "" + b + ""i)"";
        }
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the first complex number: "");
        double a1 = input.nextDouble();
        double b1 = input.nextDouble();
        System.out.print(""Enter the second complex number: "");
        double a2 = input.nextDouble();
        double b2 = input.nextDouble();
        Complex c1 = new Complex(a1, b1);
        Complex c2 = new Complex(a2, b2);
        System.out.println(c1 + "" + "" + c2 + "" = "" + c1.add(c2));
        System.out.println(c1 + "" - "" + c2 + "" = "" + c1.subtract(c2));
        System.out.println(c1 + "" * "" + c2 + "" = "" + c1.multiply(c2));
        System.out.println(c1 + "" / "" + c2 + "" = "" + c1.divide(c2));
        System.out.println(""|"" + c1 + ""| = "" + c1.abs());
    }
}",3,"import java.util.Scanner;

public class Complex {
    private double realPart;
    private double imaginaryPart;

    public Complex(double realPart, double imaginaryPart) {
        this.realPart = realPart;
        this.imaginaryPart = imaginaryPart;
    }

    public Complex(double realPart) {
        this.realPart = realPart;
        this.imaginaryPart = 0.0;
    }

    public Complex() {
        this.realPart = 0.0;
        this.imaginaryPart = 0.0;
    }

    public double getRealPart() {
        return realPart;
    }

    public double getImaginaryPart() {
        return imaginaryPart;
    }

    public Complex add(Complex complex) {
        double newRealPart = this.realPart + complex.getRealPart();
        double newImaginaryPart = this.imaginaryPart + complex.getImaginaryPart();
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex subtract(Complex complex) {
        double newRealPart = this.realPart - complex.getRealPart();
        double newImaginaryPart = this.imaginaryPart - complex.getImaginaryPart();
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex multiply(Complex complex) {
        double newRealPart = (this.realPart * complex.getRealPart()) - (this.imaginaryPart * complex.getImaginaryPart());
        double newImaginaryPart = (this.realPart * complex.getImaginaryPart()) + (this.imaginaryPart * complex.getRealPart());
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex divide(Complex complex) {
        double divisor = Math.pow(complex.getRealPart(), 2) + Math.pow(complex.getImaginaryPart(), 2);
        double newRealPart = ((this.realPart * complex.getRealPart()) + (this.imaginaryPart * complex.getImaginaryPart())) / divisor;
        double newImaginaryPart = ((this.imaginaryPart * complex.getRealPart()) - (this.realPart * complex.getImaginaryPart())) / divisor;
        return new Complex(newRealPart, newImaginaryPart);
    }

    public double abs() {
        return Math.sqrt(Math.pow(this.realPart, 2) + Math.pow(this.imaginaryPart, 2));
    }

    @Override
    public String toString() {
        if (this.imaginaryPart == 0) {
            return String.format(""%.1f"", this.realPart);
        } else if (this.imaginaryPart < 0) {
            return String.format(""%.1f - %.1fi"", this.realPart, -this.imaginaryPart);
        } else {
            return String.format(""%.1f + %.1fi"", this.realPart, this.imaginaryPart);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter the first complex number: "");
        double realPart1 = scanner.nextDouble();
        double imaginaryPart1 = scanner.nextDouble();

        System.out.print(""Enter the second complex number: "");
        double realPart2 = scanner.nextDouble();
        double imaginaryPart2 = scanner.nextDouble();

        Complex complex1 = new Complex(realPart1, imaginaryPart1);
        Complex complex2 = new Complex(realPart2, imaginaryPart2);

        System.out.println(complex1 + "" + "" + complex2 + "" = "" + complex1.add(complex2));
        System.out.println(complex1 + "" - "" + complex2 + "" = "" + complex1.subtract(complex2));
        System.out.println(complex1 + "" * "" + complex2 + "" = "" + complex1.multiply(complex2));
        System.out.println(complex1 + "" / "" + complex2 + "" = "" + complex1.divide(complex2));
        System.out.println(""|"" + complex1 + ""| = "" + complex1.abs());
    }
}",0.686267071320182
0_Complex.java," /**
 * 13.17 (Math: The Complex class) A complex number is a number in the form a + bi,
 * -where a and b are real numbers and i is SQRT(-1). The numbers a and b are known
 * as the real part and imaginary part of the complex number, respectively. You can
 * perform addition, subtraction, multiplication, and division for complex numbers
 * using the following formulas:
 * a + bi + c + di = (a + c) + (b + d)i
 * a + bi - (c + di) = (a - c) + (b - d)i
 * (a + bi)*(c + di) = (ac - bd) + (bc + ad)i
 * (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2)
 * <p>
 * You can also obtain the absolute value for a complex number using the following
 * formula:
 * |a + bi|  = SQRT(a2 + b2)
 * (A complex number can be interpreted as a point on a plane by identifying the (a,b)
 * values as the coordinates of the point. The absolute value of the complex number
 * corresponds to the distance of the point to the origin, as shown in Figure 13.10b.)
 * <p>
 * Design a class named Complex for representing complex numbers and the
 * methods add, subtract, multiply, divide, and abs for performing complex number operations,
 * and override toString method for returning a string representation for a complex number.
 * The toString method returns (a + bi) as a string. If b is 0, it simply returns a.
 * Your Complex class should also implement the Cloneable interface.
 * <p>
 * Provide three constructors Complex(a, b), Complex(a), and Complex().
 * Complex() creates a Complex object for number 0 and Complex(a) creates a Complex object with 0 for b.
 * Also provide the getRealPart() and getImaginaryPart() methods for returning the real and imaginary part
 * of the complex number, respectively.
 */ /**
     * Example addition:  (a + bi) + (c + di) = (a + c) + (b + d)i
     *
     * @param complex Complex number to add
     * @return the addition result
     */ /**
     * Subtract example:
     * a + bi - (c + di) = (a - c) + (b - d)i
     *
     * @param complex
     * @return
     */ /**
     * (a + bi)*(c + di) = (ac - bd) + (bc + ad)i
     *
     * @param complex
     * @return
     */ /**
     * (a + bi)/(c + di) = (ac + bd)/(c2 + d2) + (bc - ad)i/(c2 + d2)
     *
     * @param complex
     * @return
     */","package ch_13.exercise13_17;


public class Complex extends Number implements Cloneable {

    private double a;
    private double b;
    private static double i = Math.sqrt(-1);

    public Complex() {
        this(0);
    }

    public Complex(double a) {
        this(a, 0);
    }

    public Complex(double a, double b) {
        this.a = a;
        this.b = b;
    }

    
    public double add(Complex complex) {
        return (this.a + complex.a) + (this.b + complex.b) * i;
    }

    
    public double subtract(Complex complex) {
        return (this.a - complex.a) + (this.b - complex.b) * i;

    }

    
    public double multiply(Complex complex) {
        return (this.a * complex.a - this.b * complex.b) + ((this.b * complex.a + this.a * complex.b) * i);
    }

    
    public double divide(Complex complex) {
        return (this.a * complex.a + this.b * complex.b) / (Math.pow(complex.a, 2) + Math.pow(complex.b, 2)) + ((this.b * complex.a - this.a * complex.b) * i) / (Math.pow(complex.a, 2) + Math.pow(complex.b, 2));
    }

    public double abs(Complex complex) {
        return Math.sqrt(Math.pow(this.a, 2) + Math.pow(this.b, 2));
    }

    public double getRealPart() {
        return a;
    }

    public double getImaginaryPart() {
        return b * i;
    }

    @Override
    public Complex clone() throws CloneNotSupportedException {
        return (Complex) super.clone();

    }

    @Override
    public int intValue() {
        return (int) Math.round(a + b * i);
    }

    @Override
    public long longValue() {
        return Math.round(a + b * i);
    }

    @Override
    public float floatValue() {
        return (float) (a + b * i);
    }

    @Override
    public double doubleValue() {
        return a + b * i;
    }
}
","public class Complex implements Cloneable {
    private double a;
    private double b;
    
    public Complex() {
        this(0, 0);
    }
    
    public Complex(double a) {
        this(a, 0);
    }
    
    public Complex(double a, double b) {
        this.a = a;
        this.b = b;
    }
    
    public double getRealPart() {
        return a;
    }
    
    public double getImaginaryPart() {
        return b;
    }
    
    public Complex add(Complex c) {
        double real = a + c.a;
        double imaginary = b + c.b;
        return new Complex(real, imaginary);
    }
    
    public Complex subtract(Complex c) {
        double real = a - c.a;
        double imaginary = b - c.b;
        return new Complex(real, imaginary);
    }
    
    public Complex multiply(Complex c) {
        double real = a * c.a - b * c.b;
        double imaginary = b * c.a + a * c.b;
        return new Complex(real, imaginary);
    }
    
    public Complex divide(Complex c) {
        double denominator = c.a * c.a + c.b * c.b;
        double real = (a * c.a + b * c.b) / denominator;
        double imaginary = (b * c.a - a * c.b) / denominator;
        return new Complex(real, imaginary);
    }
    
    public double abs() {
        return Math.sqrt(a * a + b * b);
    }
    
    @Override
    public String toString() {
        if (b == 0) {
            return a + """";
        }
        if (a == 0) {
            return b + ""i"";
        }
        if (b < 0) {
            return a + "" - "" + (-b) + ""i"";
        }
        return a + "" + "" + b + ""i"";
    }
    
    @Override
    public Complex clone() {
        return new Complex(a, b);
    }
}",3,"public class Complex {
    private double realPart;
    private double imaginaryPart;

    public Complex(double realPart, double imaginaryPart) {
        this.realPart = realPart;
        this.imaginaryPart = imaginaryPart;
    }

    public Complex(double realPart) {
        this.realPart = realPart;
        this.imaginaryPart = 0.0;
    }

    public Complex() {
        this.realPart = 0.0;
        this.imaginaryPart = 0.0;
    }

    public double getRealPart() {
        return realPart;
    }

    public double getImaginaryPart() {
        return imaginaryPart;
    }

    public Complex add(Complex complex) {
        double newRealPart = this.realPart + complex.getRealPart();
        double newImaginaryPart = this.imaginaryPart + complex.getImaginaryPart();
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex subtract(Complex complex) {
        double newRealPart = this.realPart - complex.getRealPart();
        double newImaginaryPart = this.imaginaryPart - complex.getImaginaryPart();
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex multiply(Complex complex) {
        double newRealPart = (this.realPart * complex.getRealPart()) - (this.imaginaryPart * complex.getImaginaryPart());
        double newImaginaryPart = (this.realPart * complex.getImaginaryPart()) + (this.imaginaryPart * complex.getRealPart());
        return new Complex(newRealPart, newImaginaryPart);
    }

    public Complex divide(Complex complex) {
        double divisor = Math.pow(complex.getRealPart(), 2) + Math.pow(complex.getImaginaryPart(), 2);
        double newRealPart = ((this.realPart * complex.getRealPart()) + (this.imaginaryPart * complex.getImaginaryPart())) / divisor;
        double newImaginaryPart = ((this.imaginaryPart * complex.getRealPart()) - (this.realPart * complex.getImaginaryPart())) / divisor;
        return new Complex(newRealPart, newImaginaryPart);
    }

    public double abs() {
        return Math.sqrt(Math.pow(this.realPart, 2) + Math.pow(this.imaginaryPart, 2));
    }

    @Override
    public String toString() {
        if (this.imaginaryPart == 0) {
            return String.format(""%.2f"", this.realPart);
        } else if (this.imaginaryPart < 0) {
            return String.format(""%.2f - %.2fi"", this.realPart, -this.imaginaryPart);
        } else {
            return String.format(""%.2f + %.2fi"", this.realPart, this.imaginaryPart);
        }
    }

    public static void main(String[] args) {
        // Test program can be added here
    }
}
",0.606350098342231
0_Exercise13_21.java," /**
 * 13.21 (Algebra: vertex form equations) The equation of a parabola can be expressed
 * in either standard form (y = ax^2 + bx + c) or vertex form (y = a(x - h)^2 + k).
 * <p>
 * <a href=""https://mathbitsnotebook.com/Algebra2/Quadratics/QDVertexForm.html"">Learn About Quadratics</a>
 * Write a program that prompts the user to enter a, b, and c as integers in standard
 * form and displays h and k in the vertex form.
 * <p>
 * Here are some sample runs.
 * Enter a, b, c: 1 3 1
 * h is -3/2 k is -5/4
 * Enter a, b, c: 2 3 4
 * h is -3/4 k is 23/8
 * <p>
 * When working with the vertex form of a quadratic function:
 * h = -b/2a and k = f(h) >> [The ""a"" and ""b"" referenced here refer to f(x) = ax2 + bx + c.]
 * [f(h) means to plug your answer for h into the original equation for x.]
 * Therefore, f(h) = ah^2 + bh + c
 */","package ch_13.exercise13_21;

import java.util.Scanner;


public class Exercise13_21 {
    public static void main(String[] args) {
        try (Scanner in = new Scanner(System.in)) {
            System.out.print(""Enter a, b, c (as integers): "");
            /* a,b,c as integers in Standard Form */
            int a = in.nextInt();
            int b = in.nextInt();
            int c = in.nextInt();
            Rational aRational = new Rational(a); // Constructs Rational with denominator of 1 as default
            Rational bRational = new Rational(b); // Constructs Rational with denominator of 1 as default
            Rational cRational = new Rational(c); // Constructs Rational with denominator of 1 as default
            Rational h = new Rational(bRational.multiply(new Rational(-1)).longValue(),
                    aRational.multiply(new Rational(2)).longValue());
            Rational k = aRational.multiply(h.multiply(h)).add(bRational.multiply(h)).add(cRational);
            System.out.println(""h is "" + h + "", k is "" + k);

        } catch (Exception e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
        }
    }
}
","import java.util.Scanner;

public class ParabolaConverter {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the value of a: "");
        int a = input.nextInt();
        System.out.print(""Enter the value of b: "");
        int b = input.nextInt();
        System.out.print(""Enter the value of c: "");
        int c = input.nextInt();

        int h = -b / (2 * a);
        int k = a * h * h + b * h + c;

        System.out.println(""The vertex form of the parabola is: y = "" + a + ""(x - "" + h + "")^2 + "" + k);
    }
}",3,"import java.util.Scanner;

public class VertexFormEquations {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter a, b, c in standard form (y = ax^2 + bx + c): "");
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        int c = scanner.nextInt();

        double h = -b / (2.0 * a);
        double k = a * Math.pow(h, 2) + b * h + c;

        System.out.println(""h is "" + formatFraction(h) + "" k is "" + formatFraction(k));
    }

    // Format a double as a fraction if possible.
    private static String formatFraction(double value) {
        String fraction = """";

        if (value % 1 == 0) {
            fraction = Integer.toString((int) value);
        } else {
            int numerator = (int) (value * 100);
            int denominator = 100;
            int gcd = gcd(numerator, denominator);

            numerator /= gcd;
            denominator /= gcd;

            if (denominator == 1) {
                fraction = Integer.toString(numerator);
            } else {
                fraction = numerator + ""/"" + denominator;
            }
        }
        return fraction;
    }

    // Find the greatest common divisor (GCD) using Euclidean algorithm.
    private static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
}",0.4560975609756098
0_Exercise13_19.java," /**
 * 13.19 (Convert decimals to fractions) Write a program that prompts the user to enter
 * a decimal number and displays the number in a fraction. Hint: read the decimal
 * number as a string, extract the integer part and fractional part from the string,
 * and use the BigInteger implementation of the {@linkplain Rational} class in Programming
 * Exercise 13.15 to obtain a rational number for the decimal number. Here are some
 * sample runs:
 * Enter a decimal number: 3.25
 * The fraction number is 13/4
 * <p>
 * Enter a decimal number: -0.45452
 * The fraction number is -11363/25000
 */","package ch_13.exercise13_19;

import java.util.Scanner;


public class Exercise13_19 {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a decimal number: "");
        String decVal = in.next();
        try {
            System.out.println(""The fraction number is "" + decimalToFraction(decVal));
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }

        in.close();
    }

    private static String decimalToFraction(String val) throws Exception {
        boolean isNegative = val.startsWith(""-"");

        String[] decimalNumberParts = val.split(""\\."");
        if (decimalNumberParts.length < 2) {
            throw new Exception(""You must enter a decimal number like: 123.12"");
        }
        if (val.startsWith(""-"")) {
            isNegative = true;
        }
        Rational leftSideOfDecimal = new Rational(Long.parseLong(decimalNumberParts[0]));
        String denominatorRightSide = ""1"";
        for (int i = 0; i < decimalNumberParts[1].length(); i++) {
            denominatorRightSide += ""0"";
        }
        Rational rightSideOfDecimal = new Rational(Long.parseLong(decimalNumberParts[1]), Long.parseLong(denominatorRightSide));
        Rational result = leftSideOfDecimal.add(rightSideOfDecimal);
        return (isNegative ? ""-"" : """") + result.toString();

    }
}
","import java.util.Scanner;

public class DecimalToFraction {
    
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter a decimal number: "");
        String decimal = input.next();
        
        int integerPart = Integer.parseInt(decimal.split(""\\."")[0]);
        String fractionalPart = decimal.split(""\\."")[1];
        int denominator = (int) Math.pow(10, fractionalPart.length());
        int numerator = Integer.parseInt(fractionalPart) + integerPart * denominator;
        
        int gcd = gcd(numerator, denominator);
        numerator /= gcd;
        denominator /= gcd;
        
        System.out.println(decimal + "" = "" + numerator + ""/"" + denominator);
    }
    
    private static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
}",3,"import java.util.Scanner;
import java.math.BigInteger;

public class DecimalToFractionConverter {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter a decimal number: "");
        double decimalNumber = scanner.nextDouble();

        // Convert the decimal number to a string to extract integer and fractional parts
        String decimalStr = Double.toString(decimalNumber);

        int integerPart = (int) decimalNumber;
        String fractionalPartStr = decimalStr.substring(decimalStr.indexOf('.') + 1);

        int fractionalPart = Integer.parseInt(fractionalPartStr);
        int powerOfTen = (int) Math.pow(10, fractionalPartStr.length());

        // Use BigInteger to simplify the fraction
        BigInteger numerator = BigInteger.valueOf(integerPart * powerOfTen + fractionalPart);
        BigInteger denominator = BigInteger.valueOf(powerOfTen);

        // Calculate the greatest common divisor (GCD) to simplify the fraction
        BigInteger gcd = numerator.gcd(denominator);
        numerator = numerator.divide(gcd);
        denominator = denominator.divide(gcd);

        System.out.println(""The fraction number is "" + numerator + ""/"" + denominator);
    }
}",0.5981808453718566
0_Exercise14_12.java," /**
 * *14.12 (Display a bar chart) Write a program that uses a bar chart to display the percentages
 * of the overall grade represented by projects, quizzes, midterm exams, and the
 * final exam, as shown in Figure 14.46b.
 * <p>
 * Suppose that projects take 20 percent and are displayed in red,
 * quizzes take 10 percent and are displayed in blue, midterm
 * exams take 30 percent and are displayed in green, and the final exam takes 40
 * percent and is displayed in orange.
 * <p>
 * Use the Rectangle class to display the bars.
 * Interested readers may explore the JavaFX BarChart class for further study.
 */","package ch_14;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.stage.Stage;


public class Exercise14_12 extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        double fullBarValue = 250;
        HBox hBox = new HBox(5);
        VBox projectBox = new VBox(5);
        VBox quizBox = new VBox(5);
        VBox midtermBox = new VBox(5);
        VBox finalBarBox = new VBox(5);

        Rectangle projectBar = new Rectangle(125, fullBarValue * .2);
        projectBar.setFill(Color.RED);

        Rectangle quizBar = new Rectangle(125, fullBarValue * .1);
        quizBar.setFill(Color.BLUE);

        Rectangle midtermBar = new Rectangle(125, fullBarValue * .3);
        midtermBar.setFill(Color.GREEN);

        Rectangle finalBar = new Rectangle(125, fullBarValue * .4);
        finalBar.setFill(Color.ORANGE);

        Text projectText = new Text(""Project -- 20%"");
        Text quizText = new Text(""Quiz -- 10%"");
        Text midtermText = new Text(""Midterm -- 30%"");
        Text finalText = new Text(""Final -- 40%"");

        projectBox.getChildren().add(projectText);
        projectBox.getChildren().add(projectBar);
        projectBox.setAlignment(Pos.BOTTOM_CENTER);

        quizBox.getChildren().add(quizText);
        quizBox.getChildren().add(quizBar);
        quizBox.setAlignment(Pos.BOTTOM_CENTER);

        midtermBox.getChildren().add(midtermText);
        midtermBox.getChildren().add(midtermBar);
        midtermBox.setAlignment(Pos.BOTTOM_CENTER);

        finalBarBox.getChildren().add(finalText);
        finalBarBox.getChildren().add(finalBar);
        finalBarBox.setAlignment(Pos.BOTTOM_CENTER);

        hBox.getChildren().addAll(projectBox, quizBox, midtermBox, finalBarBox);
        hBox.setAlignment(Pos.BOTTOM_CENTER);
        hBox.setPadding(new Insets(10, 10, 10, 10));

        Scene scene = new Scene(hBox);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.show();

    }
}
","import javax.swing.*;
import java.awt.*;

public class GradeBarChart extends JFrame {
    public GradeBarChart() {
        setTitle(""Grade Bar Chart"");
        setSize(400, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setVisible(true);
    }

    public void paint(Graphics g) {
        super.paint(g);
        // Define the dimensions of the chart area
        int chartWidth = 300;
        int chartHeight = 200;
        int chartX = 50;
        int chartY = 50;

        // Calculate the lengths of each bar
        int projectLength = (int) (chartWidth * 0.2);
        int quizLength = (int) (chartWidth * 0.1);
        int midtermLength = (int) (chartWidth * 0.3);
        int finalLength = (int) (chartWidth * 0.4);

        // Define the colors of each bar
        Color projectColor = Color.RED;
        Color quizColor = Color.BLUE;
        Color midtermColor = Color.GREEN;
        Color finalColor = Color.ORANGE;

        // Draw the bars
        g.setColor(projectColor);
        g.fillRect(chartX, chartY, projectLength, chartHeight);

        g.setColor(quizColor);
        g.fillRect(chartX + projectLength, chartY, quizLength, chartHeight);

        g.setColor(midtermColor);
        g.fillRect(chartX + projectLength + quizLength, chartY, midtermLength, chartHeight);

        g.setColor(finalColor);
        g.fillRect(chartX + projectLength + quizLength + midtermLength, chartY, finalLength, chartHeight);

        // Draw the labels
        g.setColor(Color.BLACK);
        g.drawString(""Projects"", chartX, chartY + chartHeight + 20);
        g.drawString(""Quizzes"", chartX + projectLength, chartY + chartHeight + 20);
        g.drawString(""Midterm Exams"", chartX + projectLength + quizLength, chartY + chartHeight + 20);
        g.drawString(""Final Exam"", chartX + projectLength + quizLength + midtermLength, chartY + chartHeight + 20);
    }

    public static void main(String[] args) {
        new GradeBarChart();
    }
}",3,"import javax.swing.*;
import java.awt.*;

public class BarChartDisplay extends JPanel {
    private double projectPercentage = 20.0;
    private double quizPercentage = 10.0;
    private double midtermPercentage = 30.0;
    private double finalExamPercentage = 40.0;

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        int width = getWidth();
        int height = getHeight();

        int projectWidth = (int) (width * (projectPercentage / 100));
        int quizWidth = (int) (width * (quizPercentage / 100));
        int midtermWidth = (int) (width * (midtermPercentage / 100));
        int finalExamWidth = (int) (width * (finalExamPercentage / 100));

        g.setColor(Color.RED);
        g.fillRect(10, 10, projectWidth, 30);

        g.setColor(Color.BLUE);
        g.fillRect(10, 50, quizWidth, 30);

        g.setColor(Color.GREEN);
        g.fillRect(10, 90, midtermWidth, 30);

        g.setColor(Color.ORANGE);
        g.fillRect(10, 130, finalExamWidth, 30);

        g.setColor(Color.BLACK);
        g.drawString(""Projects"", 10, 30);
        g.drawString(""Quizzes"", 10, 70);
        g.drawString(""Midterm Exams"", 10, 110);
        g.drawString(""Final Exam"", 10, 150);
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame();
        BarChartDisplay chart = new BarChartDisplay();
        frame.add(chart);

        frame.setSize(400, 200);
        frame.setTitle(""Grade Percentage Bar Chart"");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}",0.5208604954367666
0_Exercise14_13.java," /**
 * *14.13 (Display a pie chart) Write a program that uses a pie chart to display the percentages
 * of the overall grade represented by projects, quizzes, midterm exams, and
 * the final exam, as shown in Figure 14.46c. Suppose that projects take 20 percent
 * and are displayed in red, quizzes take 10 percent and are displayed in blue,
 * midterm exams take 30 percent and are displayed in green, and the final exam
 * takes 40 percent and is displayed in orange. Use the Arc class to display the pies.
 * Interested readers may explore the JavaFX PieChart class for further study.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.Circle;
import javafx.scene.text.Text;
import javafx.stage.Stage;


public class Exercise14_13 extends Application {
    double width = 350;
    double height = 350;
    double nextSliceStart = 0;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Pane pane = new Pane();

        double wedge20Percent = 0.2 * 360;
        double wedge10Percent = 0.1 * 360;
        double wedge30Percent = 0.3 * 360;
        double wedge40Percent = 0.4 * 360;
        double centerX = width / 2;
        double centerY = height / 2;
        double radius = 150;

        Circle circle = new Circle(centerX, centerY, radius);

        Arc projects = new Arc(centerX, centerY, circle.getRadius(), circle.getRadius(), nextSliceStart, wedge20Percent);
        nextSliceStart += wedge20Percent;
        projects.setType(ArcType.ROUND);
        projects.setFill(Color.RED);
        projects.setStroke(Color.RED);
        Text projectText = new Text(centerX + 25, centerY - 15, ""Project -- 20%"");


        Arc quizzes = new Arc(centerX, centerY, circle.getRadius(), circle.getRadius(), nextSliceStart, wedge10Percent);
        nextSliceStart += wedge10Percent;
        quizzes.setType(ArcType.ROUND);
        quizzes.setFill(Color.BLUE);
        quizzes.setStroke(Color.BLUE);
        Text quizText = new Text(centerX + 15, centerY - (radius + 10), ""Quizzes -- 10%"");


        Arc midTerms = new Arc(centerX, centerY, circle.getRadius(), circle.getRadius(), nextSliceStart,
                wedge30Percent);
        nextSliceStart += wedge30Percent;
        midTerms.setType(ArcType.ROUND);
        midTerms.setFill(Color.GREEN);
        midTerms.setStroke(Color.GREEN);
        Text midtermText = new Text(centerX - 135, centerY, ""MidTerm -- 30%"");

        Arc finals = new Arc(centerX, centerY, circle.getRadius(), circle.getRadius(), nextSliceStart, wedge40Percent);
        nextSliceStart += wedge40Percent;
        finals.setType(ArcType.ROUND);
        finals.setFill(Color.ORANGE);
        finals.setStroke(Color.ORANGE);
        Text finalsText = new Text(centerX + 15, centerY + (radius - 15), ""Finals -- 40%"");


        pane.getChildren().add(circle);
        pane.getChildren().addAll(projects, quizzes, midTerms, finals);
        pane.getChildren().addAll(projectText, quizText, midtermText, finalsText);

        circle.setFill(Color.WHITE);
        circle.setStroke(Color.BLACK);
        Scene scene = new Scene(pane, width, height);
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();
    }
}
","import javax.swing.*;
import java.awt.*;

public class GradePieChart extends JFrame {
    public GradePieChart() {
        setTitle(""Grade Pie Chart"");
        setSize(400, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setVisible(true);
    }

    public void paint(Graphics g) {
        super.paint(g);
        // Define the dimensions of the chart area
        int chartWidth = 200;
        int chartHeight = 200;
        int chartX = 100;
        int chartY = 100;

        // Calculate the angles of each pie slice
        double projectAngle = 0.2 * 360;
        double quizAngle = 0.1 * 360;
        double midtermAngle = 0.3 * 360;
        double finalAngle = 0.4 * 360;

        // Define the colors of each pie slice
        Color projectColor = Color.RED;
        Color quizColor = Color.BLUE;
        Color midtermColor = Color.GREEN;
        Color finalColor = Color.ORANGE;

        // Draw the pies
        g.setColor(projectColor);
        g.fillArc(chartX, chartY, chartWidth, chartHeight, 0, (int) projectAngle);

        g.setColor(quizColor);
        g.fillArc(chartX, chartY, chartWidth, chartHeight, (int) projectAngle, (int) quizAngle);

        g.setColor(midtermColor);
        g.fillArc(chartX, chartY, chartWidth, chartHeight, (int) (projectAngle + quizAngle), (int) midtermAngle);

        g.setColor(finalColor);
        g.fillArc(chartX, chartY, chartWidth, chartHeight, (int) (projectAngle + quizAngle + midtermAngle), (int) finalAngle);

        // Draw the labels
        g.setColor(Color.BLACK);
        g.drawString(""Projects"", chartX - 50, chartY - 20);
        g.drawString(""Quizzes"", chartX + chartWidth + 10, chartY + 20);
        g.drawString(""Midterm Exams"", chartX + chartWidth / 2, chartY + chartHeight + 20);
        g.drawString(""Final Exam"", chartX + chartWidth / 2, chartY - 60);
    }

    public static void main(String[] args) {
        new GradePieChart();
    }
}",3,"import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;

public class PieChartDisplay extends JPanel {
    private double projectPercentage = 20.0;
    private double quizPercentage = 10.0;
    private double midtermPercentage = 30.0;
    private double finalExamPercentage = 40.0;

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        int width = getWidth();
        int height = getHeight();

        double totalPercentage = projectPercentage + quizPercentage + midtermPercentage + finalExamPercentage;

        double projectAngle = 360 * (projectPercentage / totalPercentage);
        double quizAngle = 360 * (quizPercentage / totalPercentage);
        double midtermAngle = 360 * (midtermPercentage / totalPercentage);
        double finalExamAngle = 360 * (finalExamPercentage / totalPercentage);

        g.setColor(Color.RED);
        g.fillArc(50, 50, 200, 200, 0, (int) projectAngle);

        g.setColor(Color.BLUE);
        g.fillArc(50, 50, 200, 200, (int) projectAngle, (int) quizAngle);

        g.setColor(Color.GREEN);
        g.fillArc(50, 50, 200, 200, (int) (projectAngle + quizAngle), (int) midtermAngle);

        g.setColor(Color.ORANGE);
        g.fillArc(50, 50, 200, 200, (int) (projectAngle + quizAngle + midtermAngle), (int) finalExamAngle);

        g.setColor(Color.BLACK);
        g.drawString(""Projects"", 20, 100);
        g.drawString(""Quizzes"", 270, 100);
        g.drawString(""Midterm Exams"", 270, 250);
        g.drawString(""Final Exam"", 20, 250);
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame();
        PieChartDisplay chart = new PieChartDisplay();
        frame.add(chart);

        frame.setSize(400, 400);
        frame.setTitle(""Grade Percentage Pie Chart"");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}",0.5767386091127098
0_Exercise14_05.java," /**
 * 14.5 (Characters around circle) Write a program that displays a string Welcome to
 * Java around the circle, as shown in Figure 14.44b. Hint: You need to display each
 * character in the right location with appropriate rotation using a loop.
 */","package ch_14;

import javafx.application.Application;
import javafx.geometry.Point2D;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.stage.Stage;


public class Exercise14_05 extends Application {
    static String[] message = new String[]{""W"", ""E"", ""L"", ""C"", ""O"", ""M"", ""E"", "" "", ""T"", ""O"", "" "", ""J"", ""A"", ""V"", ""A""};
    static Font font = Font.font(""Times New Roman"", FontWeight.BOLD, 28);

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Pane pane = new Pane();
        double radius = 75;
        for (int i = 0, currentAngle = 0, rotation = 90; i < message.length; i++, currentAngle += 22, rotation += 22) {
            double x = 105 + radius * Math.cos(Math.toRadians(currentAngle));
            double y = 105 + radius * Math.sin(Math.toRadians(currentAngle));
            Text text = new Text(x, y, message[i]);
            text.setFont(font);
            text.setRotate(rotation);
            pane.getChildren().add(text);

        }
        Scene scene = new Scene(pane, 225, 225);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

}","public class CircleString {
    public static void main(String[] args) {
        String message = ""Welcome to Java"";
        int radius = 10; // change this value to adjust the size of the circle
        int centerX = 20; // change this value to adjust the position of the circle
        int centerY = 10; // change this value to adjust the position of the circle
        
        // loop through each character in the message and display it in the right location
        for (int i = 0; i < message.length(); i++) {
            double angle = i * 2 * Math.PI / message.length();
            int x = (int)(centerX + radius * Math.cos(angle));
            int y = (int)(centerY + radius * Math.sin(angle));
            System.out.print("" "");
            System.out.print(""\033["" + y + "";"" + x + ""H""); // set the cursor position to (x, y)
            System.out.print(message.charAt(i)); // display the character at the current position
            try {
                Thread.sleep(100); // wait for 100 milliseconds before displaying the next character
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println();
    }
}",3,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class CharactersAroundCircle extends JFrame {
    private String text = ""Welcome to Java"";

    public CharactersAroundCircle() {
        setTitle(""Characters Around Circle"");
        setSize(400, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        CirclePanel circlePanel = new CirclePanel();
        add(circlePanel);

        Timer timer = new Timer(100, new ActionListener() {
            double angle = 0;

            @Override
            public void actionPerformed(ActionEvent e) {
                circlePanel.setAngle(angle);
                angle += Math.PI / 18; // Rotate by 10 degrees
                repaint();
            }
        });
        timer.start();
    }

    private class CirclePanel extends JPanel {
        private double angle = 0;

        public void setAngle(double angle) {
            this.angle = angle;
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            int centerX = getWidth() / 2;
            int centerY = getHeight() / 2;
            int radius = 100;

            for (int i = 0; i < text.length(); i++) {
                char character = text.charAt(i);
                double x = centerX + radius * Math.cos(angle);
                double y = centerY + radius * Math.sin(angle);

                g.drawString(String.valueOf(character), (int) x, (int) y);

                angle += Math.PI / 9; // Rotate by 20 degrees for the next character
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            CharactersAroundCircle frame = new CharactersAroundCircle();
            frame.setVisible(true);
        });
    }
}",0.41301727601446364
0_Exercise14_09.java," /**
 * 14.9 (Create four fans) Write a program that places four fans in a GridPane with two
 * rows and two columns, as shown in Figure 14.45b.
 */","package ch_14;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;


public class Exercise14_09 extends Application {


    @Override
    public void start(Stage primaryStage) throws Exception {

        StackPane[] stackPanes = new StackPane[4];
        GridPane gridPane = new GridPane();

        int paneArrayIdx = 0;
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                Circle circle = new Circle(100);
                circle.setStroke(Color.BLACK);
                circle.setFill(Color.WHITE);
                StackPane stackPane = new StackPane();
                stackPane.getChildren().add(circle);
                stackPane.getChildren().add(new ArcPane());
                gridPane.add(stackPane, j, i);
                stackPanes[paneArrayIdx++] = stackPane;
            }
        }
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setPadding(new Insets(10, 10, 10, 10));
        gridPane.setVgap(10);
        gridPane.setHgap(10);
        Scene scene = new Scene(gridPane);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

    }
}

class ArcPane extends Pane {

    ArcPane() {
        super();
        create();
    }

    void create() {
        int angle = 120;
        int numArcs = 4;
        while (numArcs > 0) {
            Arc arc = new Arc(100, 100, 80, 80, angle, 35);
            numArcs--;
            angle += 90;
            arc.setFill(Color.GREY);
            arc.setType(ArcType.ROUND);
            super.getChildren().add(arc);
        }
    }

}
","import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class FansGrid extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        // Create the GridPane and set the padding and gap between cells
        GridPane gridPane = new GridPane();
        gridPane.setPadding(new Insets(20, 20, 20, 20));
        gridPane.setHgap(20);
        gridPane.setVgap(20);

        // Create four ImageView objects to hold the fan images
        ImageView fan1 = new ImageView(new Image(""https://image.flaticon.com/icons/png/512/2948/2948073.png""));
        ImageView fan2 = new ImageView(new Image(""https://image.flaticon.com/icons/png/512/2948/2948073.png""));
        ImageView fan3 = new ImageView(new Image(""https://image.flaticon.com/icons/png/512/2948/2948073.png""));
        ImageView fan4 = new ImageView(new Image(""https://image.flaticon.com/icons/png/512/2948/2948073.png""));

        // Set the size of the fan images
        fan1.setFitWidth(150);
        fan1.setFitHeight(150);
        fan2.setFitWidth(150);
        fan2.setFitHeight(150);
        fan3.setFitWidth(150);
        fan3.setFitHeight(150);
        fan4.setFitWidth(150);
        fan4.setFitHeight(150);

        // Add the fans to the GridPane
        gridPane.add(fan1, 0, 0);
        gridPane.add(fan2, 1, 0);
        gridPane.add(fan3, 0, 1);
        gridPane.add(fan4, 1, 1);

        // Create a Scene and add the GridPane to it
        Scene scene = new Scene(gridPane, 500, 500);

        // Set the title of the window and show it
        primaryStage.setTitle(""Fans Grid"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",4,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class FourFans extends Application {
    @Override
    public void start(Stage primaryStage) {
        GridPane gridPane = new GridPane();

        // Create fan images
        Image fanImage1 = new Image(""file:fan.png"");
        Image fanImage2 = new Image(""file:fan.png"");
        Image fanImage3 = new Image(""file:fan.png"");
        Image fanImage4 = new Image(""file:fan.png"");

        // Create fan ImageViews
        ImageView fan1 = new ImageView(fanImage1);
        ImageView fan2 = new ImageView(fanImage2);
        ImageView fan3 = new ImageView(fanImage3);
        ImageView fan4 = new ImageView(fanImage4);

        // Set fan sizes
        fan1.setFitWidth(100);
        fan1.setFitHeight(100);
        fan2.setFitWidth(100);
        fan2.setFitHeight(100);
        fan3.setFitWidth(100);
        fan3.setFitHeight(100);
        fan4.setFitWidth(100);
        fan4.setFitHeight(100);

        // Add fans to GridPane
        gridPane.add(fan1, 0, 0);
        gridPane.add(fan2, 1, 0);
        gridPane.add(fan3, 0, 1);
        gridPane.add(fan4, 1, 1);

        Scene scene = new Scene(gridPane, 400, 400);
        primaryStage.setTitle(""Four Fans"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",0.7437185929648241
0_Exercise14_25.java," /**
 * *14.25 (Random points on a circle) Modify {@linkplain ch_04.Exercise04_06} to create five
 * random points on a circle, form a polygon by connecting the points clockwise,
 * and display the circle and the polygon, as shown in Figure 14.51b.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.stage.Stage;


public class Exercise14_25 extends Application {
    private final double RADIUS = 80;
    private final double WIDTH = 200;
    private final double HEIGHT = 200;

    @Override
    public void start(Stage primaryStage) throws Exception {
        double[][] pointsInCircle = new double[5][2];
        Circle circle = new Circle(100,100, RADIUS);
        circle.setFill(Color.TRANSPARENT);
        circle.setStroke(Color.BLACK);

        for (int i = 0; i < 5; i++) {
            pointsInCircle[i] = randomPointOnCircle(circle.getCenterX(), circle.getCenterY(), RADIUS);
        }
        drawCircleWithPolygonPoints(pointsInCircle, primaryStage, circle);

    }

    private void drawCircleWithPolygonPoints(double[][] points, Stage stage, Circle circle) {
        Pane pane = new Pane();
        pane.getChildren().add(circle);

        for (int i = 0; i < points.length - 1; i++) {
            Line line = new Line(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1]);
            pane.getChildren().add(line);
        }

        Scene scene = new Scene(pane, WIDTH, HEIGHT);
        stage.setScene(scene);
        stage.setTitle(getClass().getName());
        stage.show();

    }

    private double[] randomPointOnCircle(double centerX, double centerY, double radius) {
        double angle = Math.random() * 2 * Math.PI,
                A = Math.sqrt(Math.random()) * radius,
                B = Math.cos(angle) * A,
                C = Math.sin(angle) * A;
        return new double[]{centerX + B, centerY + C};
    }

    public static void main(String[] args) {
        launch(args);
    }

}
","import java.awt.Color;
import java.awt.Graphics;
import java.util.Random;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class CirclePolygon extends JPanel {
    private int centerX = 200;
    private int centerY = 200;
    private int radius = 100;
    private int numPoints = 5;
    private int[] xPoints = new int[numPoints];
    private int[] yPoints = new int[numPoints];
    
    public CirclePolygon() {
        // generate random points on the circle
        Random random = new Random();
        for (int i = 0; i < numPoints; i++) {
            double angle = i * 2 * Math.PI / numPoints;
            int x = (int)(centerX + radius * Math.cos(angle));
            int y = (int)(centerY + radius * Math.sin(angle));
            xPoints[i] = x;
            yPoints[i] = y;
        }
    }
    
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        // draw the circle
        g.drawOval(centerX - radius, centerY - radius, 2 * radius, 2 * radius);
        
        // draw the polygon
        g.setColor(Color.BLUE);
        g.fillPolygon(xPoints, yPoints, numPoints);
    }
    
    public static void main(String[] args) {
        JFrame frame = new JFrame(""Circle and Polygon"");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        CirclePolygon panel = new CirclePolygon();
        panel.setBackground(Color.WHITE);
        frame.add(panel);
        frame.setSize(400, 400);
        frame.setVisible(true);
    }
}",4,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

public class RandomPointsOnCircle extends Application {
    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        double centerX = 200;
        double centerY = 200;
        double radius = 100;

        Circle circle = new Circle(centerX, centerY, radius);
        circle.setFill(Color.TRANSPARENT);
        circle.setStroke(Color.BLACK);

        pane.getChildren().add(circle);

        double[] xCoords = new double[5];
        double[] yCoords = new double[5];

        for (int i = 0; i < 5; i++) {
            double angle = Math.toRadians(i * 72);
            xCoords[i] = centerX + radius * Math.cos(angle);
            yCoords[i] = centerY - radius * Math.sin(angle);

            Circle point = new Circle(xCoords[i], yCoords[i], 5);
            point.setFill(Color.RED);
            point.setStroke(Color.BLACK);

            pane.getChildren().add(point);
        }

        for (int i = 0; i < 4; i++) {
            Line line = new Line(xCoords[i], yCoords[i], xCoords[i + 1], yCoords[i + 1]);
            pane.getChildren().add(line);
        }

        Line line = new Line(xCoords[4], yCoords[4], xCoords[0], yCoords[0]);
        pane.getChildren().add(line);

        Scene scene = new Scene(pane, 400, 400);
        primaryStage.setTitle(""Random Points on Circle"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",0.47411242603550297
0_Exercise14_02.java," /**
 * *14.2 (Tic-tac-toe board) Write a program that displays a tic-tac-toe board, as shown
 * in Figure 14.43b. A cell may be X, O, or empty. What to display at each cell is
 * randomly decided. The X and O are images in the files x.gif and o.gif.
 */","package ch_14;


import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

import java.io.File;
import java.util.Random;


public class Exercise14_02 extends Application {
    Random random = new Random();
    static final String resourcePath = ""resources"" + File.separator + ""tictactoe"";

    @Override
    public void start(Stage primaryStage) throws Exception {
        GridPane gameBoard = new GridPane();
        Image X = new Image(resourcePath + File.separator + ""x.png"");
        Image O = new Image(resourcePath + File.separator + ""o.png"");

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                Pane pane = new Pane();
                ImageView imageView = new ImageView();
                if (getRandomXO()) {
                    if (getRandomXO()) {
                        imageView.setImage(X);
                    } else {
                        imageView.setImage(O);
                    }

                }
                imageView.setPreserveRatio(true);
                imageView.setFitHeight(100);
                pane.getChildren().add(imageView);
                gameBoard.add(pane, i, j);
            }
        }
        Scene scene = new Scene(gameBoard, 315, 315);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    boolean getRandomXO() {
        return random.nextBoolean();
    }
}
","import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

import java.util.Random;

public class TicTacToeBoard extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        // Create the GridPane and set the padding and gap between cells
        GridPane gridPane = new GridPane();
        gridPane.setPadding(new Insets(20, 20, 20, 20));
        gridPane.setHgap(10);
        gridPane.setVgap(10);

        // Create an array to hold the X and O images
        Image[] images = new Image[3];
        images[0] = new Image(""https://i.imgur.com/WHdYnoM.png"");
        images[1] = new Image(""https://i.imgur.com/sNDtBvL.png"");
        images[2] = null;

        // Create a Random object to generate random numbers
        Random random = new Random();

        // Fill the grid with X's, O's, and empty cells randomly
        for (int row = 0; row < 3; row++) {
            for (int col = 0; col < 3; col++) {
                int index = random.nextInt(3);
                ImageView imageView = new ImageView(images[index]);
                imageView.setFitWidth(100);
                imageView.setFitHeight(100);
                gridPane.add(imageView, col, row);
            }
        }

        // Create a Scene and add the GridPane to it
        Scene scene = new Scene(gridPane, 350, 350);

        // Set the alignment of the GridPane and show the window
        gridPane.setAlignment(Pos.CENTER);
        primaryStage.setScene(scene);
        primaryStage.setTitle(""Tic-Tac-Toe Board"");
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",4,"import javax.swing.*;
import java.awt.*;
import java.util.Random;

public class TicTacToeBoard extends JFrame {
    public TicTacToeBoard() {
        setTitle(""Tic-Tac-Toe Board"");
        setSize(300, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        JPanel panel = new JPanel(new GridLayout(3, 3));

        Random random = new Random();

        for (int i = 0; i < 9; i++) {
            int randomValue = random.nextInt(3); // 0 for empty, 1 for X, 2 for O
            JLabel cell = new JLabel();
            cell.setHorizontalAlignment(JLabel.CENTER);

            if (randomValue == 1) {
                cell.setIcon(new ImageIcon(""x.gif""));
            } else if (randomValue == 2) {
                cell.setIcon(new ImageIcon(""o.gif""));
            } else {
                cell.setText("""");
            }

            panel.add(cell);
        }

        add(panel);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            TicTacToeBoard board = new TicTacToeBoard();
            board.setVisible(true);
        });
    }
}",0.40177849636216656
0_Exercise14_14.java," /**
 * 14.14 (Display a rectanguloid) Write a program that displays a rectanguloid, as shown
 * in Figure 14.47a. The cube should grow and shrink as the window grows or
 * shrinks.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import javafx.stage.Stage;

import java.util.ArrayList;


public class Exercise14_14 extends Application {
    double sceneWidth = 325;
    double sceneHeight = 325;

    @Override
    public void start(Stage primaryStage) {

        Pane pane = new Pane();
        /* Create the bottomLeftAlg 2D-rectangle part of the cube */
        Rectangle bottomLeftAlignedRectangle = new Rectangle(0, 0);
        bottomLeftAlignedRectangle.setFill(Color.TRANSPARENT);
        bottomLeftAlignedRectangle.setStroke(Color.BLACK);
        /* Bind the rectangle to x and y properties of it's container pane,and offset to achieve 3D effect  */
        bottomLeftAlignedRectangle.xProperty().bind(pane.widthProperty().divide(4).subtract(25));
        bottomLeftAlignedRectangle.yProperty().bind(pane.heightProperty().divide(4).add(25));
        bottomLeftAlignedRectangle.widthProperty().bind(pane.widthProperty().divide(2));
        bottomLeftAlignedRectangle.heightProperty().bind(pane.heightProperty().divide(2));

        /* Create the topRightAlignedRectangle */
        Rectangle topRightAlignedRectangle = new Rectangle(0, 0);
        topRightAlignedRectangle.setFill(Color.TRANSPARENT);
        topRightAlignedRectangle.setStroke(Color.BLACK);

        /* Bind to width and height of its container and offset */
        topRightAlignedRectangle.xProperty().bind(pane.widthProperty().divide(4).add(25));
        topRightAlignedRectangle.yProperty().bind(pane.heightProperty().divide(4).subtract(25));
        topRightAlignedRectangle.widthProperty().bind(pane.widthProperty().divide(2));
        topRightAlignedRectangle.heightProperty().bind(pane.heightProperty().divide(2));

        /* Create the lines to connect the font and back rectangles to form the cube/  ""rectanguloid""*/
        /* Bind the points in the rectangles to the start and end properties of the connecting lines */
        Line l1 = new Line();
        l1.startXProperty().bind(bottomLeftAlignedRectangle.xProperty());
        l1.startYProperty().bind(bottomLeftAlignedRectangle.yProperty());
        l1.endXProperty().bind(topRightAlignedRectangle.xProperty());
        l1.endYProperty().bind(topRightAlignedRectangle.yProperty());

        Line l2 = new Line();
        l2.startXProperty().bind(bottomLeftAlignedRectangle.xProperty());
        l2.startYProperty().bind(bottomLeftAlignedRectangle.yProperty().add(bottomLeftAlignedRectangle.heightProperty()));
        l2.endXProperty().bind(topRightAlignedRectangle.xProperty());
        l2.endYProperty().bind(topRightAlignedRectangle.yProperty().add(bottomLeftAlignedRectangle.heightProperty()));

        Line l3 = new Line();
        l3.startXProperty().bind(bottomLeftAlignedRectangle.xProperty().add(bottomLeftAlignedRectangle.widthProperty()));
        l3.startYProperty().bind(bottomLeftAlignedRectangle.yProperty().add(bottomLeftAlignedRectangle.heightProperty()));
        l3.endXProperty().bind(topRightAlignedRectangle.xProperty().add(bottomLeftAlignedRectangle.widthProperty()));
        l3.endYProperty().bind(topRightAlignedRectangle.yProperty().add(bottomLeftAlignedRectangle.heightProperty()));

        Line l4 = new Line();
        l4.startXProperty().bind(bottomLeftAlignedRectangle.xProperty().add(bottomLeftAlignedRectangle.widthProperty()));
        l4.startYProperty().bind(bottomLeftAlignedRectangle.yProperty());
        l4.endXProperty().bind(topRightAlignedRectangle.xProperty().add(bottomLeftAlignedRectangle.widthProperty()));
        l4.endYProperty().bind(topRightAlignedRectangle.yProperty());

        pane.getChildren().addAll(bottomLeftAlignedRectangle, topRightAlignedRectangle, l1, l2, l3, l4);
        Scene scene = new Scene(pane, sceneWidth, sceneHeight);
        scene.xProperty().add(scene.yProperty());
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

    }
}","import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Point3D;
import javafx.scene.Group;
import javafx.scene.PerspectiveCamera;
import javafx.scene.Scene;
import javafx.scene.SceneAntialiasing;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.paint.PhongMaterial;
import javafx.scene.shape.Box;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Translate;
import javafx.stage.Stage;

public class Rectanguloid extends Application {

    private final double BOX_SIZE = 100;

    @Override
    public void start(Stage primaryStage) throws Exception {
        // Create a StackPane to hold the 3D scene
        StackPane root = new StackPane();

        // Create a Group to hold the rectanguloid
        Group group = new Group();
        root.getChildren().add(group);

        // Create a box with the specified size and color
        Box box = new Box(BOX_SIZE, BOX_SIZE, BOX_SIZE);
        box.setMaterial(new PhongMaterial(Color.RED));
        group.getChildren().add(box);

        // Set the camera and add it to the scene
        PerspectiveCamera camera = new PerspectiveCamera(true);
        camera.setFieldOfView(45);
        camera.setFarClip(10000);
        camera.setTranslateZ(-1000);
        root.getChildren().add(camera);

        // Create a scene with antialiasing
        Scene scene = new Scene(root, 500, 500, true, SceneAntialiasing.BALANCED);
        scene.setCamera(camera);

        // Add a resize listener to the scene to adjust the rectanguloid size
        scene.widthProperty().addListener((observable, oldValue, newValue) -> {
            double scale = newValue.doubleValue() / scene.getHeight();
            group.setScaleX(scale);
        });
        scene.heightProperty().addListener((observable, oldValue, newValue) -> {
            double scale = newValue.doubleValue() / scene.getWidth();
            group.setScaleY(scale);
        });

        // Add mouse and touch events to rotate the rectanguloid
        Rotate rotateX = new Rotate(0, Rotate.X_AXIS);
        Rotate rotateY = new Rotate(0, Rotate.Y_AXIS);
        group.getTransforms().addAll(rotateX, rotateY);

        Point3D axisX = new Point3D(1, 0, 0);
        Point3D axisY = new Point3D(0, 1, 0);

        group.setOnMousePressed(event -> {
            group.getTransforms().add(new Translate(event.getSceneX(), event.getSceneY(), 0));
        });

        group.setOnMouseDragged(event -> {
            double deltaX = event.getSceneX() - group.getTransforms().get(group.getTransforms().size() - 1).getTx();
            double deltaY = event.getSceneY() - group.getTransforms().get(group.getTransforms().size() - 1).getTy();

            rotateX.setAngle(rotateX.getAngle() - deltaY / 5);
            rotateY.setAngle(rotateY.getAngle() + deltaX / 5);

            group.getTransforms().set(group.getTransforms().size() - 1, new Translate(event.getSceneX(), event.getSceneY(), 0));
        });

        primaryStage.setScene(scene);
        primaryStage.setTitle(""Rectanguloid"");
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",4,"import javax.swing.*;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;

public class ResizableRectanguloid extends JFrame {
    private int cubeWidth = 100;
    private int cubeHeight = 100;

    public ResizableRectanguloid() {
        setTitle(""Resizable Rectanguloid"");
        setSize(400, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        JPanel panel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                int centerX = getWidth() / 2;
                int centerY = getHeight() / 2;

                int halfWidth = cubeWidth / 2;
                int halfHeight = cubeHeight / 2;

                // Draw the front face
                g.drawLine(centerX - halfWidth, centerY - halfHeight, centerX + halfWidth, centerY - halfHeight);
                g.drawLine(centerX - halfWidth, centerY - halfHeight, centerX - halfWidth, centerY + halfHeight);
                g.drawLine(centerX + halfWidth, centerY - halfHeight, centerX + halfWidth, centerY + halfHeight);
                g.drawLine(centerX - halfWidth, centerY + halfHeight, centerX + halfWidth, centerY + halfHeight);

                // Draw the back face
                g.drawLine(centerX, centerY - halfHeight, centerX - halfWidth, centerY - halfHeight);
                g.drawLine(centerX, centerY, centerX - halfWidth, centerY);
                g.drawLine(centerX, centerY - halfHeight, centerX, centerY);
            }
        };

        panel.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                cubeWidth = panel.getWidth() / 2;
                cubeHeight = panel.getHeight() / 2;
                panel.repaint();
            }
        });

        add(panel);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            ResizableRectanguloid rectanguloid = new ResizableRectanguloid();
            rectanguloid.setVisible(true);
        });
    }
}",0.3734567901234568
0_Exercise14_22.java," /**
 * *14.22 (Connect two circles) Write a program that draws two circles with radius
 * 15 pixels, centered at random locations, with a line connecting the two circles.
 * The line should not cross inside the circles, as shown in Figure 14.49c.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import javafx.stage.Stage;


public class Exercise14_22 extends Application {
    static final double WIDTH = 400;
    static final double HEIGHT = 400;
    static final double RADIUS = 15;


    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();
        double x1 = Math.random() * (WIDTH - 15);
        double y1 = Math.random() * (HEIGHT - 15);
        double x2 = Math.random() * (WIDTH - 15);
        double y2 = Math.random() * (HEIGHT - 15);

        Circle c1 = new Circle(x1, y1, RADIUS);
        Circle c2 = new Circle(x2, y2, RADIUS);
        c1.setFill(Color.WHITE);
        c1.setStroke(Color.BLACK);
        c2.setFill(Color.WHITE);
        c2.setStroke(Color.BLACK);

        Text text1 = new Text(x1, y1, ""1"");
        Text text2 = new Text(x2, y2, ""2"");

        Line line = drawConnectionLine(x1, y1, x2, y2, RADIUS);

        pane.getChildren().addAll(c1, c2, line, text1, text2);

        Scene scene = new Scene(pane, WIDTH, HEIGHT);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    private Line drawConnectionLine(
            double x1, double y1, double x2, double y2, double radius) {
        double d = Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
        int x11 = (int) (x1 - radius * (x1 - x2) / d);
        int y11 = (int) (y1 - radius * (y1 - y2) / d);
        int x21 = (int) (x2 + radius * (x1 - x2) / d);
        int y21 = (int) (y2 + radius * (y1 - y2) / d);
        return new Line(x11, y11, x21, y21);
    }

    public static void main(String[] args) {
        Application.launch(args);
    }
}","import javafx.application.Application;
import javafx.geometry.Point2D;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

import java.util.Random;

public class TwoCircles extends Application {

    private final int RADIUS = 15;
    private final int WINDOW_WIDTH = 500;
    private final int WINDOW_HEIGHT = 500;

    @Override
    public void start(Stage primaryStage) throws Exception {
        // Create a Group to hold the circles and line
        Group root = new Group();

        // Create the two circles with random centers
        Random random = new Random();
        Circle circle1 = new Circle(random.nextInt(WINDOW_WIDTH), random.nextInt(WINDOW_HEIGHT), RADIUS, Color.RED);
        Circle circle2 = new Circle(random.nextInt(WINDOW_WIDTH), random.nextInt(WINDOW_HEIGHT), RADIUS, Color.BLUE);

        // Calculate the line endpoints to avoid crossing inside the circles
        Point2D point1 = new Point2D(circle1.getCenterX(), circle1.getCenterY());
        Point2D point2 = new Point2D(circle2.getCenterX(), circle2.getCenterY());
        Point2D direction = point2.subtract(point1).normalize();
        Point2D offset1 = direction.multiply(RADIUS);
        Point2D offset2 = direction.multiply(-RADIUS);
        Point2D lineStart = point1.add(offset1);
        Point2D lineEnd = point2.add(offset2);

        // Create the line with the calculated endpoints
        Line line = new Line(lineStart.getX(), lineStart.getY(), lineEnd.getX(), lineEnd.getY());
        line.setStrokeWidth(2);
        line.setStroke(Color.GREEN);

        // Add the circles and line to the root Group
        root.getChildren().addAll(circle1, circle2, line);

        // Create the Scene and set it on the Stage
        Scene scene = new Scene(root, WINDOW_WIDTH, WINDOW_HEIGHT);
        primaryStage.setScene(scene);
        primaryStage.setTitle(""Two Circles"");
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",4,"import javax.swing.*;
import java.awt.*;
import java.util.Random;

public class ConnectTwoCircles extends JFrame {
    public ConnectTwoCircles() {
        setTitle(""Connect Two Circles"");
        setSize(400, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        JPanel panel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                Random random = new Random();

                int centerX1 = random.nextInt(getWidth() - 30) + 15;
                int centerY1 = random.nextInt(getHeight() - 30) + 15;

                int centerX2 = random.nextInt(getWidth() - 30) + 15;
                int centerY2 = random.nextInt(getHeight() - 30) + 15;

                int radius = 15;

                g.drawOval(centerX1 - radius, centerY1 - radius, 2 * radius, 2 * radius);
                g.drawOval(centerX2 - radius, centerY2 - radius, 2 * radius, 2 * radius);

                // Calculate the distance between centers
                double distance = Math.sqrt(Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2));

                // Draw a line connecting the circles
                if (distance > 2 * radius) {
                    g.drawLine(centerX1, centerY1, centerX2, centerY2);
                }
            }
        };

        add(panel);
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            ConnectTwoCircles connectTwoCircles = new ConnectTwoCircles();
            connectTwoCircles.setVisible(true);
        });
    }
}",0.39774506733479487
0_Exercise14_18.java," /**
 * *14.18 (Plot the square function) Write a program that draws a diagram for the function
 * f(x) = x2 (see Figure 14.48b).
 * Hint: Add points to a polyline using the following code:
 * <p><br>
 * {@code
 * Polyline polyline = new Polyline();
 * ObservableList<Double> list = polyline.getPoints();
 * double scaleFactor = 0.0125;
 * for (int x = -100; x <= 100; x++) {
 * list.add(x + 200.0);
 * list.add(scaleFactor * x * x);
 * }
 * }
 */","package ch_14;

import javafx.application.Application;
import javafx.collections.ObservableList;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polyline;
import javafx.scene.text.Text;
import javafx.stage.Stage;


public class Exercise14_18 extends Application {
    private static final double WIDTH = 400;
    private static final double HEIGHT = 400;

    @Override
    public void start(Stage primaryStage) {
        Polyline polyline = new Polyline();
        ObservableList<Double> list = polyline.getPoints();
        Group group = new Group();

        double scaleFactor = 0.0125;
        for (int x = -100; x <= 100; x++) {
            list.add(x + 200.0);
            list.add(200 - scaleFactor * x * x);
        }
        group.getChildren().add(polyline); // Add points for the Parabola

        Line line1 = new Line(10, 200, 390, 200); // The X-Axis
        group.getChildren().add(line1);

        Line line2 = new Line(200, 30, 200, 390); // The Y-Axis
        group.getChildren().add(line2);

        /* The X-Axis Arrow */
        Line line3 = new Line(390, 200, 370, 190);
        group.getChildren().add(line3);
        Line line4 = new Line(390, 200, 370, 210);
        group.getChildren().add(line4);

        /* The Y-Axis Arrow */
        Line line5 = new Line(200, 30, 190, 50);
        group.getChildren().add(line5);
        Line line6 = new Line(200, 30, 210, 50);
        group.getChildren().add(line6);

        Text text1 = new Text(380, 170, ""X"");
        Text text2 = new Text(220, 40, ""Y"");
        group.getChildren().addAll(text1, text2);

        Scene scene = new Scene(new BorderPane(group), WIDTH, HEIGHT);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

}
","import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class FunctionDiagram extends JPanel {
    private int centerX = 200;
    private int centerY = 200;
    private int scaleX = 40;
    private int scaleY = 40;
    private int maxX = 5;
    private int minX = -5;
    private int maxY = 25;
    private int minY = 0;
    
    public FunctionDiagram() {
    }
    
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        // draw the x and y axes
        g.setColor(Color.BLACK);
        g.drawLine(centerX + minX * scaleX, centerY, centerX + maxX * scaleX, centerY);
        g.drawLine(centerX, centerY - maxY * scaleY, centerX, centerY - minY * scaleY);
        
        // draw the function curve
        g.setColor(Color.BLUE);
        for (double x = minX; x <= maxX; x += 0.1) {
            double y = x * x;
            int xPixel = (int)(centerX + x * scaleX);
            int yPixel = (int)(centerY - y * scaleY);
            g.fillOval(xPixel, yPixel, 2, 2);
        }
    }
    
    public static void main(String[] args) {
        JFrame frame = new JFrame(""Function Diagram"");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        FunctionDiagram panel = new FunctionDiagram();
        panel.setBackground(Color.WHITE);
        frame.add(panel);
        frame.setSize(400, 400);
        frame.setVisible(true);
    }
}
",4,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polyline;
import javafx.stage.Stage;

public class PlotSquareFunction extends Application {
    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        Polyline polyline = new Polyline();
        polyline.setStroke(Color.BLUE);

        for (int x = -100; x <= 100; x++) {
            polyline.getPoints().add(x + 200.0);
            polyline.getPoints().add(0.0125 * x * x + 200.0);
        }

        pane.getChildren().add(polyline);

        Scene scene = new Scene(pane, 400, 400);
        primaryStage.setTitle(""Plot Square Function"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",0.40380761523046094
0_Exercise14_23.java," /**
 * 14.23 (Geometry: two rectangles) Write a program that prompts the user to enter the
 * center coordinates, width, and height of two rectangles from the command line.
 * The program displays the rectangles and a text indicating whether the two are
 * overlapping, whether one is contained in the other, or whether they don’t overlap,
 * as shown in Figure 14.50. See Programming Exercise 10.13 for checking the
 * relationship between two rectangles.
 */","package ch_14;

import ch_10.exercise10_13.MyRectangle2D;
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;

import java.util.List;
import java.util.Scanner;


public class Exercise14_23 extends Application {
    MyRectangle2D rectangleModel1 = new MyRectangle2D();
    MyRectangle2D rectangleModel2 = new MyRectangle2D();

    private static final String OVERLAP = ""The rectangles overlap."";
    private static final String DONT_OVERLAP = ""The rectangles do not overlap."";
    private static final String CONTAIN = ""One rectangle is contained in another."";

    public static void main(String[] args) {
        String[] myArgs = new String[8];
        Scanner in = new Scanner(System.in);
        System.out.println(""Rectangle 1 -> x and y are Center coordinates. Enter: x, y, width, height:  "");
        args = in.nextLine().split("" "");
        System.arraycopy(args, 0, myArgs, 0, 4);
        System.out.println(""Rectangle 2 -> x and y are Center coordinates. Enter: x, y, width, height:  "");
        String[] rect2 = in.nextLine().split("" "");
        System.arraycopy(rect2, 0, myArgs, 4, 4);
        in.close();

        Application.launch(myArgs);

    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Pane pane = new Pane();

        Parameters params = getParameters();
        List<String> passedInArgs = params.getRaw();
        if (passedInArgs.size() < 8) {
            System.out.println(""Usage: Must be called with parameters to create Rectangles.... Should be 8 String"" +
                    "" values."");
        }
        rectangleModel1.setX(Double.parseDouble(passedInArgs.get(0)));
        rectangleModel1.setY(Double.parseDouble(passedInArgs.get(1)));
        rectangleModel1.setHeight(Double.parseDouble(passedInArgs.get(2)));
        rectangleModel1.setWidth(Double.parseDouble(passedInArgs.get(3)));

        rectangleModel2.setX(Double.parseDouble(passedInArgs.get(4)));
        rectangleModel2.setY(Double.parseDouble(passedInArgs.get(5)));
        rectangleModel2.setHeight(Double.parseDouble(passedInArgs.get(6)));
        rectangleModel2.setWidth(Double.parseDouble(passedInArgs.get(7)));

        Rectangle r1View = new Rectangle(rectangleModel1.getX(), rectangleModel1.getY(), rectangleModel1.getWidth(),
                rectangleModel1.getHeight());
        r1View.setFill(Color.TRANSPARENT);
        r1View.setStroke(Color.BLACK);
        Rectangle r2View = new Rectangle(rectangleModel2.getX(), rectangleModel2.getY(), rectangleModel2.getWidth(),
                rectangleModel2.getHeight());
        r2View.setFill(Color.TRANSPARENT);
        r2View.setStroke(Color.BLACK);
        Text text = new Text(getTextFromRectangles(rectangleModel1, rectangleModel2));
        text.setTextAlignment(TextAlignment.CENTER);
        text.setY(380);
        text.setX(125);
        pane.getChildren().addAll(r1View, r2View, text);

        Scene scene = new Scene(pane, 400, 400);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

    }

    private String getTextFromRectangles(MyRectangle2D rectangleModel1, MyRectangle2D rectangleModel2) {
        if (rectangleModel1.overlaps(rectangleModel2)) {
            return OVERLAP;
        } else if (rectangleModel1.contains(rectangleModel2) || rectangleModel2.contains(rectangleModel1)) {
            return CONTAIN;
        } else {
            return DONT_OVERLAP;
        }
    }


}
","import java.util.Scanner;

public class RectangleOverlap {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter the center coordinates, width, and height of two rectangles
        System.out.println(""Enter the center coordinates, width, and height of rectangle 1: "");
        double x1 = input.nextDouble();
        double y1 = input.nextDouble();
        double w1 = input.nextDouble();
        double h1 = input.nextDouble();

        System.out.println(""Enter the center coordinates, width, and height of rectangle 2: "");
        double x2 = input.nextDouble();
        double y2 = input.nextDouble();
        double w2 = input.nextDouble();
        double h2 = input.nextDouble();

        // Determine the corner coordinates of each rectangle
        double x1Left = x1 - w1 / 2;
        double x1Right = x1 + w1 / 2;
        double y1Top = y1 - h1 / 2;
        double y1Bottom = y1 + h1 / 2;

        double x2Left = x2 - w2 / 2;
        double x2Right = x2 + w2 / 2;
        double y2Top = y2 - h2 / 2;
        double y2Bottom = y2 + h2 / 2;

        // Determine whether the two rectangles overlap, are contained, or don't overlap
        String message = """";
        if (x1Left <= x2Right && x1Right >= x2Left && y1Top <= y2Bottom && y1Bottom >= y2Top) {
            message = ""The rectangles overlap."";
        } else if (x1Left >= x2Left && x1Right <= x2Right && y1Top >= y2Top && y1Bottom <= y2Bottom) {
            message = ""Rectangle 1 is contained in rectangle 2."";
        } else if (x2Left >= x1Left && x2Right <= x1Right && y2Top >= y1Top && y2Bottom <= y1Bottom) {
            message = ""Rectangle 2 is contained in rectangle 1."";
        } else {
            message = ""The rectangles don't overlap."";
        }

        // Display the rectangles and the message
        System.out.println(message);
        System.out.println(""Rectangle 1: ("" + x1 + "", "" + y1 + ""), width = "" + w1 + "", height = "" + h1);
        System.out.println(""Rectangle 2: ("" + x2 + "", "" + y2 + ""), width = "" + w2 + "", height = "" + h2);
    }
}",4,"import java.util.Scanner;

public class RectangleRelationshipChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println(""Enter the center coordinates, width, and height of the first rectangle:"");
        double x1 = scanner.nextDouble();
        double y1 = scanner.nextDouble();
        double width1 = scanner.nextDouble();
        double height1 = scanner.nextDouble();

        System.out.println(""Enter the center coordinates, width, and height of the second rectangle:"");
        double x2 = scanner.nextDouble();
        double y2 = scanner.nextDouble();
        double width2 = scanner.nextDouble();
        double height2 = scanner.nextDouble();

        // Check for overlapping, containment, or no overlap
        if (Math.abs(x1 - x2) <= (width1 + width2) / 2 && Math.abs(y1 - y2) <= (height1 + height2) / 2) {
            if (Math.abs(x1 - x2) <= Math.abs(width1 - width2) / 2 && Math.abs(y1 - y2) <= Math.abs(height1 - height2) / 2) {
                System.out.println(""One rectangle is contained in the other."");
            } else {
                System.out.println(""The rectangles overlap."");
            }
        } else {
            System.out.println(""The rectangles don't overlap."");
        }

        scanner.close();
    }
}",0.5611559139784946
0_Exercise14_15.java," /**
 * 14.15 (Display a STOP sign) Write a program that displays a STOP sign, as shown
 * in Figure 14.47b. The octagon is in red and the sign is in white. (Hint: Place an
 * octagon and a text in a stack pane.)
 */","package ch_14;

import javafx.application.Application;
import javafx.collections.ObservableList;
import javafx.scene.Scene;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;


public class Exercise14_15 extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        StackPane stackPane = new StackPane();
        Polygon polygon = new Polygon();
        stackPane.getChildren().add(polygon);
        polygon.setFill(Color.RED);
        polygon.setStroke(Color.RED);

        ObservableList<Double> list = polygon.getPoints();
        final double WIDTH = 200, HEIGHT = 200;
        double centerX = WIDTH / 2, centerY = HEIGHT / 2;
        double radius = Math.min(WIDTH, HEIGHT) * 0.4;
        // Add points to the polygon list -> divide Math.PI by 8 for Octagon
        for (int i = 0; i < 8; i++) {
            list.add(centerX + radius * Math.cos(2 * i * Math.PI / 8));
            list.add(centerY - radius * Math.sin(2 * i * Math.PI / 8));
        }
        polygon.setRotate(22.5);

        Text text = new Text(""STOP"");
        text.setTextAlignment(TextAlignment.CENTER);
        text.setFill(Color.WHITE);
        text.setStroke(Color.WHITE);
        text.setFont(Font.font(42));
        stackPane.getChildren().add(text);

        Scene scene = new Scene(stackPane, WIDTH, HEIGHT);
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setResizable(false);
        primaryStage.show();
    }
}
","import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class StopSign extends Application {
    
    @Override
    public void start(Stage primaryStage) {
        // Create a polygon that represents an octagon
        Polygon octagon = new Polygon();
        octagon.getPoints().addAll(new Double[]{
            100.0, 0.0,
            200.0, 0.0,
            300.0, 100.0,
            300.0, 200.0,
            200.0, 300.0,
            100.0, 300.0,
            0.0, 200.0,
            0.0, 100.0
        });
        octagon.setFill(Color.RED); // Set the octagon to be red
        
        // Create a text object that says ""STOP""
        Text stopText = new Text(""STOP"");
        stopText.setFont(Font.font(""Arial"", 100)); // Set the font and size of the text
        stopText.setFill(Color.WHITE); // Set the text color to white
        
        // Create a stack pane to hold the octagon and text
        StackPane stackPane = new StackPane();
        stackPane.getChildren().addAll(octagon, stopText);
        
        // Create a scene with the stack pane as the root node
        Scene scene = new Scene(stackPane, 300, 300);
        
        // Set the title of the window and display it
        primaryStage.setTitle(""STOP Sign"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    
    public static void main(String[] args) {
        launch(args);
    }
}",4,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.TextAlignment;
import javafx.stage.Stage;

public class DisplayStopSign extends Application {
    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        Polygon octagon = new Polygon();
        octagon.setStroke(Color.RED);
        octagon.setFill(Color.RED);
        for (int i = 0; i < 8; i++) {
            double angle = 2 * Math.PI / 8 * i;
            double x = 100 + 80 * Math.cos(angle);
            double y = 100 - 80 * Math.sin(angle);
            octagon.getPoints().addAll(x, y);
        }

        Label stopLabel = new Label(""STOP"");
        stopLabel.setFont(Font.font(""Arial"", FontWeight.BOLD, 48));
        stopLabel.setTextFill(Color.WHITE);
        stopLabel.setLayoutX(50);
        stopLabel.setLayoutY(85);
        stopLabel.setTextAlignment(TextAlignment.CENTER);

        pane.getChildren().addAll(octagon, stopLabel);

        Scene scene = new Scene(pane, 200, 200);
        primaryStage.setTitle(""Display STOP Sign"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",0.6599535243996901
0_Exercise14_03.java," /**
 * *14.3 (Display three cards) Write a program that displays three cards randomly
 * selected from a deck of 52, as shown in Figure 14.43c. The card image files
 * are named 1.png, 2.png, …, 52.png and stored in the image/card directory.
 * All three cards are distinct and selected randomly. Hint: You can select random
 * cards by storing the numbers 1–52 to an array list, perform a random shuffle
 * introduced in Section 11.12, and use the first three numbers in the array list as
 * the file names for the image.
 */","package ch_14;

import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;



public class Exercise14_03 extends Application {
    Image[] cards;
    int[] picked = new int[3];
    int pick = 0;

    private void setCards() {
        cards = new Image[52];
        int cardNum = 1;
        for (int i = 0; i < cards.length; i++) {
            Image card = new Image(""resources/cards/"" + cardNum + "".png"");
            cards[i] = card;

            cardNum++;

        }

    }


    @Override
    public void start(Stage primaryStage) throws Exception {
        setCards();
        VBox vbox = new VBox();
        HBox cardBox = new HBox();
        HBox buttonBar = new HBox();
        vbox.setFillWidth(true);

        ImageView card1 = new ImageView(cards[randomCard()]);
        card1.setPreserveRatio(true);
        card1.setFitHeight(300);

        ImageView card2 = new ImageView(cards[randomCard()]);
        card2.setPreserveRatio(true);
        card2.setFitHeight(300);

        ImageView card3 = new ImageView(cards[randomCard()]);
        card3.setPreserveRatio(true);
        card3.setFitHeight(300);

        Button refreshButton = new Button(""Refresh"");
        refreshButton.setOnAction(e -> {
            refreshCards(vbox);
        });

        buttonBar.getChildren().add(refreshButton);
        buttonBar.setAlignment(Pos.CENTER);

        cardBox.getChildren().addAll(card1, card2, card3);
        vbox.getChildren().add(cardBox);
        vbox.getChildren().add(buttonBar);
        Scene scene = new Scene(vbox);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

    }

    private void refreshCards(VBox vBox) {
        pick = 0;
        HBox nuCardBox = new HBox();
        ImageView c1 = new ImageView(cards[randomCard()]);
        c1.setPreserveRatio(true);
        c1.setFitHeight(300);

        ImageView c2 = new ImageView(cards[randomCard()]);
        c2.setPreserveRatio(true);
        c2.setFitHeight(300);

        ImageView c3 = new ImageView(cards[randomCard()]);
        c3.setPreserveRatio(true);
        c3.setFitHeight(300);
        nuCardBox.getChildren().addAll(c1, c2, c3);
        vBox.getChildren().set(0, nuCardBox);

    }

    int randomCard() {
        int ran = -1;
        do {
            ran = (int) (Math.random() * 52);

        } while (ran == picked[0] || ran == picked[1] || ran == picked[2]);

        picked[pick++] = ran;

        return ran;
    }

}
","import java.util.ArrayList;
import java.util.Collections;

public class RandomCards {

    public static void main(String[] args) {
        ArrayList<Integer> deck = new ArrayList<>();
        for (int i = 1; i <= 52; i++) {
            deck.add(i);
        }
        Collections.shuffle(deck);
        int card1 = deck.get(0);
        int card2 = deck.get(1);
        int card3 = deck.get(2);
        System.out.println(""Card 1: "" + card1 + "".png"");
        System.out.println(""Card 2: "" + card2 + "".png"");
        System.out.println(""Card 3: "" + card3 + "".png"");
    }
}",4,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class DisplayThreeRandomCards extends Application {
    @Override
    public void start(Stage primaryStage) {
        HBox cardBox = new HBox();

        List<Integer> cardNumbers = new ArrayList<>();
        for (int i = 1; i <= 52; i++) {
            cardNumbers.add(i);
        }
        Collections.shuffle(cardNumbers);

        for (int i = 0; i < 3; i++) {
            int cardNumber = cardNumbers.get(i);
            String cardImagePath = ""image/card/"" + cardNumber + "".png"";
            Image cardImage = new Image(cardImagePath);
            ImageView cardImageView = new ImageView(cardImage);
            cardBox.getChildren().add(cardImageView);
        }

        Scene scene = new Scene(cardBox);
        primaryStage.setTitle(""Three Random Cards"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",0.47136273864384465
0_Exercise14_16.java," /**
 * *14.16 (Display a 3 * 3 grid) Write a program that displays a 3 * 3 grid, as shown in
 * Figure 14.47c. Use red color for vertical lines and blue for horizontals. The lines
 * are automatically resized when the window is resized.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.stage.Stage;


public class Exercise14_16 extends Application {
    private static final double WIDTH = 200;
    private static final double HEIGHT = 200;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Pane pane = new Pane();

        Line line1 = new Line(0, 0, 0, 0);
        line1.startYProperty().bind(pane.heightProperty().divide(3));
        line1.endXProperty().bind(pane.widthProperty());
        line1.endYProperty().bind(pane.heightProperty().divide(3));
        line1.setStroke(Color.BLUE);

        Line line2 = new Line(0, 0, 0, 0);
        line2.startYProperty().bind(pane.heightProperty().multiply(2).divide(3));
        line2.endXProperty().bind(pane.widthProperty());
        line2.endYProperty().bind(pane.heightProperty().multiply(2).divide(3));
        line2.setStroke(Color.BLUE);

        Line line3 = new Line(0, 0, 0, 0);
        line3.startXProperty().bind(pane.widthProperty().divide(3));
        line3.endXProperty().bind(pane.widthProperty().divide(3));
        line3.endYProperty().bind(pane.heightProperty());
        line3.setStroke(Color.RED);

        Line line4 = new Line(0, 0, 0, 0);
        line4.startXProperty().bind(pane.widthProperty().multiply(2).divide(3));
        line4.endXProperty().bind(pane.widthProperty().multiply(2).divide(3));
        line4.endYProperty().bind(pane.heightProperty());
        line4.setStroke(Color.RED);

        pane.getChildren().addAll(line1, line2, line3, line4);

        Scene scene = new Scene(pane, WIDTH, HEIGHT);
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();
    }

}
","import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

public class GridDisplay extends Application {
    
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 400, 400);
        
        double width = scene.getWidth();
        double height = scene.getHeight();
        double lineLength = 0.9 * Math.min(width, height) / 3;
        double x0 = 0.5 * (width - lineLength);
        double y0 = 0.5 * (height - lineLength);
        
        for (int i = 0; i < 4; i++) {
            Line line1 = new Line(x0 + i * lineLength, y0, x0 + i * lineLength, y0 + 3 * lineLength);
            line1.setStroke(Color.RED);
            Line line2 = new Line(x0, y0 + i * lineLength, x0 + 3 * lineLength, y0 + i * lineLength);
            line2.setStroke(Color.BLUE);
            root.getChildren().addAll(line1, line2);
        }
        
        stage.setScene(scene);
        stage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

public class DisplayGrid extends Application {
    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        // Create horizontal lines
        Line line1 = new Line(10, 50, 290, 50);
        Line line2 = new Line(10, 100, 290, 100);

        // Create vertical lines
        Line line3 = new Line(50, 10, 50, 290);
        Line line4 = new Line(100, 10, 100, 290);

        // Set line colors
        line1.setStroke(Color.BLUE);
        line2.setStroke(Color.BLUE);
        line3.setStroke(Color.RED);
        line4.setStroke(Color.RED);

        // Add lines to the pane
        pane.getChildren().addAll(line1, line2, line3, line4);

        // Create a scene and set it to the stage
        Scene scene = new Scene(pane, 300, 300);
        primaryStage.setTitle(""3x3 Grid"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",0.6214574898785425
0_Exercise14_20.java," /**
 * **14.20 (Draw an arrow line) Write a static method that draws an arrow line
 * from a starting point to an ending point in a pane using the following method header:
 * public static void drawArrowLine(double startX, double startY,
 * double endX, double endY, Pane pane)
 * Write a test program that randomly draws an arrow line, as shown in Figure 14.49a.
 * <p>
 * x3 = x2+L2/L1[(x1−x2)cosθ+(y1−y2)sinθ]
 * <p>
 * y3 = y2+L2/L1[(y1−y2)cosθ−(x1−x2)sinθ]
 * <p>
 * x4 = x2+L2/L1[(x1−x2)cosθ−(y1−y2)sinθ]
 * <p>
 * y4 = y2+L2/L1[(y1−y2)cosθ+(x1−x2)sinθ]
 *
 * <p>
 * Reference:
 * <a href=""https://math.stackexchange.com/questions/1314006/drawing-an-arrow"">Math for drawing an arrow</a>
 * </p>
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

import javafx.scene.shape.Line;

import java.util.Random;


public class Exercise14_20 extends Application {
    private static Stage primaryStage;
    private static double WIDTH = 400;
    private static double HEIGHT = 400;

    private static double x1;
    private static double x2;
    private static double y1;
    private static double y2;
    /* Length of main line body */
    private static double L1;
    /* Length of the lines that make the arrow */
    private static double L2;


    public static void drawArrowLine(double startX, double startY, double endX, double endY, Pane pane) {
        double x3, y3, x4, y4;

        Group group = new Group();
        Line line = new Line(startX, startY, endX, endY); // Draw the line for main body of arrow
        L1 = length(line);
        L2 = L1 / 8;
        //Calculate end points for the tip of the arrow
        x3 = endX + (L2 / L1) * (((startX - endX) * Math.cos(Math.toRadians(45.0))) + ((startY - endY) * Math.sin(Math.toRadians(45.0))));
        y3 = endY + (L2 / L1) * (((startY - endY) * Math.cos(Math.toRadians(45.0))) - ((startX - endX) * Math.sin(Math.toRadians(45.0))));
        x4 = endX + (L2 / L1) * (((startX - endX) * Math.cos(Math.toRadians(45.0))) - ((startY - endY) * Math.sin(Math.toRadians(45.0))));
        y4 = endY + (L2 / L1) * (((startY - endY) * Math.cos(Math.toRadians(45.0))) + ((startX - endX) * Math.sin(Math.toRadians(45.0))));

        Line arrowLine1 = new Line(endX, endY, x3, y3);
        Line arrowLine2 = new Line(endX, endY, x4, y4);

        group.getChildren().addAll(line, arrowLine1, arrowLine2);
        pane.getChildren().add(group);

        Scene scene = new Scene(pane, WIDTH, HEIGHT);
        primaryStage.setScene(scene);
        primaryStage.setTitle(Exercise14_20.class.getName());
        primaryStage.show();

    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        Exercise14_20.primaryStage = primaryStage;
        Random random = new Random();
        double bound = WIDTH - 100;
        x1 = random.nextInt((int) bound);
        y1 = random.nextInt((int) bound);
        x2 = random.nextInt((int) bound);
        y2 = random.nextInt((int) bound);
        if (Math.abs(y1 - y2) < 75) {
            y2 += 50;
        }
        if (Math.abs(x1 - x2) < 50) {
            x2 += 50;
        }
        Pane pane = new Pane();
        drawArrowLine(x1, y1, x2, y2, pane);

    }

    public static double findSlope(Line l) {
        return (l.getStartY() - l.getEndY()) / (l.getStartX() - l.getEndX());
    }

    public static double length(Line line) {
        return Math.sqrt((line.getStartX() - line.getEndX())
                * (line.getStartX() - line.getEndX())
                + (line.getStartY() - line.getEndY())
                * (line.getStartY() - line.getEndY()));
    }
}
","import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.scene.shape.Polygon;

public class ArrowLine {
    public static void drawArrowLine(double startX, double startY,
                                     double endX, double endY, Pane pane) {
        double length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
        double cos = (endX - startX) / length;
        double sin = (endY - startY) / length;
        double x3 = endX + (-10 * cos - 5 * sin);
        double y3 = endY + (-10 * sin + 5 * cos);
        double x4 = endX + (-10 * cos + 5 * sin);
        double y4 = endY + (-10 * sin - 5 * cos);
        Line line = new Line(startX, startY, endX, endY);
        Polygon arrowHead = new Polygon(endX, endY, x3, y3, x4, y4);
        pane.getChildren().addAll(line, arrowHead);
    }
}
",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

import java.util.Random;

public class DrawArrowLine extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        // Generate random coordinates for the starting and ending points
        Random random = new Random();
        double startX = random.nextDouble() * 300;
        double startY = random.nextDouble() * 300;
        double endX = random.nextDouble() * 300;
        double endY = random.nextDouble() * 300;

        drawArrowLine(startX, startY, endX, endY, pane);

        Scene scene = new Scene(pane, 300, 300);
        primaryStage.setTitle(""Random Arrow Line"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void drawArrowLine(double startX, double startY,
                                     double endX, double endY, Pane pane) {
        Line line = new Line(startX, startY, endX, endY);
        line.setStroke(Color.BLACK);

        // Calculate arrowhead points
        double angle = Math.atan2(endY - startY, endX - startX);
        double arrowLength = 10;
        double arrowWidth = 5;
        double arrowX1 = endX - arrowLength * Math.cos(angle - Math.toRadians(30));
        double arrowY1 = endY - arrowLength * Math.sin(angle - Math.toRadians(30));
        double arrowX2 = endX - arrowLength * Math.cos(angle + Math.toRadians(30));
        double arrowY2 = endY - arrowLength * Math.sin(angle + Math.toRadians(30));

        // Create arrowhead lines
        Line arrowLine1 = new Line(endX, endY, arrowX1, arrowY1);
        Line arrowLine2 = new Line(endX, endY, arrowX2, arrowY2);

        pane.getChildren().addAll(line, arrowLine1, arrowLine2);
    }
}",0.4582651391162029
0_Exercise14_21.java," /**
 * *14.21 (Two circles and their distance) Write a program that draws two filled circles
 * with radius 15 pixels, centered at random locations, with a line connecting the
 * two circles. The distance between the two centers is displayed on the line, as
 * shown in Figure 14.49b.
 */","package ch_14;

import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.application.Application;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

import javafx.scene.text.Text;


public class Exercise14_21 extends Application {
    private static final double HEIGHT = 400;
    private static final double WIDTH = 400;

    @Override
    public void start(Stage primaryStage) throws Exception {
        Pane pane = new Pane();
        Circle c1 = new Circle();
        c1.setRadius(15);
        c1.setFill(Color.BLACK);
        c1.setCenterX(10 + Math.random() * (WIDTH - 15));
        c1.setCenterY(10 + Math.random() * (HEIGHT - 15));
        pane.getChildren().add(c1);

        Circle c2 = new Circle();
        c2.setRadius(15);
        c2.setFill(Color.BLACK);
        c2.setCenterX(10 + Math.random() * (WIDTH - 15));
        c2.setCenterY(10 + Math.random() * (HEIGHT - 15));
        pane.getChildren().add(c2);

        Line line = drawConnectLine(c1.getCenterX(), c1.getCenterY(), c2.getCenterX(), c2.getCenterY());
        Text text = new Text(findDistanceFromCenters(c1, c2));
        text.setX((c1.getCenterX() + c2.getCenterX()) / 2);
        text.setY((c1.getCenterY() + c2.getCenterY()) / 2);

        pane.getChildren().add(line);
        pane.getChildren().add(text);

        Scene scene = new Scene(pane, WIDTH, HEIGHT);
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();

    }

    private Line drawConnectLine(double x1, double y1, double x2, double y2) {
        return new Line(x1, y1, x2, y2);
    }


    public static void main(String[] args) {
        Application.launch(args);
    }

    static String findDistanceFromCenters(Circle c1, Circle c2) {
        return String.format(""%.2f"",
                Math.sqrt(Math.pow(c1.getCenterX() - c2.getCenterX(), 2) + Math.pow(c1.getCenterY() - c2.getCenterY(), 2)));
    }

}
","import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import javafx.stage.Stage;

import java.util.Random;

public class TwoCircles extends Application {
    
    private static final int CIRCLE_RADIUS = 15;
    
    @Override
    public void start(Stage primaryStage) {
        
        // Create two random points
        Random rand = new Random();
        int x1 = rand.nextInt(400);
        int y1 = rand.nextInt(400);
        int x2 = rand.nextInt(400);
        int y2 = rand.nextInt(400);
        
        // Calculate the distance between the points
        double distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        
        // Create the circles
        Circle circle1 = new Circle(x1, y1, CIRCLE_RADIUS);
        circle1.setFill(javafx.scene.paint.Color.BLUE);
        Circle circle2 = new Circle(x2, y2, CIRCLE_RADIUS);
        circle2.setFill(javafx.scene.paint.Color.GREEN);
        
        // Create the line
        Line line = new Line(x1, y1, x2, y2);
        line.setStroke(javafx.scene.paint.Color.RED);
        
        // Create the distance text
        Text text = new Text((x1 + x2) / 2, (y1 + y2) / 2, String.format(""%.2f"", distance));
        text.setStroke(javafx.scene.paint.Color.BLACK);
        text.setStyle(""-fx-font-size: 14px;"");
        
        // Create a group to hold the shapes
        Group group = new Group(circle1, circle2, line, text);
        
        // Create a scene and add the group to it
        Scene scene = new Scene(group, 400, 400);
        
        // Set the stage title and scene, and show the stage
        primaryStage.setTitle(""Two Circles and Their Distance"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    
    public static void main(String[] args) {
        launch(args);
    }
}",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import java.util.Random;

public class TwoCirclesDistance extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        // Create two circles with random positions
        Circle circle1 = new Circle();
        circle1.setCenterX(generateRandomCoordinate());
        circle1.setCenterY(generateRandomCoordinate());
        circle1.setRadius(15);
        circle1.setFill(Color.RED);

        Circle circle2 = new Circle();
        circle2.setCenterX(generateRandomCoordinate());
        circle2.setCenterY(generateRandomCoordinate());
        circle2.setRadius(15);
        circle2.setFill(Color.BLUE);

        // Calculate the distance between the centers
        double distance = calculateDistance(circle1, circle2);

        // Create a line connecting the centers
        Line line = new Line(circle1.getCenterX(), circle1.getCenterY(), circle2.getCenterX(), circle2.getCenterY());
        line.setStroke(Color.GREEN);

        // Display the distance as text
        Text distanceText = new Text((circle1.getCenterX() + circle2.getCenterX()) / 2,
                (circle1.getCenterY() + circle2.getCenterY()) / 2, String.format(""%.2f"", distance));

        // Add shapes to the pane
        pane.getChildren().addAll(circle1, circle2, line, distanceText);

        Scene scene = new Scene(pane, 400, 400);
        primaryStage.setTitle(""Two Circles and Distance"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    private double generateRandomCoordinate() {
        Random random = new Random();
        return random.nextDouble() * 350 + 25; // Ensure circles are within the visible area
    }

    private double calculateDistance(Circle circle1, Circle circle2) {
        double x1 = circle1.getCenterX();
        double y1 = circle1.getCenterY();
        double x2 = circle2.getCenterX();
        double y2 = circle2.getCenterY();

        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
}
",0.5490723312718473
0_Exercise14_01.java," /**
 * 14.1 (Display images) Write a program that displays four images in a grid pane, as
 * shown in Figure 14.43a.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.image.*;
import javafx.scene.layout.*;
import javafx.stage.*;


public class Exercise14_01 extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {

        GridPane gridPane = new GridPane();
        ImageView imgV01 = new ImageView(new Image(""resources/Space_Man_Moon_Man.png""));
        imgV01.setFitHeight(200);
        imgV01.setFitWidth(300);
        imgV01.setSmooth(true);
        imgV01.setCache(true);

        ImageView imgV02 = new ImageView(new Image(""resources/GettyImages-10.png""));
        imgV02.setFitHeight(200);
        imgV02.setFitWidth(300);
        imgV02.setSmooth(true);
        imgV02.setCache(true);

        ImageView imgV03 = new ImageView(new Image(""resources/flyer1.jpg""));
        imgV03.setFitHeight(200);
        imgV03.setFitWidth(300);
        imgV03.setSmooth(true);
        imgV03.setCache(true);
        ImageView imgV04 = new ImageView(new Image(""resources/fintech-pic.jpg""));
        imgV04.setFitHeight(200);
        imgV04.setFitWidth(300);
        imgV04.setSmooth(true);
        imgV04.setCache(true);
        GridPane.setConstraints(imgV01, 0, 1);
        GridPane.setConstraints(imgV02, 2, 4);
        GridPane.setConstraints(imgV03, 0, 4);
        GridPane.setConstraints(imgV04, 2, 1);

        gridPane.getChildren().addAll(imgV01, imgV02, imgV03, imgV04);
        Scene scene = new Scene(gridPane);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

    }

}
","import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class DisplayImages extends Application {
    
    @Override
    public void start(Stage primaryStage) {
        
        // Create a grid pane
        GridPane pane = new GridPane();
        pane.setAlignment(Pos.CENTER);
        pane.setHgap(5);
        pane.setVgap(5);
        pane.setPadding(new Insets(10));
        
        // Create image views and add them to the grid pane
        ImageView image1 = new ImageView(new Image(""image1.jpg""));
        pane.add(image1, 0, 0);
        
        ImageView image2 = new ImageView(new Image(""image2.jpg""));
        pane.add(image2, 1, 0);
        
        ImageView image3 = new ImageView(new Image(""image3.jpg""));
        pane.add(image3, 0, 1);
        
        ImageView image4 = new ImageView(new Image(""image4.jpg""));
        pane.add(image4, 1, 1);
        
        // Create a scene and add the grid pane to it
        Scene scene = new Scene(pane, 400, 400);
        
        // Set the stage title and scene, and show the stage
        primaryStage.setTitle(""Display Images"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    
    public static void main(String[] args) {
        launch(args);
    }
}",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class DisplayImages extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Create a grid pane
        GridPane gridPane = new GridPane();

        // Load four images
        Image image1 = new Image(""file:image1.png"");
        Image image2 = new Image(""file:image2.png"");
        Image image3 = new Image(""file:image3.png"");
        Image image4 = new Image(""file:image4.png"");

        // Create image views and set images
        ImageView imageView1 = new ImageView(image1);
        ImageView imageView2 = new ImageView(image2);
        ImageView imageView3 = new ImageView(image3);
        ImageView imageView4 = new ImageView(image4);

        // Add images to the grid pane
        gridPane.add(imageView1, 0, 0);
        gridPane.add(imageView2, 1, 0);
        gridPane.add(imageView3, 0, 1);
        gridPane.add(imageView4, 1, 1);

        // Create a scene and set it in the stage
        Scene scene = new Scene(gridPane, 400, 400);
        primaryStage.setTitle(""Display Images"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}",0.6844044207941056
0_Exercise14_17.java," /**
 * 14.17 (Game: hangman) Write a program that displays a drawing for the popular hangman game, as shown in Figure 14.48a.
 */","package ch_14;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.io.FileInputStream;
import java.io.IOException;


public class Exercise14_17 extends Application {

    private final static double HEIGHT = 320;
    private final static double WIDTH = 300;

    @Override
    public void start(Stage primaryStage) {
        FXMLLoader fxmlLoader = new FXMLLoader();
        try {
            Parent root = fxmlLoader.load(new FileInputStream(""ch_14/exercise14_17/hangman.fxml""));
            primaryStage.setTitle(getClass().getName());
            root.setTranslateX(20); //Float right to center in frame
            Scene scene = new Scene(root, WIDTH, HEIGHT);
            primaryStage.setScene(scene);
            primaryStage.setResizable(false);
            primaryStage.show();

        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
        /*
        Pane pane = new Pane();
        ObservableList<Node> list = pane.getChildren();

        Arc arc = new Arc(WIDTH / 4, HEIGHT - HEIGHT / 12, WIDTH / 5, HEIGHT / 12, 0, 180);
        arc.setFill(Color.TRANSPARENT);
        arc.setStroke(Color.BLACK);
        list.add(arc);

        Line pole = new Line(arc.getCenterX(), arc.getCenterY() - arc.getRadiusY(), arc.getCenterX(), pane.getHeight() / 12);
        list.add(pole);

        Line holder = new Line(pole.getEndX(), pole.getEndY(), pane.getWidth() / 1.5, pole.getEndY());
        list.add(holder);
        Line hang = new Line(holder.getEndX(), holder.getEndY(), holder.getEndX(), pane.getHeight() / 6);
        list.add(hang);

        double radius = WIDTH / 10;
        Circle c = new Circle(holder.getEndX(), pane.getHeight() / 6 + radius, radius);
        c.setFill(Color.TRANSPARENT);
        c.setStroke(Color.BLACK);
        list.add(c);

        Line leftArm = new Line(pane.getWidth() / 2, pane.getHeight() / 2,
                c.getCenterX() + c.getRadius() * Math.cos(Math.toRadians(angle)),
                c.getCenterY() - c.getRadius() * Math.sin(Math.toRadians(angle));
        list.add(leftArm);

        Line rightArm = new Line(pane.getWidth() / 1.2, pane.getHeight() / 2,
                c.getCenterX() + c.getRadius() * Math.cos(Math.toRadians(angle),
                        c.getCenterY() - c.getRadius() * Math.sin(Math.toRadians(angle));
        list.add(rightArm);

        Line body = new Line(c.getCenterX() + c.getRadius() * Math.cos(Math.toRadians(angle)),
                c.getCenterY() - c.getRadius() * Math.sin(Math.toRadians(angle)),
                c.getCenterX() + c.getRadius() * Math.cos(Math.toRadians(angle), pane.getHeight() / 1.6);
        list.add(body);

        Line leftLeg = new Line(body.getEndX(), body.getEndY(),
                pane.getWidth() / 2, pane.getHeight() / 1.3);
        list.add(leftLeg);

        Line rightLeg = new Line(body.getEndX(), body.getEndY(),
                pane.getWidth() / 1.2, pane.getHeight() / 1.3);
        list.add(rightLeg); */

    }
}
","import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.shape.Line;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class Hangman extends Application {
    
    private static final int WIDTH = 400;
    private static final int HEIGHT = 400;
    private static final int MARGIN = 50;
    
    @Override
    public void start(Stage primaryStage) {
        
        // Create the shapes for the hangman
        Line base = new Line(MARGIN, HEIGHT - MARGIN, WIDTH - MARGIN, HEIGHT - MARGIN);
        Line pole = new Line(MARGIN, MARGIN, MARGIN, HEIGHT - MARGIN);
        Line rope = new Line(pole.getEndX(), pole.getEndY(), pole.getEndX(), pole.getEndY() + 50);
        Circle head = new Circle(rope.getEndX(), rope.getEndY() + 25, 25);
        Line body = new Line(head.getCenterX(), head.getCenterY() + head.getRadius(), head.getCenterX(), head.getCenterY() + head.getRadius() + 100);
        Line leftArm = new Line(body.getEndX(), body.getEndY() - 50, body.getEndX() - 50, body.getEndY());
        Line rightArm = new Line(body.getEndX(), body.getEndY() - 50, body.getEndX() + 50, body.getEndY());
        Line leftLeg = new Line(body.getEndX(), body.getEndY(), body.getEndX() - 50, body.getEndY() + 100);
        Line rightLeg = new Line(body.getEndX(), body.getEndY(), body.getEndX() + 50, body.getEndY() + 100);
        
        // Create the ground rectangle
        Rectangle ground = new Rectangle(MARGIN, HEIGHT - MARGIN + 10, WIDTH - 2 * MARGIN, 10);
        ground.setFill(javafx.scene.paint.Color.BROWN);
        
        // Create a group to hold the shapes
        Group group = new Group(base, pole, rope, head, body, leftArm, rightArm, leftLeg, rightLeg, ground);
        
        // Create a scene and add the group to it
        Scene scene = new Scene(group, WIDTH, HEIGHT);
        
        // Set the stage title and scene, and show the stage
        primaryStage.setTitle(""Hangman"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
    
    public static void main(String[] args) {
        launch(args);
    }
}",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

public class HangmanGame extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Create a pane to display the hangman drawing
        Pane pane = new Pane();

        // Create a hangman base (ground)
        Line base = new Line(20, 250, 200, 250);

        // Create a vertical post
        Line post = new Line(60, 250, 60, 50);

        // Create a horizontal beam
        Line beam = new Line(60, 50, 150, 50);

        // Create a rope
        Line rope = new Line(150, 50, 150, 100);

        // Create a head
        Circle head = new Circle(150, 125, 25);
        head.setFill(null);
        head.setStroke(Color.BLACK);

        // Add elements to the pane
        pane.getChildren().addAll(base, post, beam, rope, head);

        // Create a scene and set it in the stage
        Scene scene = new Scene(pane, 220, 280);
        primaryStage.setTitle(""Hangman Game"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}",0.5407166123778502
0_Exercise14_26.java," /**
 * 14.26 (Use the ClockPane class) Write a program that displays two clocks. The hour,
 * minute, and second values are 4, 20, 45 for the first clock and 22, 46, 15 for the
 * second clock, as shown in Figure 14.51c.
 */ /**
     * Construct a default clock with the current time
     */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import javafx.stage.Stage;

import java.util.Calendar;
import java.util.GregorianCalendar;


public class Exercise14_26 extends Application {
    double paneWidth = 475;
    double paneHeight = 275;

    @Override
    public void start(Stage primaryStage) {

        ClockPane clock1 = new ClockPane(4, 20, 45);
        ClockPane clock2 = new ClockPane(22, 46, 15);

        GridPane pane = new GridPane();
        pane.add(clock1, 0, 0);
        pane.add(clock2, 1, 0);

        clock1.setW(250);
        clock1.setH(250);
        clock2.setW(250);
        clock2.setH(250);

        Scene scene = new Scene(pane, paneWidth, paneHeight);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }


    public static void main(String[] args) {
        launch(args);
    }
}

class ClockPane extends Pane {
    private int hour;
    private int minute;
    private int second;

    private double w = 250, h = 250;

    
    public ClockPane() {
        setCurrentTime();
    }

    public ClockPane(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        paintClock();
    }

    public int getHour() {
        return hour;
    }

    public void setHour(int hour) {
        this.hour = hour;
        paintClock();
    }

    public int getMinute() {
        return minute;
    }

    public void setMinute(int minute) {
        this.minute = minute;
        paintClock();
    }

    public int getSecond() {
        return second;
    }

    public void setSecond(int second) {
        this.second = second;
        paintClock();
    }

    public double getW() {
        return w;
    }

    public void setW(double w) {
        this.w = w;
        paintClock();
    }

    public double getH() {
        return h;
    }

    public void setH(double h) {
        this.h = h;
        paintClock();
    }

    public void setCurrentTime() {
        Calendar calendar = new GregorianCalendar();
        this.hour = calendar.get(Calendar.HOUR_OF_DAY);
        this.minute = calendar.get(Calendar.MINUTE);
        this.second = calendar.get(Calendar.SECOND);
        paintClock(); // Repaint the clock
    }

    protected void paintClock() {
        double clockRadius = Math.min(w, h) * 0.8 * 0.5;
        double centerX = w / 2;
        double centerY = h / 2;

        Circle circle = new Circle(centerX, centerY, clockRadius);
        circle.setFill(Color.WHITE);
        circle.setStroke(Color.BLACK);
        Text t1 = new Text(centerX - 5, centerY - clockRadius + 12, ""12"");
        Text t2 = new Text(centerX - clockRadius + 3, centerY + 5, ""9"");
        Text t3 = new Text(centerX + clockRadius - 10, centerY + 3, ""3"");
        Text t4 = new Text(centerX - 3, centerY + clockRadius - 3, ""6"");
        double sLength = clockRadius * 0.8;
        double secondX = centerX + sLength *
                Math.sin(second * (2 * Math.PI / 60));
        double secondY = centerY - sLength *
                Math.cos(second * (2 * Math.PI / 60));
        Line sLine = new Line(centerX, centerY, secondX, secondY);
        sLine.setStroke(Color.RED);
        double mLength = clockRadius * 0.65;
        double xMinute = centerX + mLength *
                Math.sin(minute * (2 * Math.PI / 60));
        double minuteY = centerY - mLength *
                Math.cos(minute * (2 * Math.PI / 60));
        Line mLine = new Line(centerX, centerY, xMinute, minuteY);
        mLine.setStroke(Color.BLUE);

        double hLength = clockRadius * 0.5;
        double hourX = centerX + hLength *
                Math.sin((hour % 12 + minute / 60.0) * (2 * Math.PI / 12));
        double hourY = centerY - hLength *
                Math.cos((hour % 12 + minute / 60.0) * (2 * Math.PI / 12));
        Line hLine = new Line(centerX, centerY, hourX, hourY);
        hLine.setStroke(Color.GREEN);
        getChildren().clear();
        getChildren().addAll(circle, t1, t2, t3, t4, sLine, mLine, hLine);
    }
}","import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class TwoClocks extends Application {

    @Override
    public void start(Stage primaryStage) {
        // create two ClockPane objects with the specified time values
        ClockPane clock1 = new ClockPane(4, 20, 45);
        ClockPane clock2 = new ClockPane(22, 46, 15);

        // create an HBox to hold the two clocks side by side
        HBox hbox = new HBox(clock1, clock2);

        // create a scene and add the HBox to it
        Scene scene = new Scene(hbox, 600, 300);

        // set the title of the stage and show it
        primaryStage.setTitle(""Two Clocks"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class TwoClocksApp extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Create ClockPane for the first clock
        ClockPane clock1 = new ClockPane(4, 20, 45);

        // Create ClockPane for the second clock
        ClockPane clock2 = new ClockPane(22, 46, 15);

        // Create an HBox to hold the clocks
        HBox hbox = new HBox(20); // Add some spacing between clocks
        hbox.getChildren().addAll(clock1, clock2);

        // Create a scene and set it in the stage
        Scene scene = new Scene(hbox, 400, 200);

        // Set the stage title
        primaryStage.setTitle(""Two Clocks"");

        // Set the scene and show the stage
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static class ClockPane {
        // Some overly descriptive attributes
        private int hour;
        private int minute;
        private int second;

        // Constructor for the ClockPane
        public ClockPane(int hour, int minute, int second) {
            this.hour = hour;
            this.minute = minute;
            this.second = second;
            // More unnecessary comments
        }

        // Other clock-related methods...
    }
}",0.6683518705763397
0_Exercise14_10.java," /**
 * 14.10 (Display a cylinder) Write a program that draws a cylinder, as shown in
 * Figure 14.45b. You can use the following method to set the dashed stroke for an arc:
 * arc.getStrokeDashArray().addAll(6.0, 21.0);
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.Ellipse;
import javafx.scene.shape.Line;
import javafx.stage.Stage;


public class Exercise14_10 extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        Ellipse ellipse = new Ellipse(150, 60, 70, 25);
        ellipse.setStroke(Color.BLACK);
        ellipse.setFill(Color.WHITE);
        pane.getChildren().add(ellipse);

        Arc arc1 = new Arc(ellipse.getCenterX(), 200, ellipse.getRadiusX(),
                ellipse.getRadiusY(), 0, -180);
        arc1.setType(ArcType.OPEN);
        arc1.setFill(Color.WHITE);
        arc1.setStroke(Color.BLACK);
        pane.getChildren().add(arc1);

        Arc arc2 = new Arc(ellipse.getCenterX(), arc1.getCenterY(),
                ellipse.getRadiusX(), ellipse.getRadiusY(), 0, 180);
        arc2.setType(ArcType.OPEN);
        arc2.setFill(Color.WHITE);
        arc2.setStroke(Color.BLACK);
        arc2.getStrokeDashArray().addAll(6.0, 21.0);
        pane.getChildren().add(arc2);


        Line line1 = new Line(ellipse.getCenterX() - ellipse.getRadiusX(),
                ellipse.getCenterY(), ellipse.getCenterX() - ellipse.getRadiusX(),
                arc1.getCenterY());
        pane.getChildren().add(line1);

        Line line2 = new Line((ellipse.getCenterX() - ellipse.getRadiusX()) +
                ellipse.getRadiusX() * 2, ellipse.getCenterY(),
                (ellipse.getCenterX() - ellipse.getRadiusX())
                        + ellipse.getRadiusX() * 2, arc1.getCenterY());

        pane.getChildren().add(line2);

        Scene scene = new Scene(pane, 300, 250);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}
","import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.scene.shape.Shape;
import javafx.scene.shape.StrokeType;
import javafx.stage.Stage;

public class CylinderDrawing extends Application {
    @Override
    public void start(Stage primaryStage) {
        // create two arcs for the top and bottom of the cylinder
        Arc topArc = new Arc(150, 50, 100, 50, 0, 180);
        Arc bottomArc = new Arc(150, 200, 100, 50, 0, 180);

        // set the stroke type and width for the arcs
        topArc.setStrokeType(StrokeType.INSIDE);
        topArc.setStrokeWidth(5);
        bottomArc.setStrokeType(StrokeType.INSIDE);
        bottomArc.setStrokeWidth(5);

        // set the stroke color and fill color for the arcs
        topArc.setStroke(Color.BLACK);
        topArc.setFill(Color.WHITE);
        bottomArc.setStroke(Color.BLACK);
        bottomArc.setFill(Color.WHITE);

        // set the arc type to ROUND
        topArc.setType(ArcType.ROUND);
        bottomArc.setType(ArcType.ROUND);

        // add dashed stroke to the arcs
        topArc.getStrokeDashArray().addAll(6.0, 21.0);
        bottomArc.getStrokeDashArray().addAll(6.0, 21.0);

        // create a group to hold the arcs
        Group group = new Group(topArc, bottomArc);

        // create a scene and add the group to it
        Scene scene = new Scene(group, 300, 300);

        // set the title of the stage and show it
        primaryStage.setTitle(""Cylinder Drawing"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Arc;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

public class CylinderDisplay extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Create a pane to hold the cylinder
        Pane pane = new Pane();

        // Create the top ellipse of the cylinder
        Arc topEllipse = new Arc(100, 100, 60, 40, 0, 360);
        topEllipse.setFill(null);
        topEllipse.setStrokeWidth(2);
        topEllipse.setStrokeDashArray(6.0, 21.0); // Adding dashed stroke
        topEllipse.setStrokeLineCap(null);

        // Create the bottom ellipse of the cylinder
        Arc bottomEllipse = new Arc(100, 200, 60, 40, 0, 360);
        bottomEllipse.setFill(null);
        bottomEllipse.setStrokeWidth(2);
        bottomEllipse.setStrokeDashArray(6.0, 21.0); // Adding dashed stroke
        bottomEllipse.setStrokeLineCap(null);

        // Create the vertical lines connecting the ellipses
        Line leftLine = new Line(40, 100, 40, 200);
        Line rightLine = new Line(160, 100, 160, 200);

        // Add all shapes to the pane
        pane.getChildren().addAll(topEllipse, bottomEllipse, leftLine, rightLine);

        // Create a scene and set it in the stage
        Scene scene = new Scene(pane, 200, 300);

        // Set the stage title
        primaryStage.setTitle(""Cylinder Display"");

        // Set the scene and show the stage
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}",0.5638972305638972
0_Exercise14_06.java," /**
 * *14.6 (Game: display a checkerboard) Write a program that displays a checkerboard
 * in which each white and black cell is a Rectangle with a fill color black or
 * white, as shown in Figure 14.44c.
 */","package ch_14;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;


public class Exercise14_06 extends javafx.application.Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        GridPane gridPane = new GridPane();
        boolean colorCell = false;
        Rectangle[][] rectangles = new Rectangle[8][8];
        for (int r = 0; r < rectangles.length; r++) {
            for (int c = 0; c < rectangles[r].length; c++) {
                rectangles[r][c] = new Rectangle(25, 25);
                rectangles[r][c].setFill(colorCell ? Color.BLACK : Color.WHITE);
                colorCell = !colorCell;
            }
            colorCell = !colorCell;
        }
        for (int r = 0; r < rectangles.length; r++) {
            for (int c = 0; c < rectangles[r].length; c++) {
                gridPane.add(rectangles[r][c], c, r);

            }
        }
        Scene scene = new Scene(gridPane);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

}
","import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class Checkerboard extends Application {
    @Override
    public void start(Stage primaryStage) {
        // create a GridPane to hold the rectangles
        GridPane gridPane = new GridPane();

        // set the size of each rectangle
        int rectSize = 50;

        // create the rectangles and add them to the GridPane
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 8; j++) {
                Rectangle rect = new Rectangle(rectSize, rectSize);
                rect.setFill((i + j) % 2 == 0 ? Color.WHITE : Color.BLACK);
                gridPane.add(rect, j, i);
            }
        }

        // create a scene and add the GridPane to it
        Scene scene = new Scene(gridPane, rectSize * 8, rectSize * 8);

        // set the title of the stage and show it
        primaryStage.setTitle(""Checkerboard"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class CheckerboardDisplay extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        int rows = 8;
        int cols = 8;
        double cellSize = 40; // Size of each cell

        GridPane grid = new GridPane();

        // Create the checkerboard pattern
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                Rectangle cell = new Rectangle(cellSize, cellSize);

                // Set fill color based on row and column
                if ((row + col) % 2 == 0) {
                    cell.setFill(Color.WHITE);
                } else {
                    cell.setFill(Color.BLACK);
                }

                // Add cell to the grid
                grid.add(cell, col, row);
            }
        }

        // Create a scene and set it in the stage
        Scene scene = new Scene(grid, cellSize * cols, cellSize * rows);

        // Set the stage title
        primaryStage.setTitle(""Checkerboard Display"");

        // Set the scene and show the stage
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}",0.7067599067599067
0_Exercise14_07.java," /**
 * 14.7 (Display random 0 or 1) Write a program that displays a 10-by-10 square matrix,
 * as shown in Figure 14.45a. Each element in the matrix is 0 or 1, randomly generated.
 * Display each number centered in a text field. Use TextField’s setText
 * method to set value 0 or 1 as a string.
 */","package ch_14;

import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

import java.util.Random;


public class Exercise14_07 extends javafx.application.Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        GridPane gridPane = new GridPane();

        for (int r = 0; r < 10; r++) {
            for (int c = 0; c < 10; c++) {
                TextField textField = new TextField();
                textField.setText(String.valueOf(getRandomOneOrZero()));
                textField.setAlignment(Pos.CENTER);
                textField.setMaxWidth(30);
                gridPane.add(textField,c,r);
            }
        }

        Scene scene = new Scene(gridPane);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    static int getRandomOneOrZero() {
        return (int) (Math.random() * 2);
    }

}
","import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class RandomMatrix extends Application {

    @Override
    public void start(Stage primaryStage) {
        // create a GridPane to hold the TextFields
        GridPane gridPane = new GridPane();
        gridPane.setAlignment(Pos.CENTER);
        gridPane.setHgap(5);
        gridPane.setVgap(5);

        // generate random 0s and 1s and add them to the GridPane
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                int num = (int) (Math.random() * 2);
                TextField textField = new TextField(String.valueOf(num));
                textField.setPrefColumnCount(1);
                textField.setAlignment(Pos.CENTER);
                gridPane.add(textField, j, i);
            }
        }

        // create a scene and add the GridPane to it
        Scene scene = new Scene(gridPane, 300, 300);

        // set the title of the stage and show it
        primaryStage.setTitle(""Random Matrix"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

import java.util.Random;

public class RandomMatrixDisplay extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        int rows = 10;
        int cols = 10;

        GridPane grid = new GridPane();

        Random random = new Random();

        // Create a 10x10 matrix of random 0s and 1s
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int randomNumber = random.nextInt(2); // Generate random 0 or 1
                String value = String.valueOf(randomNumber);

                // Create a TextField to display the number
                TextField textField = new TextField(value);

                // Style the TextField
                textField.setPrefWidth(30);
                textField.setPrefHeight(30);
                textField.setEditable(false);
                textField.setStyle(""-fx-alignment: center;"");

                // Add the TextField to the grid
                grid.add(textField, col, row);
            }
        }

        // Create a scene and set it in the stage
        Scene scene = new Scene(grid, 300, 300);

        // Set the stage title
        primaryStage.setTitle(""Random Matrix Display"");

        // Set the scene and show the stage
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}",0.6458421274799493
0_Exercise14_11.java," /**
 * 14.11 (Paint a smiley face) Write a program that paints a smiley face, as shown in
 * Figure 14.46a
 */","package ch_14;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.*;
import javafx.stage.Stage;


public class Exercise14_11 extends Application {
    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        double faceRadius = 150;
        Pane pane = new Pane();

        /* Outline of face */
        Circle circle = new Circle(160, 160, faceRadius);
        double centerOfFaceX = circle.getCenterX();
        double centerOfFaceY = circle.getCenterY();
        circle.setFill(Color.WHITE);
        circle.setStroke(Color.BLACK);
        pane.getChildren().add(circle);

        /* Nose */
        Polygon triangle = new Polygon();
        triangle.getPoints().addAll(
                centerOfFaceX, centerOfFaceY + 30,
                centerOfFaceX - 30, centerOfFaceY - 30,
                centerOfFaceX + 30, centerOfFaceY - 30
        );
        triangle.setRotate(180);
        triangle.setFill(Color.WHITE);
        triangle.setStroke(Color.BLACK);
        pane.getChildren().add(triangle);

        /* Left Eye - Outline */
        Ellipse ellipse1 = new Ellipse(circle.getCenterX() - 60,circle.getCenterY()-60,circle.getRadius()/6,
                circle.getRadius()/5);
        ellipse1.setRotate(90);
        ellipse1.setFill(Color.TRANSPARENT);
        ellipse1.setStroke(Color.BLACK);
        pane.getChildren().add(ellipse1);
        /* Left Eye - Pupil */
        Circle circle1 = new Circle(16);
        circle1.setCenterX(ellipse1.getCenterX());
        circle1.setCenterY(ellipse1.getCenterY());
        pane.getChildren().add(circle1);

        /* Right Eye - Outline */
        Ellipse ellipse2 = new Ellipse(circle.getCenterX() + 60,circle.getCenterY()-60,circle.getRadius()/6,
                circle.getRadius()/5);
        ellipse2.setRotate(90);
        ellipse2.setFill(Color.TRANSPARENT);
        ellipse2.setStroke(Color.BLACK);
        pane.getChildren().add(ellipse2);
        /* Right Eye - Pupil */
        Circle circle2 = new Circle(16);
        circle2.setCenterX(ellipse2.getCenterX());
        circle2.setCenterY(ellipse2.getCenterY());
        pane.getChildren().add(circle2);

        /* Smile */
        Arc arc = new Arc(circle.getCenterX(), 200, circle.getRadius()-60,
                circle.getRadius()-100, 0, -180);
        arc.setType(ArcType.OPEN);
        arc.setFill(Color.WHITE);
        arc.setStroke(Color.BLACK);
        pane.getChildren().add(arc);

        Scene scene = new Scene(pane, 320, 320);
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();

    }
}
","import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class SmileyFace extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        // Create a canvas to draw on
        Canvas canvas = new Canvas(400, 400);
        GraphicsContext gc = canvas.getGraphicsContext2D();

        // Draw the smiley face
        gc.setFill(Color.YELLOW);
        gc.fillOval(100, 100, 200, 200);
        gc.setFill(Color.BLACK);
        gc.fillOval(150, 150, 25, 25);
        gc.fillOval(225, 150, 25, 25);
        gc.setFill(Color.RED);
        gc.fillOval(165, 200, 70, 70);

        // Create a scene and add the canvas to it
        Scene scene = new Scene(canvas);
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Arc;
import javafx.scene.shape.ArcType;
import javafx.stage.Stage;

public class SmileyFacePainter extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Create a pane to hold the smiley face
        Pane pane = new Pane();

        // Create the head (a yellow circle)
        Circle head = new Circle(150, 150, 100);
        head.setFill(Color.YELLOW);
        head.setStroke(Color.BLACK);

        // Create the left eye (a white circle)
        Circle leftEye = new Circle(120, 120, 20);
        leftEye.setFill(Color.WHITE);
        leftEye.setStroke(Color.BLACK);

        // Create the right eye (a white circle)
        Circle rightEye = new Circle(180, 120, 20);
        rightEye.setFill(Color.WHITE);
        rightEye.setStroke(Color.BLACK);

        // Create the smile (an arc)
        Arc smile = new Arc(150, 170, 60, 40, 0, 180);
        smile.setFill(Color.WHITE);
        smile.setStroke(Color.BLACK);
        smile.setType(ArcType.OPEN);

        // Add all the shapes to the pane
        pane.getChildren().addAll(head, leftEye, rightEye, smile);

        // Create the scene and set it in the stage
        Scene scene = new Scene(pane, 300, 300);

        // Set the stage title
        primaryStage.setTitle(""Smiley Face Painter"");

        // Set the scene and show the stage
        primaryStage.setScene(scene);
        primaryStage.show();
    }
}",0.5355612682090831
0_Exercise12_13.java," /**
 * 12.13 (Count characters, words, and lines in a file)
 * Write a program that will count the number of characters,
 * words, and lines in a file. Words are separated by whitespace characters.
 * The file name should be passed as a command-line argument, as shown in Figure 12.13.
 */","package ch_12;

import java.io.File;
import java.io.IOException;
import java.util.Scanner;



public class Exercise12_13 {
    public static void main(String[] args) throws IOException {

        File sourceFile = new File(args[0]);
        if (!sourceFile.exists()) {
            System.out.println(""Please check your file name and try again"");
            System.exit(1);
        }

        int numChars = 0, numWords = 0, numLines = 0;
        String temp = """";

        try (Scanner input = new Scanner(sourceFile);) {

            while (input.hasNext()) {

                temp = input.nextLine();
                numLines++;

                String[] tempArr = temp.split("" "");

                numWords += tempArr.length;

                for (int i = tempArr.length - 1; i >= 0; i--) {
                    numChars += tempArr[i].length();
                }
            }

        }

        System.out.println(""The file "" + sourceFile.getName() + "" has:"");
        System.out.println(numChars + "" Characters"");
        System.out.println(numWords + "" words"");
        System.out.println(numLines + "" lines"");

    }
}
","import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class FileCounter {

    public static void main(String[] args) {

        if (args.length != 1) {
            System.out.println(""Usage: java FileCounter <filename>"");
            return;
        }

        String filename = args[0];

        int charCount = 0;
        int wordCount = 0;
        int lineCount = 0;

        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                lineCount++;
                charCount += line.length();
                wordCount += line.split(""\\s+"").length;
            }
        } catch (IOException e) {
            System.out.println(""Error reading file: "" + filename);
            return;
        }

        System.out.println(""File: "" + filename);
        System.out.println(""Number of characters: "" + charCount);
        System.out.println(""Number of words: "" + wordCount);
        System.out.println(""Number of lines: "" + lineCount);
    }
}",1,"import java.io.*;

public class TextAnalyzer {

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java TextAnalyzer <filename>"");
        } else {
            String filename = args[0];
            processFile(filename);
        }
    }

    private static void processFile(String filename) {
        try {
            BufferedReader reader = new BufferedReader(new FileReader(filename));

            int charCount = 0;
            int wordCount = 0;
            int lineCount = 0;

            String line;
            while ((line = reader.readLine()) != null) {
                charCount += line.length();
                String[] words = line.split(""\\s+"");
                wordCount += words.length;
                lineCount++;
            }

            reader.close();

            displayResults(charCount, wordCount, lineCount);

        } catch (FileNotFoundException e) {
            System.out.println(""Error: File not found."");
        } catch (IOException e) {
            System.out.println(""Error reading the file."");
        }
    }

    private static void displayResults(int charCount, int wordCount, int lineCount) {
        System.out.println(""Character count: "" + charCount);
        System.out.println(""Word count: "" + wordCount);
        System.out.println(""Line count: "" + lineCount);
    }
}",0.6666666666666666
0_Exercise12_25.java," /**
 * *12.25 (Process large dataset) A university posts its employees’ salaries at http://
 * cs.armstrong.edu/liang/data/Salary.txt. Each line in the file consists of a faculty
 * member’s first name, last name, rank, and salary (see Programming Exercise
 * 12.24).
 * <p>
 * Write a program to display the total salary for assistant professors,
 * associate professors, full professors, and all faculty, respectively, and display
 * the average salary for assistant professors, associate professors, full professors,
 * and all faculty, respectively.
 */","package ch_12;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Objects;
import java.util.Scanner;


public class Exercise12_25 {
    private final static String ASSOCIATE = ""associate"";
    private final static String ASSISTANT = ""assistant"";
    private final static String FULL = ""full"";

    public static void main(String[] args) {
        double totalSalaryAssociate = 0, totalSalaryAssistant = 0, totalSalaryFull = 0;
        int countAssociate = 0, countAssistant = 0, countFull = 0;
        /*
         * The Salary.txt for this book no longer exists online. Using Salary.txt created in
         * Exercise12_24...
         */
        File file = new File(""src\\ch_12\\exercise12_24\\Salary.txt"");

        if (!file.exists()) {
            System.out.println(""Could not find the Salary.txt file to read from.."");
            System.exit(1);
        }

        try (Scanner in = new Scanner(file)) {
            while (in.hasNextLine()) {
                String[] employeeRecord = in.nextLine().split(""\\s+"");
                if (employeeRecord[2].equals(ASSISTANT)) {
                    countAssistant++;
                    totalSalaryAssistant += Double.parseDouble(employeeRecord[3]);

                } else if (employeeRecord[2].equals(ASSOCIATE)) {
                    countAssociate++;
                    totalSalaryAssociate += Double.parseDouble(employeeRecord[3]);

                } else if (employeeRecord[2].equals(FULL)) {
                    countFull++;
                    totalSalaryFull += Double.parseDouble(employeeRecord[3]);
                }
            }
            double totalSalaryAll = sum(totalSalaryAssistant, totalSalaryAssociate, totalSalaryFull);

            // Total salary
            System.out.printf(""Total salary for "" + ASSISTANT + "" professors is $%.2f"", totalSalaryAssistant);
            System.out.printf(""\nTotal salary for "" + ASSOCIATE + "" professors is $%.2f"", totalSalaryAssociate);
            System.out.printf(""\nTotal salary for "" + FULL + "" professors is $%.2f"", totalSalaryFull);
            System.out.printf(""\nTotal salary for ALL faculty is $%.2f"", totalSalaryAll);

            // Averages
            System.out.printf(""\nTotal average salary for "" + ASSISTANT + "" professors is $%.2f"", average(countAssistant
                    , totalSalaryAssistant));
            System.out.printf(""\nTotal average salary for "" + ASSOCIATE + "" professors is $%.2f"", average(countAssociate
                    , totalSalaryAssociate));
            System.out.printf(""\nTotal average salary for "" + FULL + "" professors is $%.2f"", average(countFull,
                    totalSalaryFull));

            System.out.printf(""\nTotal average for ALL professors is $%.2f"", average(sum(countAssistant, countAssociate,
                    countFull), totalSalaryAll));

        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(""Scanner couldn't read from the Salary.txt file..."");
        }

    }

    private static double average(int count, double total) {
        return total / count;
    }

    private static double sum(double totalSalaryAssistant, double totalSalaryAssociate, double totalSalaryFull) {
        return totalSalaryAssistant + totalSalaryAssociate + totalSalaryFull;
    }

    private static int sum(int c1, int c2, int c3) {
        return c1 + c2 + c3;
    }


}
","import java.io.IOException;
import java.net.URL;
import java.util.Scanner;

public class SalaryAnalyzer {

    public static void main(String[] args) throws IOException {

        URL url = new URL(""http://cs.armstrong.edu/liang/data/Salary.txt"");

        double totalAssistant = 0;
        double totalAssociate = 0;
        double totalFull = 0;
        double totalAll = 0;

        int countAssistant = 0;
        int countAssociate = 0;
        int countFull = 0;
        int countAll = 0;

        try (Scanner scanner = new Scanner(url.openStream())) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                String[] tokens = line.split(""\\s+"");
                String rank = tokens[2];
                double salary = Double.parseDouble(tokens[3]);
                switch (rank) {
                    case ""assistant"":
                        totalAssistant += salary;
                        countAssistant++;
                        break;
                    case ""associate"":
                        totalAssociate += salary;
                        countAssociate++;
                        break;
                    case ""full"":
                        totalFull += salary;
                        countFull++;
                        break;
                }
                totalAll += salary;
                countAll++;
            }
        }

        double averageAssistant = totalAssistant / countAssistant;
        double averageAssociate = totalAssociate / countAssociate;
        double averageFull = totalFull / countFull;
        double averageAll = totalAll / countAll;

        System.out.printf(""Assistant professors:\n"");
        System.out.printf(""Total salary: $%.2f\n"", totalAssistant);
        System.out.printf(""Average salary: $%.2f\n"", averageAssistant);
        System.out.printf(""Associate professors:\n"");
        System.out.printf(""Total salary: $%.2f\n"", totalAssociate);
        System.out.printf(""Average salary: $%.2f\n"", averageAssociate);
        System.out.printf(""Full professors:\n"");
        System.out.printf(""Total salary: $%.2f\n"", totalFull);
        System.out.printf(""Average salary: $%.2f\n"", averageFull);
        System.out.printf(""All faculty:\n"");
        System.out.printf(""Total salary: $%.2f\n"", totalAll);
        System.out.printf(""Average salary: $%.2f\n"", averageAll);
    }
}",1,"import java.io.*;
import java.net.URL;
import java.util.Scanner;

public class FacultySalaryAnalyzer {

    public static void main(String[] args) {
        try {
            URL url = new URL(""http://cs.armstrong.edu/liang/data/Salary.txt"");
            Scanner scanner = new Scanner(url.openStream());

            double totalAssistantSalary = 0;
            double totalAssociateSalary = 0;
            double totalFullSalary = 0;
            double totalFacultySalary = 0;

            int assistantCount = 0;
            int associateCount = 0;
            int fullCount = 0;
            int facultyCount = 0;

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                String[] tokens = line.split("" "");

                if (tokens.length == 4) {
                    String rank = tokens[2];
                    double salary = Double.parseDouble(tokens[3]);

                    if (""assistant"".equalsIgnoreCase(rank)) {
                        totalAssistantSalary += salary;
                        assistantCount++;
                    } else if (""associate"".equalsIgnoreCase(rank)) {
                        totalAssociateSalary += salary;
                        associateCount++;
                    } else if (""full"".equalsIgnoreCase(rank)) {
                        totalFullSalary += salary;
                        fullCount++;
                    }

                    totalFacultySalary += salary;
                    facultyCount++;
                }
            }

            printResults(""Assistant"", totalAssistantSalary, assistantCount);
            printResults(""Associate"", totalAssociateSalary, associateCount);
            printResults(""Full"", totalFullSalary, fullCount);
            printResults(""Faculty"", totalFacultySalary, facultyCount);

            scanner.close();

        } catch (IOException e) {
            System.out.println(""Error reading data from the URL."");
        }
    }

    private static void printResults(String rank, double totalSalary, int count) {
        System.out.println(""Total "" + rank + "" Salary: $"" + totalSalary);
        System.out.println(""Average "" + rank + "" Salary: $"" + (count != 0 ? totalSalary / count : 0));
        System.out.println();
    }
}",0.6397926864382378
0_Exercise12_23.java," /**
 * **12.23 (Process scores in a text file on the Web) Suppose that the text file on the
 * Web http://cs.armstrong.edu/liang/data/Scores.txt contains an unspecified number
 * of scores. Write a program that reads the scores from the file and displays their
 * total and average. Scores are separated by blanks.
 */","package ch_12;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Scanner;
import java.util.regex.Pattern;


public class Exercise12_23 {

    public static void main(String[] args) {
        double total = 0, average = 0;
        int count = 0;
        try {
//            URL url = new URL(""http://cs.armstrong.edu/liang/data/Scores.txt""); No longer online
            URL url = new URL(""https://git.savannah.gnu.org/cgit/datamash.git/plain/examples/scores.txt"");
            try (Scanner in = new Scanner(url.openStream())) {
                while (in.hasNext()) {
                    double score;
                    String nxtStr = in.next();
                    if (Character.isDigit(nxtStr.charAt(0))) {
                        score = Double.parseDouble(nxtStr);
                        count++;
                        total += score;
                    }
                }
                System.out.println(""The total is "" + total);
                average = total / count;
                System.out.printf(""The average score was %.2f%n"", average);

            } catch (IOException ioe) {
                ioe.printStackTrace();
            }


        } catch (MalformedURLException malformedURLException) {
            malformedURLException.printStackTrace();
        }

    }
}
","import java.io.*;
import java.net.*;

public class ScoreReader {
    public static void main(String[] args) {
        try {
            URL url = new URL(""http://cs.armstrong.edu/liang/data/Scores.txt"");
            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));

            String line;
            double sum = 0;
            int count = 0;

            while ((line = in.readLine()) != null) {
                String[] scores = line.split(""\\s+"");
                for (String score : scores) {
                    sum += Double.parseDouble(score);
                    count++;
                }
            }

            in.close();

            System.out.println(""Total: "" + sum);
            System.out.println(""Average: "" + sum / count);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}",1,"import java.io.*;
import java.net.URL;
import java.util.Scanner;

public class FacultySalaryAnalyzer {

    public static void main(String[] args) {
        try {
            URL url = new URL(""http://cs.armstrong.edu/liang/data/Salary.txt"");
            Scanner scanner = new Scanner(url.openStream());

            double totalAssistantSalary = 0;
            double totalAssociateSalary = 0;
            double totalFullSalary = 0;
            double totalFacultySalary = 0;

            int assistantCount = 0;
            int associateCount = 0;
            int fullCount = 0;
            int facultyCount = 0;

            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                String[] tokens = line.split("" "");

                if (tokens.length == 4) {
                    String rank = tokens[2];
                    double salary = Double.parseDouble(tokens[3]);

                    if (""assistant"".equalsIgnoreCase(rank)) {
                        totalAssistantSalary += salary;
                        assistantCount++;
                    } else if (""associate"".equalsIgnoreCase(rank)) {
                        totalAssociateSalary += salary;
                        associateCount++;
                    } else if (""full"".equalsIgnoreCase(rank)) {
                        totalFullSalary += salary;
                        fullCount++;
                    }

                    totalFacultySalary += salary;
                    facultyCount++;
                }
            }

            printResults(""Assistant"", totalAssistantSalary, assistantCount);
            printResults(""Associate"", totalAssociateSalary, associateCount);
            printResults(""Full"", totalFullSalary, fullCount);
            printResults(""Faculty"", totalFacultySalary, facultyCount);

            scanner.close();

        } catch (IOException e) {
            System.out.println(""Error reading data from the URL."");
        }
    }

    private static void printResults(String rank, double totalSalary, int count) {
        System.out.println(""Total "" + rank + "" Salary: $"" + totalSalary);
        System.out.println(""Average "" + rank + "" Salary: $"" + (count != 0 ? totalSalary / count : 0));
        System.out.println();
    }
}",0.4329718004338395
0_Exercise12_19.java," /**
 * 12.19 (Count words) Write a program that counts the number of words in President
 * Abraham Lincoln’s Gettysburg address from http://cs.armstrong.edu/liang/data/
 * Lincoln.txt. (Substituted http://se.cs.depaul.edu/Java/Chapter04/Lincoln.txt)
 */","package ch_12;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;


public class Exercise12_19 {

    public static void main(String[] args) {
        try {
            URL url = new URL(""http://se.cs.depaul.edu/Java/Chapter04/Lincoln.txt"");
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(url.openStream()));
            System.out.println(""Number of words in the Gettysburg Address is "" + countWords(bufferedReader));
        } catch (MalformedURLException malformedURLException) {
            malformedURLException.printStackTrace();
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }

    }

    static int countWords(BufferedReader br) throws IOException {
        int wordCount = 0;
        String line;
        while ((line = br.readLine()) != null) {
            String[] words = line.split(""\\s"");
            if (words.length == 0) continue;
            for (String word : words) {
                word = word.trim();
                if (word.length() > 0 && !word.equals("" "")) {
                    wordCount++;
//                    System.out.println(""Word: "" + word + "" Count = "" + wordCount);
                }
            }
        }
        return wordCount;
    }
}
","import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;

public class GettysburgAddressWordCounter {
    public static void main(String[] args) {
        String url = ""http://se.cs.depaul.edu/Java/Chapter04/Lincoln.txt"";
        int wordCount = 0;

        try {
            URL textUrl = new URL(url);
            BufferedReader in = new BufferedReader(new InputStreamReader(textUrl.openStream()));
            String line;
            while ((line = in.readLine()) != null) {
                String[] words = line.split(""\\s+"");
                wordCount += words.length;
            }
            in.close();
        } catch (IOException e) {
            System.out.println(""Error reading from URL: "" + e.getMessage());
        }

        System.out.println(""The Gettysburg address contains "" + wordCount + "" words."");
    }
}",1,"import java.io.*;
import java.net.URL;
import java.util.Scanner;

// Program to count the number of words in Lincoln's Gettysburg address
public class WordCounter {

    // Main method
    public static void main(String[] args) {
        try {
            // URL for Lincoln's Gettysburg address
            URL url = new URL(""http://se.cs.depaul.edu/Java/Chapter04/Lincoln.txt"");

            // Open a connection to the URL and create a Scanner for reading
            Scanner scanner = new Scanner(url.openStream());

            // Initialize word count variable
            int wordCount = 0;

            // Read the Gettysburg address line by line
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                
                // Split the line into words using a simple space-based approach
                String[] words = line.split("" "");

                // Count the words in the line
                wordCount += words.length;
            }

            // Close the scanner to free up resources
            scanner.close();

            // Print the final word count
            System.out.println(""The Gettysburg address contains approximately "" + wordCount + "" words."");

        } catch (IOException e) {
            // Handle the exception if there is an error reading from the URL
            System.out.println(""Error reading data from the URL."");
        }
    }
}",0.5297872340425532
0_Exercise12_03.java," /**
 * 12.3 (ArrayIndexOutOfBoundsException) Write a program that meets the following requirements:
 * Creates an array with 100 randomly chosen integers
 * Prompts the user to enter the index of the array, then displays the corresponding element value.
 * If the specified index is out of bounds, display the message Out of Bounds.
 */","package ch_12;

import java.util.Scanner;


public class Exercise12_03 {
    public static void main(String[] args) {

        int[] randomArray = new int[100];

        for (int i = 0; i < randomArray.length; i++) {
            randomArray[i] = (int) (1 + Math.random() * 10_000);
        }

        Scanner input = new Scanner(System.in);

        System.out.println(""Enter an index in the array for which to display it's value: "");

        try {
            int indexValue = input.nextInt();
            System.out.println(randomArray[indexValue]);

        } catch (ArrayIndexOutOfBoundsException ex) {
            System.out.println(""Out Of Bounds"");
        }

        input.close();
    }

}
","import java.util.Random;
import java.util.Scanner;

public class ArrayElement {
    public static void main(String[] args) {
        int[] arr = new int[100];
        Random random = new Random();

        for (int i = 0; i < arr.length; i++) {
            arr[i] = random.nextInt(1000);
        }

        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter an index to retrieve the corresponding element: "");
        int index = scanner.nextInt();

        if (index < 0 || index >= arr.length) {
            System.out.println(""Out of Bounds"");
        } else {
            System.out.println(""Element at index "" + index + "" is "" + arr[index]);
        }
    }
}",1,"import java.util.Scanner;
import java.util.Random;

public class ArrayElementReader {

    public static void main(String[] args) {
        // Declare and initialize an array with 100 randomly chosen integers
        int[] randomIntegers = new int[100];
        fillArrayWithRandomIntegers(randomIntegers);

        // Prompt the user to enter the index of the array
        System.out.println(""Enter the index of the array (0-99):"");

        // Create a Scanner to read user input
        Scanner scanner = new Scanner(System.in);

        // Get user input for the array index
        int index = getUserIndexInput(scanner);

        // Display the corresponding element value or handle out-of-bounds exception
        displayArrayElement(randomIntegers, index);

        // Close the scanner to free up resources
        scanner.close();
    }

    // Method to fill the array with 100 randomly chosen integers
    private static void fillArrayWithRandomIntegers(int[] array) {
        Random random = new Random();
        for (int i = 0; i < array.length; i++) {
            array[i] = random.nextInt(1000); // Filling with random integers between 0 and 999
        }
    }

    // Method to get user input for the array index
    private static int getUserIndexInput(Scanner scanner) {
        int index;
        while (true) {
            // Use try-catch to handle non-integer inputs
            try {
                System.out.print(""Enter an index (0-99): "");
                index = scanner.nextInt();
                break; // Exit the loop if input is valid
            } catch (Exception e) {
                System.out.println(""Invalid input. Please enter a valid integer."");
                scanner.nextLine(); // Consume the invalid input
            }
        }
        return index;
    }

    // Method to display the corresponding element value or handle out-of-bounds exception
    private static void displayArrayElement(int[] array, int index) {
        try {
            // Display the corresponding element value
            System.out.println(""The element value at index "" + index + "" is: "" + array[index]);
        } catch (ArrayIndexOutOfBoundsException e) {
            // Handle out-of-bounds exception
            System.out.println(""Out of Bounds. Please enter a valid index within the range (0-99)."");
        }
    }
}",0.3820662768031189
0_Exercise12_02.java," /**
 * 12.2 (InputMismatchException) Write a program that prompts the user to read
 * two integers and displays their sum. Your program should prompt the user to
 * read the number again if the input is incorrect.
 */","package ch_12;

import jdk.internal.util.xml.impl.Input;

import java.util.InputMismatchException;
import java.util.Scanner;


public class Exercise12_02 {
    public static void main(String[] args) {
        int i1, i2;
        boolean inputMismatch = false;

        Scanner in = new Scanner(System.in);

        do {
            System.out.print(""Enter two integers: "");

            try {
                i1 = in.nextInt();
                i2 = in.nextInt();

                System.out.print(""Sum = "" + (i1 + i2));
                inputMismatch = false;

            } catch (InputMismatchException ime) {
                inputMismatch = true;

                System.out.println(""Incorrect input type, please try again: "");
                in.nextLine();
            }
        } while (inputMismatch);

        in.close();
    }
}
","import java.util.Scanner;

public class IntegerSum {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num1, num2;

        do {
            System.out.print(""Enter the first integer: "");
            while (!scanner.hasNextInt()) {
                System.out.print(""Invalid input. Enter the first integer: "");
                scanner.next();
            }
            num1 = scanner.nextInt();

            System.out.print(""Enter the second integer: "");
            while (!scanner.hasNextInt()) {
                System.out.print(""Invalid input. Enter the second integer: "");
                scanner.next();
            }
            num2 = scanner.nextInt();
        } while (num1 < Integer.MIN_VALUE/2 || num1 > Integer.MAX_VALUE/2 || num2 < Integer.MIN_VALUE/2 || num2 > Integer.MAX_VALUE/2);

        int sum = num1 + num2;
        System.out.println(""The sum of "" + num1 + "" and "" + num2 + "" is "" + sum);
    }
}",1,"import java.util.Scanner;
import java.util.InputMismatchException;

public class SimpleAdditionProgram {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first integer
        System.out.println(""Enter the first integer:"");

        // Initialize variables to store user input
        int firstNumber = getUserInput(scanner);

        // Prompt the user to enter the second integer
        System.out.println(""Enter the second integer:"");

        // Initialize variables to store user input
        int secondNumber = getUserInput(scanner);

        // Display the sum of the two integers
        displaySum(firstNumber, secondNumber);

        // Close the scanner to free up resources
        scanner.close();
    }

    private static int getUserInput(Scanner scanner) {
        int number = 0;
        boolean inputValid = false;

        while (!inputValid) {
            try {
                // Get user input
                number = scanner.nextInt();
                inputValid = true;
            } catch (InputMismatchException e) {
                // Handle input mismatch exception
                System.out.println(""Invalid input. Please enter a valid integer."");
                scanner.nextLine(); // Consume the invalid input
            }
        }

        return number;
    }

    private static void displaySum(int num1, int num2) {
        int sum = num1 + num2;

        // Display the sum of the two integers
        System.out.println(""The sum of "" + num1 + "" and "" + num2 + "" is: "" + sum);
    }
}",0.53156146179402
0_Exercise12_28.java," /**
 * *12.28 (Rename files) Suppose you have a lot of files in a directory named Exercisei_j,
 * where i and j are digits. Write a program that pads a 0 before i if i is a single
 * digit. For example, a file named Exercise2_1 in a directory will be renamed to
 * Exercise02_1. In Java, when you pass the symbol * from the command line,
 * it refers to all files in the directory (see Supplement III.V). Use the following
 * command to run your program.
 *
 * To test:
 * rename files in ./testDir by removing the '0' padding in the suffix.
 * <p>
 * (From inside: java-prog-dan-lang-10th/src/ch_12/exercise12_28/ ) cmd: javac Exercise12_28.java
 * cmd: cd ../..
 * cmd: java ch_12.exercise12_28.Exercise12_28 *
 */","package ch_12.exercise12_28;


import java.io.File;
import java.io.IOException;
import java.nio.file.StandardCopyOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.regex.Pattern;


public class Exercise12_28 {

    private static final Pattern PATTERN = Pattern.compile(""Exercise\\d_\\d.*"");

    public static void main(String[] args) {

        if (args.length < 1) {
            System.out.println(""Usage: java Exercise12_28 *"");
            return;
        }
        if (!args[0].equals(""*"")) {
            System.out.println(""Usage: java Exercise12_28 *"");
            return;
        }

        File srcDirectory = new File(""./testDir"");
        if (!srcDirectory.isDirectory()) {
            System.out.println(""The directory path is not a directory: "" + srcDirectory.getAbsolutePath());
            return;
        }

        if (!Objects.isNull(srcDirectory.listFiles()) && srcDirectory.listFiles().length > 0) {
            ArrayList<File> files = new ArrayList<>(Arrays.asList(srcDirectory.listFiles()));
            for (File f : files) {
                String fileName = f.getName();
                StringBuffer stringBuffer = new StringBuffer(fileName);
                if (PATTERN.matcher(stringBuffer.toString()).matches()) {
                    stringBuffer.insert(fileName.lastIndexOf(""e"") + 1, ""0"");
                    System.out.println(""Renaming: "" + fileName + "" to "" + stringBuffer.toString());
                    Path srcPath = f.toPath();
                    Path trgtPath = Paths.get(srcDirectory.toPath().toString(), stringBuffer.toString());
                    try {
                        Files.move(srcPath, trgtPath, StandardCopyOption.REPLACE_EXISTING);
                        System.out.println(""Rename successful"");
                    } catch (IOException ioe) {
                        System.out.println(""Something went wrong while renaming the file... "" + fileName + ""\n\n"");
                        ioe.printStackTrace();
                    }

                }

            }
        } else {
            System.out.println(""The current directory is empty..."");
        }

    }
}
","import java.io.File;

public class FileRenamer {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println(""Usage: java FileRenamer <directory>"");
            System.exit(1);
        }

        File dir = new File(args[0]);
        if (!dir.isDirectory()) {
            System.out.println(args[0] + "" is not a directory."");
            System.exit(1);
        }

        String[] files = dir.list();
        String pattern = ""Exercise([1-9])_(\\d+)"";
        for (String fileName : files) {
            if (fileName.matches(pattern)) {
                String newFileName = fileName.replaceFirst(pattern, ""Exercise0$1_$2"");
                File oldFile = new File(dir, fileName);
                File newFile = new File(dir, newFileName);
                boolean renamed = oldFile.renameTo(newFile);
                if (renamed) {
                    System.out.println(""Renamed "" + fileName + "" to "" + newFileName);
                } else {
                    System.out.println(""Failed to rename "" + fileName);
                }
            }
        }
    }
}",1,"import java.io.File;

public class ExerciseRenamer {

    public static void main(String[] args) {
        // Check if the user provided the symbol '*' as a command-line argument
        if (args.length == 1 && args[0].equals(""*"")) {
            // Get the list of files in the current directory
            File currentDirectory = new File(""."");
            File[] files = currentDirectory.listFiles();

            // Iterate through each file in the directory
            for (File file : files) {
                // Check if the file is a directory
                if (file.isFile()) {
                    // Rename the file if it matches the Exercise pattern
                    if (file.getName().matches(""Exercise\\d_\\d.*"")) {
                        renameFile(file);
                    }
                }
            }

            System.out.println(""Files renamed successfully."");
        } else {
            System.out.println(""Usage: java ExerciseRenamer *"");
        }
    }

    // Method to rename the file by padding a '0' before a single-digit i
    private static void renameFile(File file) {
        String oldFileName = file.getName();
        String[] parts = oldFileName.split(""_"");

        // Check if i is a single digit
        if (parts.length == 2 && parts[1].length() == 1) {
            // Pad a '0' before i
            String newFileName = parts[0] + ""_0"" + parts[1];
            File newFile = new File(newFileName);

            // Rename the file
            if (file.renameTo(newFile)) {
                System.out.println(""File renamed: "" + oldFileName + "" -> "" + newFileName);
            } else {
                System.out.println(""Error renaming file: "" + oldFileName);
            }
        }
    }
}",0.5258818140174072
0_Exercise12_21.java," /**
 * 12.21 (Data sorted?) Write a program that reads the strings from file SortedStrings.txt
 * and reports whether the strings in the files are stored in increasing order.
 * If the strings are not sorted in the file, displays the first two strings that are out
 * of the order.
 */","package ch_12.exercise12_21;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;


public class Exercise12_21 {
    public static void main(String[] args) {
        String nextStr = """";
        String lastStr = """";
        int strCount = 0;
        try (BufferedReader bufferedReader =
                     new BufferedReader(new FileReader(""src\\ch_12\\exercise12_21\\SortedStrings.txt""))) {

            while ((nextStr = bufferedReader.readLine()) != null) {
                if (strCount++ == 0) {
                    lastStr = nextStr;
                    continue;
                }
                if (!isIncreasingOrder(lastStr, nextStr)) {
                    System.out.println(""The strings are not in increasing order..."");
                    System.out.println(""The first occurrence of two Strings out of order are "" + lastStr +
                            "" "" +
                            ""and "" + nextStr);
                    break;
                }

                lastStr = nextStr;
            }


        } catch (Exception e) {
            e.printStackTrace();
        }


    }

    static boolean isIncreasingOrder(String s1, String s2) {
        return s1.compareTo(s2) < 0;
    }

}
","import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class SortedStringsChecker {
    public static void main(String[] args) {
        String fileName = ""SortedStrings.txt"";
        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {
            String line;
            String previousLine = """";
            boolean sorted = true;
            while ((line = br.readLine()) != null) {
                if (line.compareTo(previousLine) < 0) {
                    sorted = false;
                    System.out.println(""File not sorted: "" + previousLine + "" "" + line);
                    break;
                }
                previousLine = line;
            }
            if (sorted) {
                System.out.println(""File sorted in increasing order"");
            }
        } catch (IOException e) {
            System.err.println(""Error reading file: "" + e.getMessage());
        }
    }
}",1,"import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class SortedStringsChecker {

    public static void main(String[] args) {
        // Open the file for reading
        File file = new File(""SortedStrings.txt"");

        try {
            // Create a Scanner to read from the file
            Scanner scanner = new Scanner(file);

            // Initialize variables
            boolean sorted = true;
            String prevString = null;
            String firstOutOfOrder1 = null;
            String firstOutOfOrder2 = null;

            // Read each string from the file
            while (scanner.hasNext()) {
                String currentString = scanner.next();

                // Check if the strings are in increasing order
                if (prevString != null && currentString.compareTo(prevString) < 0) {
                    sorted = false;
                    firstOutOfOrder1 = prevString;
                    firstOutOfOrder2 = currentString;
                    break; // Exit the loop if out of order strings are found
                }

                // Update the previous string for the next iteration
                prevString = currentString;
            }

            // Close the scanner to free up resources
            scanner.close();

            // Display the result
            if (sorted) {
                System.out.println(""The strings in the file are sorted in increasing order."");
            } else {
                System.out.println(""The strings in the file are not sorted."");
                System.out.println(""First out-of-order strings: "" + firstOutOfOrder1 + "", "" + firstOutOfOrder2);
            }

        } catch (FileNotFoundException e) {
            // Handle file not found exception
            System.out.println(""Error: File 'SortedStrings.txt' not found."");
        }
    }
}",0.5016256386437529
0_Exercise12_27.java," /**
 * *12.27 (Replace words) Suppose you have a lot of files in a directory that contain
 * words Exercisei_j, where i and j are digits. Write a program that pads a 0
 * before i if i is a single digit and 0 before j if j is a single digit.
 * <p>
 * For example,
 * the word Exercise2_1 in a file will be replaced by Exercise02_01. In Java,
 * when you pass the symbol * from the command line, it refers to all files in
 * the directory (see Supplement III.V). Use the following command to run your
 * program.
 * <p>
 * To test:
 * for files in /exercise12_27 , open and rename strings by removing the '0' padding in the suffix.
 * <p>
 * (From inside: java-prog-dan-lang-10th/src/ch_12/exercise12_27/ ) cmd: javac Exercise12_27.java
 * cmd: cd ../..
 * cmd: java ch_12.exercise12_27.Exercise12_27 *
 *
 */","package ch_12.exercise12_27;


import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


public class Exercise12_27 {
    private static final Pattern PATTERN = Pattern.compile(""Exercise\\d_\\d"");
    private static final String PREFIX = ""Exercise"";
    private static Logger logger = LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME);

    public static void main(String[] args) {

        if (args.length < 1) {
            System.out.println(""Usage: java Exercise12_27 *"");
            return;
        }
        if (!args[0].equals(""*"")) {
            System.out.println(""Usage: java Exercise12_27 *"");
            return;
        }

        File file = new File(""."");
        if (file.list().length > 0) {
            ArrayList<File> files = new ArrayList<>(Arrays.asList(file.listFiles()));
            for (File f : files) {
                if (!f.getName().equalsIgnoreCase(""Exercise12_27.java"")) {
                    ArrayList<String> lines = new ArrayList<>();
                    try (Scanner fileIn = new Scanner(f)) {
                        while (fileIn.hasNextLine()) {
                            lines.add(fileIn.nextLine().trim());
                        }
                        lines = handleRename(lines);

                    } catch (IOException ioException) {
                        ioException.printStackTrace();
                    }

                    try (PrintWriter printWriter = new PrintWriter(f)) {
                        for (String line : lines) {
                            printWriter.println(line);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                }

            }
        } else {
            System.out.println(""The current directory is empty."");
        }

    }

    private static ArrayList<String> handleRename(ArrayList<String> lines) {
        ArrayList<String> nuList = new ArrayList<>();
        for (String line : lines) {
            if (PATTERN.matcher(line).matches()) { // PATTERN = Pattern.compile(""Exercise\\d_\\d"");
                /* Use StringBuffer to handle shorter strings */
                StringBuffer stringBuffer = new StringBuffer(line.substring(line.lastIndexOf('e') + 1));
                stringBuffer.insert(0, 0);// pad first number with a ""0""
                stringBuffer.insert(stringBuffer.length() - 1, 0); // pad last number with ""0""
                nuList.add(PREFIX + stringBuffer.toString());
                logger.log(Level.INFO, PREFIX + stringBuffer.toString());
            } else {
                nuList.add(line);
            }

        }
        return nuList;
    }
}
","import java.io.File;

public class FileRenamer {
    public static void main(String[] args) {
        String directoryPath = ""/path/to/directory/""; // Replace with the path to your directory
        File directory = new File(directoryPath);
        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isFile() && file.getName().matches(""Exercise\\d_\\d"")) {
                String oldName = file.getName();
                String[] parts = oldName.split(""_"");
                String newName = String.format(""Exercise%02d_%02d"", Integer.parseInt(parts[0].substring(8)), Integer.parseInt(parts[1]));
                File newFile = new File(directoryPath + newName);
                if (file.renameTo(newFile)) {
                    System.out.println(""Renamed "" + oldName + "" to "" + newName);
                } else {
                    System.err.println(""Error renaming "" + oldName);
                }
            }
        }
    }
}",1,"import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Scanner;

public class WordReplacer {

    public static void main(String[] args) {
        // Check if the user provided the symbol '*' as a command-line argument
        if (args.length == 1 && args[0].equals(""*"")) {
            // Get the list of files in the current directory
            File currentDirectory = new File(""."");
            File[] files = currentDirectory.listFiles();

            // Iterate through each file in the directory
            for (File file : files) {
                // Check if the file is a directory
                if (file.isFile()) {
                    // Replace words in the file if it matches the Exercise pattern
                    if (file.getName().matches(""Exercise\\d_\\d.*"")) {
                        replaceWords(file);
                    }
                }
            }

            System.out.println(""Words replaced successfully."");
        } else {
            System.out.println(""Usage: java WordReplacer *"");
        }
    }

    // Method to replace words by padding '0' before i and j if they are single digits
    private static void replaceWords(File file) {
        try {
            // Create a Scanner to read from the file
            Scanner scanner = new Scanner(file);

            // Create a PrintWriter to write to a temporary file
            PrintWriter writer = new PrintWriter(""tempFile.txt"");

            // Read each line from the file
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();

                // Replace words in the line
                String modifiedLine = line.replaceAll(""Exercise(\\d)_(\\d)"", ""Exercise0$1_0$2"");

                // Write the modified line to the temporary file
                writer.println(modifiedLine);
            }

            // Close the scanner and writer to free up resources
            scanner.close();
            writer.close();

            // Rename the temporary file to the original file
            File tempFile = new File(""tempFile.txt"");
            if (tempFile.renameTo(file)) {
                System.out.println(""Words replaced in file: "" + file.getName());
            } else {
                System.out.println(""Error replacing words in file: "" + file.getName());
            }

        } catch (FileNotFoundException e) {
            // Handle file not found exception
            System.out.println(""Error: File '"" + file.getName() + ""' not found."");
        }
    }
}",0.420824295010846
0_Exercise12_18.java," /**
 * *12.18 (Add package statement) Suppose you have Java source files under the directories chapter1, chapter2, . . . , chapter34.
 * Write a program to insert the statement package chapteri; as the first line for each Java source file under
 * the directory chapteri. Suppose chapter1, chapter2, . . . , chapter34
 * are under the root directory srcRootDirectory. The root directory and
 * chapteri directory may contain other folders and files. Use the following
 * command to run the program:
 * java Exercise12_18 srcRootDirectory
 *
 * @implNote  package statements may already be written in testFile*.java files.
 * Remove the package statement to start over
 * test this class. Hint: Use Exercise12_20.java to remove package statements.
 */","package ch_12.exercise12_18;

import java.io.*;
import java.nio.file.*;
import java.util.ArrayList;
import java.util.List;


public class Exercise12_18 {
    private final static String USAGE = ""java Exercise12_18 srcRootDirectory"";
    private static final String SUB_DIR_PATTERN = ""chapter*"";
    private static final String SRC_FILE_PATTERN = ""*.java"";
    private static final String RESOLVE_PACKAGE_PATH = ""src\\ch_12\\exercise12_18\\"";

    public static void main(String[] args) {
        if (args == null || args.length != 1) {
            System.out.println(""Usage: "" + USAGE);
            System.exit(1);
        }

        List<Path> parentFiles = new ArrayList<>();

        Path parentPath = Paths.get(RESOLVE_PACKAGE_PATH, args[0]);
        if (!parentPath.toFile().exists()) {
            System.out.println(""Error: Please enter the full filepath to your srcRootDirectory. The current "" +
                    ""directory is "" + new File("""").getAbsolutePath());
            System.exit(2);
        } else {
            System.out.println(""Path is resolved: "" + parentPath.toAbsolutePath());
        }


        try (DirectoryStream<Path> parentDirStream = Files.newDirectoryStream(parentPath, SUB_DIR_PATTERN)) {
            for (Path subPath : parentDirStream) {
                parentFiles.add(subPath);
            }

        } catch (
                IOException dirIterException) {
            System.out.println(""The srcRootDirectory is empty or cannot be read because of system security settings."");
//            dirIterException.printStackTrace();

        }

        for (Path subPath : parentFiles) {
            System.out.println(""Handling package reference writing for: "" + subPath);
            handlePackage(subPath);
        }

    }

    private static void handlePackage(Path path) {
        String pkg = path.getName(path.getNameCount() - 1).toString();
        System.out.println(""Iterating current package: "" + pkg);

        try (DirectoryStream<Path> subDirStream = Files.newDirectoryStream(path, SRC_FILE_PATTERN)) {
            for (Path targetFilePath : subDirStream) {
                File targetFile = targetFilePath.toFile();
                ArrayList<String> fileContents = new ArrayList<>();

                FileReader reader = new FileReader(targetFile);
                BufferedReader bufferedReader = new BufferedReader(reader);

                String line;
                while ((line = bufferedReader.readLine()) != null) {
                    fileContents.add(line);
                }
                bufferedReader.close();

                String insertStatement = ""package "" + pkg + "";"";
                fileContents.add(0, insertStatement);

                PrintWriter fileWriter = new PrintWriter(targetFile);
                for (String singleLine : fileContents) {
                    fileWriter.println(singleLine);
                }
                fileWriter.close();
            }
        } catch (IOException ex) {
            System.out.println(""An error occurred while handling the source files in "" + pkg);
        }

    }
}
","import java.io.*;

public class PackageInserter {
    public static void main(String[] args) {
        String srcRootDirectory = ""/path/to/srcRootDirectory/""; // Replace with the path to your root directory
        for (int i = 1; i <= 34; i++) {
            String chapterDirectory = srcRootDirectory + ""chapter"" + i + ""/"";
            File[] files = new File(chapterDirectory).listFiles();
            for (File file : files) {
                if (file.isFile() && file.getName().endsWith("".java"")) {
                    try {
                        BufferedReader reader = new BufferedReader(new FileReader(file));
                        StringBuilder stringBuilder = new StringBuilder();
                        String line = reader.readLine();
                        stringBuilder.append(""package chapter"" + i + "";\n"");
                        while (line != null) {
                            stringBuilder.append(line + ""\n"");
                            line = reader.readLine();
                        }
                        reader.close();
                        FileWriter writer = new FileWriter(file);
                        writer.write(stringBuilder.toString());
                        writer.close();
                        System.out.println(""Inserted package statement in "" + file.getName());
                    } catch (IOException e) {
                        System.err.println(""Error processing "" + file.getName() + "": "" + e.getMessage());
                    }
                }
            }
        }
    }
}",1,"import java.io.*;
import java.util.Scanner;

public class PackageInserter {

    public static void main(String[] args) {
        // Check if the user provided the root directory as a command-line argument
        if (args.length == 1) {
            String rootDirectoryPath = args[0];
            File rootDirectory = new File(rootDirectoryPath);

            // Check if the provided path is a directory
            if (rootDirectory.isDirectory()) {
                insertPackageStatements(rootDirectory);
                System.out.println(""Package statements inserted successfully."");
            } else {
                System.out.println(""Error: The provided path is not a directory."");
            }
        } else {
            System.out.println(""Usage: java PackageInserter <srcRootDirectory>"");
        }
    }

    // Method to insert package statements in Java source files
    private static void insertPackageStatements(File directory) {
        // Get the list of files in the directory
        File[] files = directory.listFiles();

        // Iterate through each file in the directory
        for (File file : files) {
            // Check if the file is a directory
            if (file.isDirectory()) {
                // Recursively insert package statements in subdirectories
                insertPackageStatements(file);
            } else if (file.getName().endsWith("".java"")) {
                // Insert package statement in Java source file
                insertPackageStatement(file);
            }
        }
    }

    // Method to insert package statement in a Java source file
    private static void insertPackageStatement(File file) {
        try {
            // Read the contents of the file
            StringBuilder fileContent = new StringBuilder();
            Scanner scanner = new Scanner(file);

            while (scanner.hasNextLine()) {
                fileContent.append(scanner.nextLine()).append(""\n"");
            }

            // Close the scanner
            scanner.close();

            // Insert the package statement as the first line
            String packageName = file.getParentFile().getName();
            String packageStatement = ""package "" + packageName + "";"";
            fileContent.insert(0, packageStatement + ""\n"");

            // Write the modified content back to the file
            PrintWriter writer = new PrintWriter(file);
            writer.write(fileContent.toString());
            writer.close();

        } catch (IOException e) {
            // Handle IOException
            System.out.println(""Error processing file: "" + file.getName());
        }
    }
}",0.4652777777777778
0_Exercise12_16.java," /**
 * *12.16 (Replace text) Listing 12.16, ReplaceText.java, gives a program that replaces
 * text in a source file and saves the change into a new file.
 * Revise the program to save the change into the original file.
 * <p>
 * For example, invoking
 * java Exercise12_16 file oldString newString
 * replaces oldString in the source file with newString
 */","package ch_12.exercise12_16;//package ch_12.exercise12_16;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;



public class Exercise12_16 {
    private static ArrayList<String> strHelper = new ArrayList<>();
//    private static String filePath = ""src"" + File.separator + ""ch_12"" + File.separator + ""exercise12_16"" + File.separator;

    public static void main(String[] args) {
        if (args.length < 3) {
            System.out.println(
                    ""Run: java Exercise12_16 fileName oldString newString"");
            System.out.println(args.length);
            System.exit(1);
        }
        File sourceFile = new File(args[0]);
        if (!sourceFile.exists()) {
            System.out.println(""Source file "" + args[0] + "" does not exist"");
            System.exit(2);
        }

        try (Scanner input = new Scanner(sourceFile)) {
            while (input.hasNext()) {
                String s1 = input.nextLine();
                String s2 = s1.replaceAll(args[1], args[2]);

                strHelper.add(s2);

            }
        } catch (FileNotFoundException fileNotFoundException) {
            fileNotFoundException.printStackTrace();
        }

        try (PrintWriter output = new PrintWriter(sourceFile)) {
            for (int i = 0; i < strHelper.size(); i++) {
                output.println(strHelper.remove(i));
            }
        } catch (FileNotFoundException fileNotFoundException) {
            fileNotFoundException.printStackTrace();
        }

    }
}","import java.io.*;

public class ReplaceText {
    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println(""Usage: java ReplaceText sourceFile oldStr newStr"");
            System.exit(1);
        }

        String sourceFile = args[0];
        String oldStr = args[1];
        String newStr = args[2];

        try {
            BufferedReader reader = new BufferedReader(new FileReader(sourceFile));
            StringBuilder stringBuilder = new StringBuilder();
            String line = reader.readLine();
            while (line != null) {
                stringBuilder.append(line.replaceAll(oldStr, newStr) + ""\n"");
                line = reader.readLine();
            }
            reader.close();
            FileWriter writer = new FileWriter(sourceFile);
            writer.write(stringBuilder.toString());
            writer.close();
            System.out.println(""Text replaced in "" + sourceFile);
        } catch (IOException e) {
            System.err.println(""Error processing "" + sourceFile + "": "" + e.getMessage());
        }
    }
}",2,"import java.io.*;

public class TextReplacer {

    public static void main(String[] args) {
        // Check if the correct number of command-line arguments are provided
        if (args.length != 3) {
            System.out.println(""Usage: java TextReplacer <filename> <oldString> <newString>"");
            return;
        }

        // Get command-line arguments
        String filename = args[0];
        String oldString = args[1];
        String newString = args[2];

        // Read the file and replace the text
        replaceTextInFile(filename, oldString, newString);

        System.out.println(""Text replaced successfully in the file."");
    }

    // Method to replace text in a file and save changes in the original file
    private static void replaceTextInFile(String filename, String oldString, String newString) {
        try {
            // Read the content of the file
            StringBuilder fileContent = new StringBuilder();
            BufferedReader reader = new BufferedReader(new FileReader(filename));

            String line;
            while ((line = reader.readLine()) != null) {
                fileContent.append(line).append(""\n"");
            }

            // Close the reader
            reader.close();

            // Replace the old string with the new string
            String updatedContent = fileContent.toString().replace(oldString, newString);

            // Write the updated content back to the original file
            BufferedWriter writer = new BufferedWriter(new FileWriter(filename));
            writer.write(updatedContent);

            // Close the writer
            writer.close();

        } catch (IOException e) {
            // Handle IOException
            System.out.println(""Error processing file: "" + filename);
        }
    }
}",0.5433575395130287
0_Exercise12_29.java," /**
 * **12.29 (Rename files) Suppose you have a lot of files in a directory named Exercisei_j,
 * where i and j are digits. Write a program that pads a 0 before j if j is a single
 * digit. For example, a file named Exercise2_1 in a directory will be renamed to
 * Exercise2_01. In Java, when you pass the symbol * from the command line,
 * it refers to all files in the directory (see Supplement III.V). Use the following
 * command to run your program.
 * To test:
 * rename files in ./testDir by removing the '0' padding in the suffix for j.
 * <p>
 * (From inside: java-prog-dan-lang-10th/src/ch_12/exercise12_29/ ) cmd: javac Exercise12_29.java
 * cmd: cd ../..
 * cmd: java ch_12.exercise12_29.Exercise12_29 *
 */","package ch_12.exercise12_29;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import java.util.regex.Pattern;


public class Exercise12_29 {
    private static final Pattern PATTERN = Pattern.compile(""Exercise\\d{1,2}_\\d.*""); //

    public static void main(String[] args) {

        if (args.length < 1) {
            System.out.println(""Usage: java Exercise12_29 *"");
            return;
        }
        if (!args[0].equals(""*"")) {
            System.out.println(""Usage: java Exercise12_29 *"");
            return;
        }

        File srcDirectory = new File(""./testDir"");
        if (!srcDirectory.isDirectory()) {
            System.out.println(""The directory path is not a directory: "" + srcDirectory.getAbsolutePath());
            return;
        }

        if (!Objects.isNull(srcDirectory.listFiles()) && srcDirectory.listFiles().length > 0) {
            ArrayList<File> files = new ArrayList<>(Arrays.asList(srcDirectory.listFiles()));
            for (File f : files) {
                String fileName = f.getName();
                StringBuffer stringBuffer = new StringBuffer(fileName);
                if (PATTERN.matcher(stringBuffer.toString()).matches()) {
                    stringBuffer.insert(fileName.lastIndexOf(""_"") + 1, ""0"");
                    System.out.println(""Renaming: "" + fileName + "" to "" + stringBuffer.toString());
                    Path srcPath = f.toPath();
                    Path trgtPath = Paths.get(srcDirectory.toPath().toString(), stringBuffer.toString());
                    try {
                        Files.move(srcPath, trgtPath, StandardCopyOption.REPLACE_EXISTING);
                        System.out.println(""Rename successful"");
                    } catch (IOException ioe) {
                        System.out.println(""Something went wrong while renaming the file... "" + fileName + ""\n\n"");
                        ioe.printStackTrace();
                    }

                }

            }
        } else {
            System.out.println(""The current directory is empty..."");
        }

    }
}
","import java.io.*;

public class RenameFiles {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java RenameFiles directory"");
            System.exit(1);
        }

        File directory = new File(args[0]);
        if (!directory.isDirectory()) {
            System.out.println(args[0] + "" is not a directory"");
            System.exit(1);
        }

        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isFile() && file.getName().matches(""Exercise\\d_\\d\\.txt"")) {
                String filename = file.getName();
                String[] parts = filename.split(""_"");
                String newFilename = parts[0] + ""_"" + String.format(""%02d"", Integer.parseInt(parts[1].split(""\\."")[0])) + "".txt"";
                File newFile = new File(directory, newFilename);
                if (file.renameTo(newFile)) {
                    System.out.println(""Renamed "" + filename + "" to "" + newFilename);
                } else {
                    System.err.println(""Error renaming "" + filename);
                }
            }
        }
    }
}",2,"import java.io.File;

public class ExerciseFileRenamer {

    public static void main(String[] args) {
        // Check if the user provided the symbol '*' as a command-line argument
        if (args.length == 1 && args[0].equals(""*"")) {
            // Get the list of files in the current directory
            File currentDirectory = new File(""."");
            File[] files = currentDirectory.listFiles();

            // Iterate through each file in the directory
            for (File file : files) {
                // Check if the file is a directory
                if (file.isFile()) {
                    // Rename files in the directory if they match the Exercise pattern
                    if (file.getName().matches(""Exercise\\d+_\\d.*"")) {
                        renameFile(file);
                    }
                }
            }

            System.out.println(""Files renamed successfully."");
        } else {
            System.out.println(""Usage: java ExerciseFileRenamer *"");
        }
    }

    // Method to rename files by padding '0' before j if it is a single digit
    private static void renameFile(File file) {
        String oldFileName = file.getName();
        String[] parts = oldFileName.split(""_"");

        // Check if j is a single digit
        if (parts.length == 2 && parts[1].length() == 1) {
            // Pad a '0' before j
            String newFileName = parts[0] + ""_0"" + parts[1];
            File newFile = new File(newFileName);

            // Rename the file
            if (file.renameTo(newFile)) {
                System.out.println(""File renamed: "" + oldFileName + "" -> "" + newFileName);
            } else {
                System.out.println(""Error renaming file: "" + oldFileName);
            }
        }
    }
}",0.55324790101635
0_Triangle.java," /**
     * Construct a triangle with the specified sides
     */","package ch_12.exercise12_05;

import ch_11.exercise11_01.GeometricObject;

public class Triangle extends GeometricObject {

    private double side1;
    private double side2;
    private double side3;


    public Triangle() {

        this.side1 = 1.0;
        this.side2 = 1.0;
        this.side3 = 1.0;

    }

    
    public Triangle(double side1, double side2, double side3) throws IllegalTriangleException {
        setSides(side1, side2, side3);
    }

    public double getArea() {
        double s = (this.side1 + this.side2 + this.side3) / 2;
        return Math.sqrt(s * (s - this.side1) * (s - this.side2) * (s - this.side3));
    }

    public double getPerimeter() {

        double p = this.side1 + this.side2 + this.side3;

        return p;

    }

    private void setSides(double side1, double side2, double side3) throws IllegalTriangleException {
        if (side1 + side2 < side3) {
            throw new IllegalTriangleException(side1, side2, side3);
        } else if (side2 + side3 < side1) {
            throw new IllegalTriangleException(side1, side2, side3);
        } else if (side1 + side3 < side2) {
            throw new IllegalTriangleException(side1, side2, side3);
        } else {
            this.side1 = side1;
            this.side2 = side2;
            this.side3 = side3;

        }

    }

    public double getSide1() {
        return side1;
    }

    public double getSide2() {
        return side2;
    }

    public double getSide3() {
        return side3;
    }

    @Override
    public String toString() {
        return ""Triangle: side1 = "" + this.side1 + "" side2 = "" + this.side2 +
                "" side3 = "" + this.side3;
    }
}

","import java.util.Scanner;

public class TriangleConstructor {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the length of side 1: "");
        double side1 = input.nextDouble();
        System.out.print(""Enter the length of side 2: "");
        double side2 = input.nextDouble();
        System.out.print(""Enter the length of side 3: "");
        double side3 = input.nextDouble();
        
        if (isValidTriangle(side1, side2, side3)) {
            double perimeter = side1 + side2 + side3;
            double semiPerimeter = perimeter / 2;
            double area = Math.sqrt(semiPerimeter * (semiPerimeter - side1) * (semiPerimeter - side2) * (semiPerimeter - side3));
            System.out.printf(""Perimeter: %.2f%n"", perimeter);
            System.out.printf(""Area: %.2f%n"", area);
            System.out.println(""The triangle is valid."");
        } else {
            System.out.println(""The sides entered do not form a valid triangle."");
        }
    }
    
    public static boolean isValidTriangle(double side1, double side2, double side3) {
        return side1 + side2 > side3 && side2 + side3 > side1 && side1 + side3 > side2;
    }
}
",2,"import java.util.Scanner;

public class TriangleConstructor {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get user input for triangle sides
        System.out.println(""Enter the length of side A:"");
        double sideA = scanner.nextDouble();

        System.out.println(""Enter the length of side B:"");
        double sideB = scanner.nextDouble();

        System.out.println(""Enter the length of side C:"");
        double sideC = scanner.nextDouble();

        // Check if the sides can form a triangle
        if (isValidTriangle(sideA, sideB, sideC)) {
            // Construct the triangle
            System.out.println(""Triangle constructed successfully!"");
        } else {
            System.out.println(""Invalid sides. Cannot construct a triangle."");
        }

        scanner.close();
    }

    // Method to check if the sides can form a triangle
    private static boolean isValidTriangle(double a, double b, double c) {
        return (a + b > c) && (a + c > b) && (b + c > a);
    }
}",0.6713995943204868
0_Exercise12_05.java," /**
 * *12.5 (IllegalTriangleException) Programming Exercise 11.1 defined the
 * Triangle class with three sides. In a triangle, the sum of any two sides is
 * greater than the other side. The Triangle class must adhere to this rule.
 * <p>
 * Create the IllegalTriangleException class, and modify the constructor
 * of the Triangle class to throw an IllegalTriangleException object if a
 * triangle is created with sides that violate the rule, as follows:
 * <p>
 * {@code /* Construct a triangle with the specified sides
 * public Triangle(double side1,double side2,double side3)
 * throws IllegalTriangleException {
 * // Implement it
 * }}
 */","package ch_12.exercise12_05;



public class Exercise12_05 {
    public static void main(String[] args) {
        System.out.println(""Test new Triangle with non-compliant values:"");
        try {
            Triangle triangle = new Triangle(1.0, 0.1, 0.2);
            System.out.println(""The Triangle's area is "" + triangle.getArea());
        } catch (IllegalTriangleException e) {
            System.out.println(e);
        }
        System.out.println(""Test new Triangle with compliant values:"");
        try {
            Triangle triangle = new Triangle(1.0, 1.0, 1.0);
            System.out.println(""The Triangle's area is "" + triangle.getArea());
        } catch (IllegalTriangleException e) {
            System.out.println(e);
        }

    }


}
","public class Triangle {
    private double side1, side2, side3;

    public Triangle(double side1, double side2, double side3) throws IllegalTriangleException {
        if (side1 + side2 <= side3 || side1 + side3 <= side2 || side2 + side3 <= side1) {
            throw new IllegalTriangleException(""Invalid triangle sides"");
        }
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }

    public double getSide1() {
        return side1;
    }

    public double getSide2() {
        return side2;
    }

    public double getSide3() {
        return side3;
    }

    public double getArea() {
        double s = (side1 + side2 + side3) / 2.0;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    public double getPerimeter() {
        return side1 + side2 + side3;
    }

    @Override
    public String toString() {
        return ""Triangle: side1 = "" + side1 + "" side2 = "" + side2 + "" side3 = "" + side3;
    }
}  public class IllegalTriangleException extends Exception {
    public IllegalTriangleException(String message) {
        super(message);
    }
}
",2,"public class Triangle {

    private double side1;
    private double side2;
    private double side3;

    public Triangle(double side1, double side2, double side3) throws IllegalTriangleException {
        // Ensure sides are non-negative
        if (side1 <= 0 || side2 <= 0 || side3 <= 0) {
            throw new IllegalTriangleException(""Sides must be positive."");
        }

        // Check the triangle inequality rule
        if (!isValidTriangle(side1, side2, side3)) {
            throw new IllegalTriangleException(""Invalid triangle: The sum of any two sides must be greater than the other side."");
        }

        // Initialize the triangle sides
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }

    // Method to check if the sides can form a triangle
    private boolean isValidTriangle(double a, double b, double c) {
        return (a + b > c) && (a + c > b) && (b + c > a);
    }

    // Other methods and properties of the Triangle class
    // ...
}

public class IllegalTriangleException extends Exception {

    public IllegalTriangleException(String message) {
        super(message);
    }
}",0.6097438473129081
0_Loan.java," /**
     * Construct a loan with specified annual interest rate,
     * number of years, and loan amount
     */ /**
     * Return annualInterestRate
     */ /**
     * Set a new annualInterestRate
     */ /**
     * Return numberOfYears
     */ /**
     * Set a new numberOfYears
     */ /**
     * Return loanAmount
     */ /**
     * Set a new loanAmount
     */ /**
     * Find monthly payment
     */ /**
     * Find total payment
     */ /**
     * Return loan date
     */","package ch_12.exercise12_04;

public class Loan {
    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    private java.util.Date loanDate;

    /* Default constructor */
    public Loan() {
        this(2.5, 1, 1000);
    }

    
    public Loan(double annualInterestRate, int numberOfYears,
                double loanAmount) {
        if (loanAmount <= 0) {
            throw new IllegalArgumentException(""Loan Amount must be greater than 0."");
        } else if (annualInterestRate <= 0) {
            throw new IllegalArgumentException(""Annual interest rate must be greater than 0."");
        } else if (numberOfYears <= 0) {
            throw new IllegalArgumentException(""Number of years must be greater than 0."");
        }
        this.annualInterestRate = annualInterestRate;
        this.numberOfYears = numberOfYears;
        this.loanAmount = loanAmount;
        loanDate = new java.util.Date();
    }

    
    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    
    public void setAnnualInterestRate(double annualInterestRate) {
        if (annualInterestRate <= 0) {
            throw new IllegalArgumentException(""Annual Interest Rate must be greater than 0."");
        }
        this.annualInterestRate = annualInterestRate;
    }

    
    public int getNumberOfYears() {
        return numberOfYears;
    }

    
    public void setNumberOfYears(int numberOfYears) {
        if (numberOfYears <= 0) {
            throw new IllegalArgumentException(""Number of years must be greater than 0."");
        }
        this.numberOfYears = numberOfYears;
    }

    
    public double getLoanAmount() {
        return loanAmount;
    }

    
    public void setLoanAmount(double loanAmount) {
        if (loanAmount <= 0) {
            throw new IllegalArgumentException(""Loan Amount must be greater than 0."");
        }

        this.loanAmount = loanAmount;
    }

    
    public double getMonthlyPayment() {
        double monthlyInterestRate = annualInterestRate / 1200;
        return loanAmount * monthlyInterestRate / (1 -
                (1 / Math.pow(1 + monthlyInterestRate, numberOfYears * 12)));
    }

    
    public double getTotalPayment() {
        return getMonthlyPayment() * numberOfYears * 12;
    }

    
    public java.util.Date getLoanDate() {
        return loanDate;
    }
}
","import java.util.Date;

public class Loan {
    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    private Date loanDate;

    public Loan(double annualInterestRate, int numberOfYears, double loanAmount) {
        this.annualInterestRate = annualInterestRate;
        this.numberOfYears = numberOfYears;
        this.loanAmount = loanAmount;
        this.loanDate = new Date();
    }

    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    public void setAnnualInterestRate(double annualInterestRate) {
        this.annualInterestRate = annualInterestRate;
    }

    public int getNumberOfYears() {
        return numberOfYears;
    }

    public void setNumberOfYears(int numberOfYears) {
        this.numberOfYears = numberOfYears;
    }

    public double getLoanAmount() {
        return loanAmount;
    }

    public void setLoanAmount(double loanAmount) {
        this.loanAmount = loanAmount;
    }

    public double getMonthlyPayment() {
        double monthlyInterestRate = annualInterestRate / 1200;
        double monthlyPayment = loanAmount * monthlyInterestRate / (1 - 1 / Math.pow(1 + monthlyInterestRate, numberOfYears * 12));
        return monthlyPayment;
    }

    public double getTotalPayment() {
        double totalPayment = getMonthlyPayment() * numberOfYears * 12;
        return totalPayment;
    }

    public Date getLoanDate() {
        return loanDate;
    }
}",2,"public class Loan {

    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    private java.util.Date loanDate;

    /**
     * Constructs a loan with a specified annual interest rate,
     * number of years, and loan amount.
     */
    public Loan(double annualInterestRate, int numberOfYears, double loanAmount) {
        setAnnualInterestRate(annualInterestRate);
        setNumberOfYears(numberOfYears);
        setLoanAmount(loanAmount);
        this.loanDate = new java.util.Date();
    }

    /**
     * Returns the annual interest rate.
     */
    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    /**
     * Sets a new annual interest rate.
     */
    public void setAnnualInterestRate(double annualInterestRate) {
        this.annualInterestRate = annualInterestRate;
    }

    /**
     * Returns the number of years.
     */
    public int getNumberOfYears() {
        return numberOfYears;
    }

    /**
     * Sets a new number of years.
     */
    public void setNumberOfYears(int numberOfYears) {
        this.numberOfYears = numberOfYears;
    }

    /**
     * Returns the loan amount.
     */
    public double getLoanAmount() {
        return loanAmount;
    }

    /**
     * Sets a new loan amount.
     */
    public void setLoanAmount(double loanAmount) {
        this.loanAmount = loanAmount;
    }

    /**
     * Finds the monthly payment.
     */
    public double findMonthlyPayment() {
        double monthlyInterestRate = annualInterestRate / 1200;
        return (loanAmount * monthlyInterestRate) / (1 - Math.pow(1 + monthlyInterestRate, -numberOfYears * 12));
    }

    /**
     * Finds the total payment.
     */
    public double findTotalPayment() {
        return findMonthlyPayment() * numberOfYears * 12;
    }

    /**
     * Returns the loan date.
     */
    public java.util.Date getLoanDate() {
        return loanDate;
    }
}",0.7878787878787878
0_Exercise12_04.java," /**
 * *12.4 (IllegalArgumentException) Modify the Loan class in Listing 10.2 to
 * throw IllegalArgumentException if the loan amount, interest rate, or
 * number of years is less than or equal to zero.
 */","package ch_12.exercise12_04;


public class Exercise12_04 {
    public static void main(String[] args) {
        Loan testLoan = new Loan();

        try {
            testLoan.setLoanAmount(-123_000);
        } catch (IllegalArgumentException e1) {
            System.out.println(""IllegalArgumentException Caught: "" + e1.getMessage());
        }

        try {
            testLoan.setAnnualInterestRate(-5.5);
        } catch (IllegalArgumentException e2) {
            System.out.println(""IllegalArgumentException Caught: "" + e2.getMessage());

        }

        try {
            testLoan.setNumberOfYears(0);

        } catch (IllegalArgumentException e3) {
            System.out.println(""IllegalArgumentException Caught: "" + e3.getMessage());

        }


        try {
            testLoan.setAnnualInterestRate(7.4);
            testLoan.setNumberOfYears(10);
            testLoan.setLoanAmount(100_000);


        } catch (IllegalArgumentException e5) {
            System.out.println(""IllegalArgumentException Caught: "" + e5.getMessage());

        }

        try {
            System.out.println(""For a Loan where: "");
            System.out.println(""Annual interest rate = "" + testLoan.getAnnualInterestRate());
            System.out.println(""Amount = "" + testLoan.getLoanAmount());
            System.out.println(""number of years = "" + testLoan.getNumberOfYears());
            System.out.println(""loan date = "" + testLoan.getLoanDate());
            System.out.printf(""The monthly payment = $%.2f"", testLoan.getMonthlyPayment());

        } catch (IllegalArgumentException e6) {
            System.out.println(""IllegalArgumentException Caught: "" + e6.getMessage());

        }


    }
}

","import java.util.Date;

public class Loan {
    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    private Date loanDate;

    public Loan(double annualInterestRate, int numberOfYears, double loanAmount) {
        if (annualInterestRate <= 0) {
            throw new IllegalArgumentException(""Interest rate must be greater than zero."");
        }
        if (numberOfYears <= 0) {
            throw new IllegalArgumentException(""Number of years must be greater than zero."");
        }
        if (loanAmount <= 0) {
            throw new IllegalArgumentException(""Loan amount must be greater than zero."");
        }
        this.annualInterestRate = annualInterestRate;
        this.numberOfYears = numberOfYears;
        this.loanAmount = loanAmount;
        this.loanDate = new Date();
    }

    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    public void setAnnualInterestRate(double annualInterestRate) {
        if (annualInterestRate <= 0) {
            throw new IllegalArgumentException(""Interest rate must be greater than zero."");
        }
        this.annualInterestRate = annualInterestRate;
    }

    public int getNumberOfYears() {
        return numberOfYears;
    }

    public void setNumberOfYears(int numberOfYears) {
        if (numberOfYears <= 0) {
            throw new IllegalArgumentException(""Number of years must be greater than zero."");
        }
        this.numberOfYears = numberOfYears;
    }

    public double getLoanAmount() {
        return loanAmount;
    }

    public void setLoanAmount(double loanAmount) {
        if (loanAmount <= 0) {
            throw new IllegalArgumentException(""Loan amount must be greater than zero."");
        }
        this.loanAmount = loanAmount;
    }

    public double getMonthlyPayment() {
        double monthlyInterestRate = annualInterestRate / 1200;
        double monthlyPayment = loanAmount * monthlyInterestRate / (1 - 1 / Math.pow(1 + monthlyInterestRate, numberOfYears * 12));
        return monthlyPayment;
    }

    public double getTotalPayment() {
        double totalPayment = getMonthlyPayment() * numberOfYears * 12;
        return totalPayment;
    }

    public Date getLoanDate() {
        return loanDate;
    }
}",2,"public class Loan {

    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    private java.util.Date loanDate;

    /**
     * Constructs a loan with a specified annual interest rate,
     * number of years, and loan amount.
     *
     * @param annualInterestRate The annual interest rate for the loan.
     * @param numberOfYears      The number of years for the loan.
     * @param loanAmount         The loan amount.
     * @throws IllegalArgumentException if the loan amount, interest rate,
     *                                  or number of years is less than or equal to zero.
     */
    public Loan(double annualInterestRate, int numberOfYears, double loanAmount) {
        setAnnualInterestRate(annualInterestRate);
        setNumberOfYears(numberOfYears);
        setLoanAmount(loanAmount);
        this.loanDate = new java.util.Date();
    }

    /**
     * Returns the annual interest rate.
     */
    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    /**
     * Sets a new annual interest rate.
     *
     * @param annualInterestRate The new annual interest rate.
     * @throws IllegalArgumentException if the annual interest rate is less than or equal to zero.
     */
    public void setAnnualInterestRate(double annualInterestRate) {
        if (annualInterestRate <= 0) {
            throw new IllegalArgumentException(""Annual interest rate must be greater than zero."");
        }
        this.annualInterestRate = annualInterestRate;
    }

    /**
     * Returns the number of years.
     */
    public int getNumberOfYears() {
        return numberOfYears;
    }

    /**
     * Sets a new number of years.
     *
     * @param numberOfYears The new number of years.
     * @throws IllegalArgumentException if the number of years is less than or equal to zero.
     */
    public void setNumberOfYears(int numberOfYears) {
        if (numberOfYears <= 0) {
            throw new IllegalArgumentException(""Number of years must be greater than zero."");
        }
        this.numberOfYears = numberOfYears;
    }

    /**
     * Returns the loan amount.
     */
    public double getLoanAmount() {
        return loanAmount;
    }

    /**
     * Sets a new loan amount.
     *
     * @param loanAmount The new loan amount.
     * @throws IllegalArgumentException if the loan amount is less than or equal to zero.
     */
    public void setLoanAmount(double loanAmount) {
        if (loanAmount <= 0) {
            throw new IllegalArgumentException(""Loan amount must be greater than zero."");
        }
        this.loanAmount = loanAmount;
    }

    /**
     * Finds the monthly payment.
     */
    public double findMonthlyPayment() {
        double monthlyInterestRate = annualInterestRate / 1200;
        return (loanAmount * monthlyInterestRate) / (1 - Math.pow(1 + monthlyInterestRate, -numberOfYears * 12));
    }

    /**
     * Finds the total payment.
     */
    public double findTotalPayment() {
        return findMonthlyPayment() * numberOfYears * 12;
    }

    /**
     * Returns the loan date.
     */
    public java.util.Date getLoanDate() {
        return loanDate;
    }
}",0.7038060812247502
0_Exercise12_14.java," /**
 * *12.14 (Process scores in a text file) Suppose that a text file contains an unspecified
 * number of scores separated by blanks. Write a program that prompts the user
 * to enter the file, reads the scores from the file, and displays their total and
 * average
 * <p>
 * TO TEST: Enter ""ScoresFile.txt"" when prompted.
 */","package ch_12.exercise12_14;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;


public class Exercise12_14 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a file to read: "");
        String filePath =
                ""src"" + File.separator + ""ch_12"" + File.separator + ""exercise12_14"" + File.separator + in.nextLine().trim();
        File file = new File(filePath);

        try (Scanner fileScanner = new Scanner(file)) {
            ArrayList<Double> scores = new ArrayList<>();
            while (fileScanner.hasNext()) {
                String value = fileScanner.next();
                scores.add(Double.parseDouble(value));
            }
            double total = 0;
            for (Double score : scores) {
                total += score;
            }
            double average = total / scores.size();
            System.out.printf(""\nTotal is %.2f"", total);
            System.out.printf(""\nAverage is %.2f"", average);

        } catch (FileNotFoundException fileNotFoundException) {
            fileNotFoundException.printStackTrace();
            System.out.println(""Could not find this file: "" + file.getAbsolutePath());
        }

        in.close();
    }
}
","import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class ScoreAnalyzer {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the filename: "");
        String filename = input.nextLine();

        File file = new File(filename);
        try {
            Scanner fileInput = new Scanner(file);
            int total = 0;
            int count = 0;
            while (fileInput.hasNextInt()) {
                int score = fileInput.nextInt();
                total += score;
                count++;
            }
            fileInput.close();
            double average = (double) total / count;
            System.out.println(""Total score: "" + total);
            System.out.println(""Average score: "" + average);
        } catch (FileNotFoundException e) {
            System.out.println(""File not found."");
        }
    }
}",2,"import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class ScoreProcessor {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the file name
        System.out.println(""Enter the file name: "");
        String fileName = scanner.nextLine();

        try {
            // Open the file for reading
            File file = new File(fileName);
            Scanner fileScanner = new Scanner(file);

            // Initialize variables
            int total = 0;
            int count = 0;

            // Read scores from the file
            while (fileScanner.hasNext()) {
                int score = fileScanner.nextInt();
                total += score;
                count++;
            }

            // Close the file scanner
            fileScanner.close();

            // Calculate and display total and average
            if (count > 0) {
                double average = (double) total / count;
                System.out.println(""Total: "" + total);
                System.out.println(""Average: "" + average);
            } else {
                System.out.println(""No scores found in the file."");
            }

        } catch (FileNotFoundException e) {
            // Handle file not found exception
            System.out.println(""Error: File '"" + fileName + ""' not found."");
        } catch (Exception e) {
            // Handle other exceptions
            System.out.println(""An error occurred: "" + e.getMessage());
        } finally {
            // Close the scanner
            scanner.close();
        }
    }
}
",0.6828038325769037
0_Exercise12_22.java," /**
 * *12.22 (Replace text) Revise Programming Exercise 12.16 to replace a string in a file
 * with a new string for all files in the specified directory using the command:
 * <p>
 * java Exercise12_22 dir oldString newString
 * <p>
 * example cmd: java Exercise12_22 testDirectory test fun
 * or if testFile.txt's already have the word fun switch to:
 * cmd:  java Exercise12_22 testDirectory fun test
 */","package ch_12.exercise12_22;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Scanner;


public class Exercise12_22 {

    public static void main(String[] args) {
        if (args.length < 3) {
            System.out.println(
                    ""Run: java Exercise12_16 fileName oldString newString"");
            System.out.println(args.length);
            System.exit(1);
        }

        File[] files = new File(args[0]).listFiles();

        if (files == null) {
            System.out.println(""Directory: "" + args[0] + "" is not a valid file directory."");
            System.exit(2);
        }
        for (File f : files) {
            replaceStrNextFile(f, args[1], args[2]);
        }

    }

    static void replaceStrNextFile(File file, String oldString, String nuString) {
        ArrayList<String> strHelper = new ArrayList<>();

        try (Scanner input = new Scanner(file)) {
            while (input.hasNext()) {
                String s1 = input.nextLine();
                String s2 = s1.replaceAll(oldString, nuString);
                strHelper.add(s2);

            }
        } catch (FileNotFoundException fileNotFoundException) {
            fileNotFoundException.printStackTrace();
        }

        try (PrintWriter output = new PrintWriter(file)) {
            for (int i = 0; i < strHelper.size(); i++) {
                output.println(strHelper.remove(i));
            }
        } catch (FileNotFoundException fileNotFoundException) {
            fileNotFoundException.printStackTrace();
        }
    }
}
","import java.io.*;

public class Exercise12_22 {
    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println(""Usage: java Exercise12_22 directory oldString newString"");
            System.exit(1);
        }

        String directory = args[0];
        String oldString = args[1];
        String newString = args[2];

        File dir = new File(directory);
        if (!dir.isDirectory()) {
            System.out.println(directory + "" is not a directory."");
            System.exit(2);
        }

        File[] files = dir.listFiles();
        for (File file : files) {
            if (file.isFile()) {
                try {
                    BufferedReader reader = new BufferedReader(new FileReader(file));
                    String line = reader.readLine();
                    StringBuilder builder = new StringBuilder();
                    while (line != null) {
                        builder.append(line.replaceAll(oldString, newString));
                        builder.append(System.lineSeparator());
                        line = reader.readLine();
                    }
                    reader.close();

                    BufferedWriter writer = new BufferedWriter(new FileWriter(file));
                    writer.write(builder.toString());
                    writer.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        System.out.println(""Finished replacing \"""" + oldString + ""\"" with \"""" + newString + ""\"" in "" + files.length + "" files in "" + directory);
    }
}
",2,"import java.io.*;
import java.util.Scanner;

public class TextReplacer {

    public static void main(String[] args) {
        // Check if the correct number of command-line arguments are provided
        if (args.length != 3) {
            System.out.println(""Usage: java TextReplacer <directory> <oldString> <newString>"");
            return;
        }

        // Get command-line arguments
        String directoryPath = args[0];
        String oldString = args[1];
        String newString = args[2];

        // Replace text in all files in the specified directory
        replaceTextInDirectory(directoryPath, oldString, newString);

        System.out.println(""Text replaced successfully in all files."");
    }

    // Method to replace text in all files in a directory
    private static void replaceTextInDirectory(String directoryPath, String oldString, String newString) {
        File directory = new File(directoryPath);

        // Check if the provided path is a directory
        if (!directory.isDirectory()) {
            System.out.println(""Error: The provided path is not a directory."");
            return;
        }

        // Get the list of files in the directory
        File[] files = directory.listFiles();

        // Iterate through each file in the directory
        for (File file : files) {
            // Check if the file is a regular file
            if (file.isFile()) {
                // Replace text in the file
                replaceTextInFile(file, oldString, newString);
            }
        }
    }

    // Method to replace text in a file
    private static void replaceTextInFile(File file, String oldString, String newString) {
        try {
            // Read the content of the file
            StringBuilder fileContent = new StringBuilder();
            Scanner scanner = new Scanner(file);

            while (scanner.hasNextLine()) {
                fileContent.append(scanner.nextLine()).append(""\n"");
            }

            // Close the scanner
            scanner.close();

            // Replace the old string with the new string
            String updatedContent = fileContent.toString().replace(oldString, newString);

            // Write the updated content back to the file
            PrintWriter writer = new PrintWriter(file);
            writer.write(updatedContent);

            // Close the writer
            writer.close();

        } catch (IOException e) {
            // Handle IOException
            System.out.println(""Error processing file: "" + file.getName());
        }
    }
}
",0.5148818656029457
0_Exercise12_24.java," /**
 * *12.24 (Create large dataset) Create a data file with 1,000 lines.
 * <p>
 * Each line in the file consists of a faculty member’s first name, last name, rank, and salary.
 * The faculty member’s first name and last name for the ith line are FirstNamei and
 * LastNamei.
 * <p>
 * The rank is randomly generated as assistant, associate, and full.
 * The salary is randomly generated as a number with two digits after the decimal
 * point.
 * <p>
 * The salary for an assistant professor should be in the range from 50,000
 * to 80,000, for associate professor from 60,000 to 110,000, and for full professor
 * from 75,000 to 130,000.
 * <p>
 * Save the file in Salary.txt. Here are some sample data:
 * FirstName1 LastName1 assistant 60055.95
 * FirstName2 LastName2 associate 81112.45
 * . . .
 * FirstName1000 LastName1000 full 92255.21
 */","package ch_12.exercise12_24;


import java.io.File;
import java.io.PrintWriter;


public class Exercise12_24 {
    final static String FNAME = ""FirstName"";
    final static String LNAME = ""LastName"";

    final static String RANK_ASSISTANT = ""assistant"";
    final static String RANK_FULL = ""full"";
    final static String RANK_ASSOCIATE = ""associate"";

    public static void main(String[] args) {
        File file = new File(""src\\ch_12\\exercise12_24\\Salary.txt"");

        try (PrintWriter printWriter = new PrintWriter(file)) {
            for (int numLines = 1; numLines <= 1000; numLines++) {
                String rank = getRank();    //Randomly generated rank
                double salary = getSalary(rank); //Semi-randomly generated salary

                StringBuilder recordBuilder = new StringBuilder();//Build the record
                recordBuilder.append(FNAME + numLines).append("" "") //First name
                        .append(LNAME + numLines).append("" "")     //Last name
                        .append(rank).append("" "")
                        .append(String.format(""%.2f"", salary)).append("" "");

                printWriter.println(recordBuilder.toString());
//                System.out.println(recordBuilder.toString());

            }

        } catch (Exception e) {
            e.printStackTrace();
        }


    }

    static double getSalary(final String rank) {
        double salary = 0.0;
        switch (rank) {
            case RANK_ASSISTANT:
                salary = 50_000 + Math.random() * 30_000;
                break;
            case RANK_ASSOCIATE:
                salary = 60_000 + Math.random() * 50_000;
                break;
            case RANK_FULL:
                salary = 75_000 + Math.random() * 55_000;
                break;
        }
        return salary;
    }

    static String getRank() {
        final int random = (int) (1 + Math.random() * 3);
        String rank = null;
        switch (random) {
            case 1:
                rank = RANK_ASSISTANT;
                break;
            case 2:
                rank = RANK_ASSOCIATE;
                break;
            case 3:
                rank = RANK_FULL;
                break;
        }
        return rank;
    }
}
","import java.io.FileWriter;
import java.io.IOException;
import java.util.Random;

public class FacultyDataGenerator {
    private static final int NUMBER_OF_LINES = 1000;
    private static final String[] FIRST_NAMES = {""John"", ""Jane"", ""Bob"", ""Alice"", ""David"", ""Mary"", ""Kate"", ""Peter"", ""Susan"", ""Tom""};
    private static final String[] LAST_NAMES = {""Doe"", ""Smith"", ""Johnson"", ""Williams"", ""Brown"", ""Jones"", ""Miller"", ""Davis"", ""Garcia"", ""Wilson""};
    private static final String[] RANKS = {""assistant"", ""associate"", ""full""};
    private static final double[] SALARY_RANGES = {80000.0 - 50000.0, 110000.0 - 60000.0, 130000.0 - 75000.0};
    private static final double[] SALARY_MIN = {50000.0, 60000.0, 75000.0};
    private static final Random random = new Random();

    public static void main(String[] args) {
        try {
            FileWriter fileWriter = new FileWriter(""Salary.txt"");
            for (int i = 1; i <= NUMBER_OF_LINES; i++) {
                String firstName = FIRST_NAMES[random.nextInt(FIRST_NAMES.length)];
                String lastName = LAST_NAMES[random.nextInt(LAST_NAMES.length)];
                String rank = RANKS[random.nextInt(RANKS.length)];
                double salary = SALARY_MIN[getIndexForRank(rank)] + SALARY_RANGES[getIndexForRank(rank)] * random.nextDouble();
                fileWriter.write(firstName + "" "" + lastName + "" "" + rank + "" "" + String.format(""%.2f"", salary) + ""\n"");
            }
            fileWriter.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static int getIndexForRank(String rank) {
        switch (rank) {
            case ""assistant"":
                return 0;
            case ""associate"":
                return 1;
            case ""full"":
                return 2;
            default:
                return -1;
        }
    }
}",2,"import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Random;

public class DatasetCreator {

    public static void main(String[] args) {
        // Define the file name
        String fileName = ""Salary.txt"";

        // Attempt to create the data file
        try {
            // Create a BufferedWriter for efficient writing
            BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));

            // Write 1,000 lines of faculty members' information
            for (int i = 1; i <= 1000; i++) {
                // Generate random data
                String firstName = ""FirstName"" + i;
                String lastName = ""LastName"" + i;
                String rank = generateRandomRank();
                double salary = generateRandomSalary(rank);

                // Write the data to the file
                writer.write(firstName + "" "" + lastName + "" "" + rank + "" "" + salary);
                writer.newLine();
            }

            // Close the writer
            writer.close();

            System.out.println(""Data file created successfully: "" + fileName);
        } catch (IOException e) {
            // Handle IOException
            System.out.println(""Error creating the data file: "" + e.getMessage());
        }
    }

    // Method to generate a random rank (assistant, associate, full)
    private static String generateRandomRank() {
        String[] ranks = {""assistant"", ""associate"", ""full""};
        Random random = new Random();
        return ranks[random.nextInt(ranks.length)];
    }

    // Method to generate a random salary based on rank
    private static double generateRandomSalary(String rank) {
        Random random = new Random();
        double salary;

        switch (rank) {
            case ""assistant"":
                salary = 50000 + random.nextDouble() * 30000;
                break;
            case ""associate"":
                salary = 60000 + random.nextDouble() * 50000;
                break;
            case ""full"":
                salary = 75000 + random.nextDouble() * 55000;
                break;
            default:
                salary = 0;
        }

        return Math.round(salary * 100.0) / 100.0; // Round to two decimal places
    }
}
",0.4388059701492537
0_Exercise12_12.java," /**
 * *12.12 (Reformat Java source code) Write a program that converts the Java source
 * code from the next-line brace style to the end-of-line brace style. For example,
 * the following Java source in (a) uses the next-line brace style. Your program
 * converts it to the end-of-line brace style in (b).
 * public class Test
 * {
 * public static void main(String[] args)
 * {
 * // Some statements
 * }
 * }
 * (a) Next-line brace style
 * public class Test {
 * public static void main(String[] args) {
 * // Some statements
 * }
 * }
 * (b) End-of-line brace style
 * <p>
 * Your program can be invoked from the command line with the Java sourcecode file as the argument.
 * <p>
 * It converts the Java source code to a new format. For
 * example, the following command converts the Java source-code file Test.java
 * to the end-of-line brace style.
 * java Exercise12_12 Test.java
 */","package ch_12.exercise12_12;

import java.io.*;

import java.util.ArrayList;
import java.util.Scanner;


public class Exercise12_12 {
    public static void main(String[] args) {
        ArrayList<String> lines = new ArrayList<>();
        if (args.length < 1) {
            System.out.println(""Usage: java Exercise12_12 sourceFile"");
            return;
        }
        File file = new File(args[0]);

        if (file.exists()) {

            try {
                Scanner scanner = new Scanner(file);
                while (scanner.hasNextLine()) {
                    String line = scanner.nextLine();
                    lines.add(line);

                }

                for (int i = 1; i < lines.size(); i++) {
                    if (lines.get(i).contains(""{"")) {
                        String orgLine = lines.get(i);
                        orgLine = orgLine.replace('{', ' '); //Remove open bracket
                        String targetLine = lines.get(i - 1); //Get preceding line of open bracket
                        targetLine = targetLine + "" {""; // Add the bracket to the end of line
                        lines.set(i, orgLine);
                        lines.set(i - 1, targetLine);
                    }
                }
                PrintWriter writer = new PrintWriter(file);

                for (String line : lines) {
                    writer.println(line);
                }
                writer.close();


            } catch (FileNotFoundException e) {
                System.out.println(""File could not be found to exist: "" + e);

            }
        }
    }
}
","import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class BraceStyleConverter {
    
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java BraceStyleConverter <filename>"");
            System.exit(1);
        }
        
        String filename = args[0];
        
        try (BufferedReader br = new BufferedReader(new FileReader(filename));
             BufferedWriter bw = new BufferedWriter(new FileWriter(filename + "".out""))) {
            
            String line;
            while ((line = br.readLine()) != null) {
                // Check if the line contains an opening brace
                int braceIndex = line.indexOf(""{"");
                if (braceIndex != -1 && braceIndex != line.length() - 1) {
                    // If the opening brace is not the last character on the line, move it to the end
                    line = line.substring(0, braceIndex + 1) + "" "" + line.substring(braceIndex + 1);
                }
                
                // Write the modified line to the output file
                bw.write(line);
                bw.newLine();
            }
            
        } catch (IOException e) {
            System.err.println(""Error: "" + e.getMessage());
            System.exit(1);
        }
        
        System.out.println(""Conversion complete. Output file: "" + filename + "".out"");
    }
    
}",2,"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class BraceStyleConverter {

    public static void main(String[] args) {
        // Check if the correct number of command-line arguments are provided
        if (args.length != 1) {
            System.out.println(""Usage: java BraceStyleConverter <JavaSourceCodeFile>"");
            return;
        }

        // Get the file name from the command-line argument
        String fileName = args[0];

        // Attempt to convert the Java source code file
        try {
            // Read the original Java source code
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            StringBuilder originalCode = new StringBuilder();

            String line;
            while ((line = reader.readLine()) != null) {
                originalCode.append(line).append(""\n"");
            }

            // Close the reader
            reader.close();

            // Convert the Java source code to end-of-line brace style
            String convertedCode = convertToEOLBraceStyle(originalCode.toString());

            // Write the converted code back to the file
            BufferedWriter writer = new BufferedWriter(new FileWriter(fileName));
            writer.write(convertedCode);

            // Close the writer
            writer.close();

            System.out.println(""Java source code converted successfully."");

        } catch (IOException e) {
            // Handle IOException
            System.out.println(""Error converting Java source code: "" + e.getMessage());
        }
    }

    // Method to convert next-line brace style to end-of-line brace style
    private static String convertToEOLBraceStyle(String originalCode) {
        // Replace next-line braces with end-of-line braces
        return originalCode.replaceAll(""\\)\\s*\\{"", "") {"");
    }
}
",0.5725574712643678
0_Exercise12_15.java," /**
 * 12.15 (Write/read data) Write a program to create a file named Exercise12_15.txt if
 * it does not exist.
 * <p>
 * Write 100 integers created randomly into the file using text I/O.
 * <p>
 * Integers are separated by spaces in the file.
 * <p>
 * Read the data back from the file and display the data in increasing order.
 */","package ch_12.exercise12_15;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;


public class Exercise12_15 {
    static ArrayList<Integer> lines = new ArrayList<>();

    public static void main(String[] args) {
        boolean success = true;
        File file = new File(""src"" + File.separator + ""ch_12"" + File.separator + ""exercise12_15"" + File.separator +
                ""Exercise12_15.txt"");
        if (!file.exists()) {
            try {
                success = file.createNewFile();
            } catch (IOException ioe) {
                success = false;
                ioe.printStackTrace();
            }
        }
        if (success) {
            try (PrintWriter printWriter = new PrintWriter(file)) {
                for (int i = 0; i < 100; i++) {
                    int random = (int) (1 + Math.random() * 9999);
                    printWriter.write(String.valueOf(random));
                    printWriter.write("" "");
                }
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
            try (Scanner fileIn = new Scanner(file)) {
                while (fileIn.hasNextLine()) {
                    String[] line = fileIn.nextLine().split("" "");
                    for (String num : line) {
                        lines.add(Integer.parseInt(num));
                    }
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
            lines.sort((i1, i2) -> i1 - i2);
            System.out.println(Arrays.toString(lines.toArray()));
            System.out.println(""Integer count= "" + lines.size());

        }
    }
}
","import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

public class IntegerFileIO {
    
    public static void main(String[] args) {
        File file = new File(""Exercise12_15.txt"");
        
        // Create the file if it does not exist
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                System.err.println(""Error creating file: "" + e.getMessage());
                System.exit(1);
            }
        }
        
        // Generate 100 random integers and write them to the file
        Random random = new Random();
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {
            for (int i = 0; i < 100; i++) {
                int num = random.nextInt(1000);
                bw.write(num + "" "");
            }
        } catch (IOException e) {
            System.err.println(""Error writing to file: "" + e.getMessage());
            System.exit(1);
        }
        
        // Read the integers from the file and store them in an ArrayList
        ArrayList<Integer> nums = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line = br.readLine();
            String[] tokens = line.split("" "");
            for (String token : tokens) {
                nums.add(Integer.parseInt(token));
            }
        } catch (IOException e) {
            System.err.println(""Error reading from file: "" + e.getMessage());
            System.exit(1);
        }
        
        // Sort the integers in increasing order
        Collections.sort(nums);
        
        // Display the integers in increasing order
        for (int num : nums) {
            System.out.println(num);
        }
    }
    
}",3,"import java.io.*;
import java.util.*;

public class DataFileHandler {

    public static void main(String[] args) {
        // Create file name
        String fileName = ""Exercise12_15.txt"";

        // Check if the file exists
        if (!fileExists(fileName)) {
            // If not, create the
                        createFile(fileName);
        }

        // Write 100 random integers into the file
        writeRandomIntegersToFile(fileName, 100);

        // Read the data back from the file
        List<Integer> dataList = readDataFromFile(fileName);

        // Display the data in increasing order
        displayDataInIncreasingOrder(dataList);
    }

    // Method to check if the file exists
    private static boolean fileExists(String fileName) {
        File file = new File(fileName);
        return file.exists();
    }

    // Method to create a file
    private static void createFile(String fileName) {
        try {
            File file = new File(fileName);
            file.createNewFile();
            System.out.println(""File created: "" + fileName);
        } catch (IOException e) {
            System.out.println(""Error creating the file: "" + e.getMessage());
        }
    }

    // Method to write random integers to the file
    private static void writeRandomIntegersToFile(String fileName, int numIntegers) {
        try {
            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));

            for (int i = 0; i < numIntegers; i++) {
                int randomInt = new Random().nextInt(1000);
                writer.print(randomInt + "" "");
            }

            writer.close();
            System.out.println(""Random integers written to file: "" + fileName);

        } catch (IOException e) {
            System.out.println(""Error writing random integers to the file: "" + e.getMessage());
        }
    }

    // Method to read data from the file
    private static List<Integer> readDataFromFile(String fileName) {
        List<Integer> dataList = new ArrayList<>();

        try {
            Scanner scanner = new Scanner(new FileReader(fileName));

            while (scanner.hasNext()) {
                int data = scanner.nextInt();
                dataList.add(data);
            }

            scanner.close();

        } catch (FileNotFoundException e) {
            System.out.println(""Error reading data from the file: "" + e.getMessage());
        }

        return dataList;
    }

    // Method to display data in increasing order
    private static void displayDataInIncreasingOrder(List<Integer> dataList) {
        Collections.sort(dataList);
        System.out.println(""Data in increasing order: "" + dataList);
    }
}",0.538135593220339
0_Exercise12_08.java," /**
 * *12.8 (HexFormatException) Exercise 12.6 implements the hex2Dec method to
 * throw a NumberFormatException if the string is not a hex string. Define
 * a custom exception called HexFormatException.
 * <p>
 * Implement the hex2Dec method to throw a HexFormatException if the string is not a hex string.
 */","package ch_12.exercise12_08;


public class Exercise12_08 {
    public static void main(String[] args) {
        String validHexString = ""A7C9"";
        String invalidHexString = ""A7CZ"";

        System.out.println(""Hex String convert to decimal: "" + hexToDecimal(validHexString));
        System.out.println(""Hex String convert to decimal: "" + hexToDecimal(invalidHexString));

    }

    public static int hexToDecimal(String hex) {
        int decimalValue = 0;

        for (int i = 0; i < hex.length(); i++) {
            char hexChar = hex.charAt(i);
            if (checkHexChar(hexChar)) {
                decimalValue = decimalValue * 16 + hexCharToDecimal(hexChar);
            } else {
                throw new HexFormatException(hex);
            }

        }
        return decimalValue;
    }

    static boolean checkHexChar(char ch) {
        return ch >= '0' && ch <= 'F';
    }

    public static int hexCharToDecimal(char ch) {
        if (ch >= 'A' && ch <= 'F') {
            return 10 + ch - 'A';
        } else { // ch is '0', '1', ..., or '9'
            return ch - '0';
        }
    }
}
","public class HexFormatException extends Exception {
    public HexFormatException(String message) {
        super(message);
    }
}

public class HexConverter {
    public static int hex2Dec(String hexString) throws HexFormatException {
        int decimalValue = 0;
        for (int i = 0; i < hexString.length(); i++) {
            char hexChar = hexString.charAt(i);
            if (!(hexChar >= '0' && hexChar <= '9') &&
                !(hexChar >= 'A' && hexChar <= 'F') &&
                !(hexChar >= 'a' && hexChar <= 'f')) {
                throw new HexFormatException(""Invalid hex string: "" + hexString);
            }
            decimalValue = decimalValue * 16 + hexToDecimal(hexChar);
        }
        return decimalValue;
    }

    public static int hexToDecimal(char ch) {
        if (ch >= 'A' && ch <= 'F')
            return 10 + ch - 'A';
        else
            return ch - '0';
    }
}",3,"import java.util.Scanner;

public class HexConverter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a hex string
        System.out.print(""Enter a hex string: "");
        String hexString = scanner.nextLine();

        try {
            // Convert hex string to decimal
            int decimalValue = hex2Dec(hexString);
            System.out.println(""Decimal value: "" + decimalValue);
        } catch (HexFormatException e) {
            // Handle custom HexFormatException
            System.out.println(""Error: "" + e.getMessage());
        } finally {
            // Close the scanner
            scanner.close();
        }
    }

    // Method to convert hex string to decimal
    private static int hex2Dec(String hexString) throws HexFormatException {
        int decimalValue = 0;

        // Validate hex string
        if (!isValidHexString(hexString)) {
            throw new HexFormatException(""Invalid hex string format"");
        }

        // Convert hex string to decimal
        for (int i = hexString.length() - 1, power = 0; i >= 0; i--, power++) {
            char hexChar = hexString.charAt(i);
            int hexDigit = hexCharToDecimal(hexChar);
            decimalValue += hexDigit * Math.pow(16, power);
        }

        return decimalValue;
    }

    // Method to check if the hex string is valid
    private static boolean isValidHexString(String hexString) {
        // Check for null or empty string
        if (hexString == null || hexString.isEmpty()) {
            return false;
        }

        // Check for valid hex characters
        for (char hexChar : hexString.toCharArray()) {
            if (!Character.isDigit(hexChar) && (hexChar < 'A' || hexChar > 'F') && (hexChar < 'a' || hexChar > 'f')) {
                return false;
            }
        }

        return true;
    }

    // Method to convert hex character to decimal
    private static int hexCharToDecimal(char hexChar) {
        if (Character.isDigit(hexChar)) {
            return hexChar - '0';
        } else {
            return Character.toUpperCase(hexChar) - 'A' + 10;
        }
    }

    // Custom HexFormatException class
    static class HexFormatException extends Exception {
        public HexFormatException(String message) {
            super(message);
        }
    }
}
",0.3965646004480956
0_HexFormatException.java," /**
 * Define a custom exception called HexFormatException.
 */","package ch_12.exercise12_08;


public class HexFormatException extends NumberFormatException {
    public HexFormatException(String hex) {
        super(""Invalid Hex String: "" + hex);
    }
}
","public class HexFormatException extends Exception {
    public HexFormatException(String message) {
        super(message);
    }
}",3,"public class HexConverter {

    public static void main(String[] args) {
        try {
            // Simulate hex string conversion
            String hexString = ""1A3G""; // Invalid hex string
            int decimalValue = hex2Dec(hexString);
            System.out.println(""Decimal value: "" + decimalValue);
        } catch (HexFormatException e) {
            // Handle custom HexFormatException
            System.out.println(""Error: "" + e.getMessage());
        }
    }

    // Method to convert hex string to decimal
    private static int hex2Dec(String hexString) throws HexFormatException {
        int decimalValue = 0;

        // Validate hex string
        try {
            validateHexString(hexString);
        } catch (HexFormatException e) {
            throw e; // Re-throw the exception
        }

        // Convert hex string to decimal
        for (int i = hexString.length() - 1, power = 0; i >= 0; i--, power++) {
            char hexChar = hexString.charAt(i);
            int hexDigit = hexCharToDecimal(hexChar);
            decimalValue += hexDigit * Math.pow(16, power);
        }

        return decimalValue;
    }

    // Method to validate hex string
    private static void validateHexString(String hexString) throws HexFormatException {
        // Check for null or empty string
        if (hexString == null || hexString.isEmpty()) {
            throw new HexFormatException(""Hex string cannot be null or empty"");
        }

        // Check for valid hex characters
        for (char hexChar : hexString.toCharArray()) {
            if (!Character.isDigit(hexChar) && (hexChar < 'A' || hexChar > 'F') && (hexChar < 'a' || hexChar > 'f')) {
                throw new HexFormatException(""Invalid hex character: "" + hexChar);
            }
        }
    }

    // Method to convert hex character to decimal
    private static int hexCharToDecimal(char hexChar) {
        if (Character.isDigit(hexChar)) {
            return hexChar - '0';
        } else {
            return Character.toUpperCase(hexChar) - 'A' + 10;
        }
    }

    // Custom HexFormatException class
    static class HexFormatException extends Exception {
        public HexFormatException(String message) {
            super(message);
        }
    }
}
",0.1193727870510875
0_Exercise12_30.java," /**
 * *12.30 (Occurrences of each letter) Write a program that prompts the user to enter
 * a file name and displays the occurrences of each letter in the file. Letters are
 * case-insensitive. Here is a sample run:
 * Enter a filename: Lincoln.txt
 * Number of A's: 56
 * Number of B's: 134
 * ...
 * Number of Z's: 9
 */","package ch_12.exercise12_30;

import java.io.File;
import java.io.IOException;
import java.util.Scanner;


public class Exercise12_30 {
    public static void main(String[] args) {
        int[] occurrences = new int[26]; // [# of A's , # of B's, # of C's,...,...] (Index + 65) = uppercase char val
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a file name: "");// My Test file is: testfile.txt

        String fileName = in.next();
        File workingDir = new File(""."" + File.separator + ""src"" + File.separator + ""ch_12"" + File.separator +
                ""exercise12_30"" + File.separator);

        File file = new File(workingDir, fileName);

        if (!file.exists()) {
            System.out.println(""File does not exist..."");
            return;
        }
        try (Scanner fileIn = new Scanner(file)) {
            while (fileIn.hasNext()) {
                String str = fileIn.next();
                for (char ch : str.toCharArray()) {
                    if (Character.isLetter(ch)) {
                        occurrences[(Character.toUpperCase(ch) - 65)]++; /* Example: (A - 65) = 0, so int[0]++ */
                    }
                }
            }

        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
        in.close();

        for (int idx = 0; idx < occurrences.length; idx++) {
            char ch = (char) (idx + 65);
            System.out.println(""Number of "" + ch + ""'s: "" + occurrences[idx]);

        }

    }
}
","import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class CountLettersInFile {
    public static void main(String[] args) {
        // Prompt the user to enter a file name
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a file name: "");
        String fileName = scanner.nextLine();
        scanner.close();
        
        // Try to open the file and read its contents
        try {
            File file = new File(fileName);
            Scanner fileScanner = new Scanner(file);
            String fileContent = """";
            while (fileScanner.hasNextLine()) {
                fileContent += fileScanner.nextLine();
            }
            fileScanner.close();
            
            // Count the occurrences of each letter in the file
            Map<Character, Integer> letterCount = new HashMap<>();
            for (int i = 0; i < fileContent.length(); i++) {
                char c = fileContent.charAt(i);
                if (Character.isLetter(c)) {
                    c = Character.toLowerCase(c);
                    if (letterCount.containsKey(c)) {
                        letterCount.put(c, letterCount.get(c) + 1);
                    } else {
                        letterCount.put(c, 1);
                    }
                }
            }
            
            // Display the letter counts
            System.out.println(""Letter counts for file "" + fileName + "":"");
            for (char c = 'a'; c <= 'z'; c++) {
                int count = letterCount.getOrDefault(c, 0);
                if (count > 0) {
                    System.out.println(c + "": "" + count);
                }
            }
            
        } catch (FileNotFoundException e) {
            System.out.println(""File not found: "" + fileName);
        }
    }
}",3,"import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class LetterOccurrenceCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a file name
        System.out.print(""Enter a filename: "");
        String fileName = scanner.nextLine();

        // Count occurrences of each letter in the file
        countLetterOccurrences(fileName);

        // Close the scanner
        scanner.close();
    }

    // Method to count occurrences of each letter in the file
    private static void countLetterOccurrences(String fileName) {
        try {
            // Create a file object
            File file = new File(fileName);

            // Create an array to store occurrences of each letter
            int[] letterOccurrences = new int[26];

            // Initialize array with zeros
            for (int i = 0; i < letterOccurrences.length; i++) {
                letterOccurrences[i] = 0;
            }

            // Read the file
            Scanner fileScanner = new Scanner(file);

            // Process each line in the file
            while (fileScanner.hasNextLine()) {
                String line = fileScanner.nextLine();

                // Process each character in the line
                for (char character : line.toCharArray()) {
                    // Check if the character is a letter (case-insensitive)
                    if (Character.isLetter(character)) {
                        // Convert the letter to uppercase and update occurrences
                        int index = Character.toUpperCase(character) - 'A';
                        letterOccurrences[index]++;
                    }
                }
            }

            // Close the file scanner
            fileScanner.close();

            // Display the occurrences of each letter
            for (int i = 0; i < letterOccurrences.length; i++) {
                char letter = (char) ('A' + i);
                System.out.println(""Number of "" + letter + ""'s: "" + letterOccurrences[i]);
            }

        } catch (FileNotFoundException e) {
            // Handle file not found exception
            System.out.println(""Error: File not found - "" + e.getMessage());
        }
    }
}",0.556615776081425
0_Exercise12_06.java," /**
 * 12.6 (NumberFormatException) Listing 6.8 implements the hex2Dec(String
 * hexString) method, which converts a hex string into a decimal number.
 * Implement the hex2Dec method to throw a NumberFormatException if the
 * string is not a hex string.
 */","package ch_12.exercise12_06;


public class Exercise12_06 {
    public static void main(String[] args) {
        String hex1 = ""AF71Z"";
        String hex2 = ""AB8C"";
        try { //Try block is optional because NumberFormatException is child of RuntimeException (UnChecked Exception)
            System.out.println(""The decimal value for hex1 number ""
                    + hex1 + "" is "" + Hex2Dec.hexToDecimal(hex1.toUpperCase()));
        } catch (NumberFormatException nfe) {
            System.out.println(nfe);
        }

        try {
            System.out.println(""The decimal value for hex2 number ""
                    + hex2 + "" is "" + Hex2Dec.hexToDecimal(hex2.toUpperCase()));
        } catch (NumberFormatException nfe) {
            System.out.println(nfe);
        }

    }
}
","public static int hex2Dec(String hexString) throws NumberFormatException {
    // Check that the input string is not null or empty
    if (hexString == null || hexString.isEmpty()) {
        throw new NumberFormatException(""Input string is null or empty"");
    }
    
    // Check that the input string contains only hexadecimal digits
    for (int i = 0; i < hexString.length(); i++) {
        char c = hexString.charAt(i);
        if (!Character.isDigit(c) && !(""ABCDEFabcdef"".indexOf(c) >= 0)) {
            throw new NumberFormatException(""Input string is not a hex string"");
        }
    }
    
    // Convert the input string to decimal
    int decimal = 0;
    for (int i = 0; i < hexString.length(); i++) {
        char c = hexString.charAt(i);
        int digit = Character.digit(c, 16);
        decimal = decimal * 16 + digit;
    }
    
    return decimal;
}",3,"import java.util.Scanner;

public class HexConverter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a hex string
        System.out.print(""Enter a hex string: "");
        String hexString = scanner.nextLine();

        try {
            // Convert hex string to decimal
            int decimalValue = hex2Dec(hexString);
            System.out.println(""Decimal value: "" + decimalValue);
        } catch (NumberFormatException e) {
            // Handle NumberFormatException
            System.out.println(""Error: "" + e.getMessage());
        } finally {
            // Close the scanner
            scanner.close();
        }
    }

    // Method to convert hex string to decimal
    private static int hex2Dec(String hexString) {
        // Check if the hex string is not valid
        if (!isValidHexString(hexString)) {
            throw new NumberFormatException(""Invalid hex string format"");
        }

        // Convert hex string to decimal
        return Integer.parseInt(hexString, 16);
    }

    // Method to check if the hex string is valid
    private static boolean isValidHexString(String hexString) {
        try {
            // Attempt to parse the hex string
            Integer.parseInt(hexString, 16);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }
}",0.454025974025974
0_Exercise12_01_p2.java," /**
 * Exercise12_01 part2.....
 * ......Then write another program without using an
 * exception handler to achieve the same objective.
 * Your program should display a message that informs
 * the user of the wrong operand type before exiting
 */","package ch_12.exercise12_01;


public class Exercise12_01_p2 {
    public static void main(String[] args) {

        String t1 = args[0]; // Left side operand
        String t2 = args[2]; // Right side operand

        checkInput(t1);
        checkInput(t2);

        int result = 0;

        switch (args[1].charAt(0)) {
            case '+':
                result = Integer.parseInt(args[0]) + Integer.parseInt(args[2]);
                break;
            case '-':
                result = Integer.parseInt(args[0]) - Integer.parseInt(args[2]);
                break;
            case '.':
                result = Integer.parseInt(args[0]) * Integer.parseInt(args[2]);
                break;
            case '/':
                result = Integer.parseInt(args[0]) / Integer.parseInt(args[2]);
        }

        System.out.println(args[0] + ' ' + args[1] + ' ' + args[2] + "" = "" + result);
    }

    public static void checkInput(String str) {
        int i = str.length() - 1;
        while (i >= 0) {

            if (!Character.isDigit(str.charAt(i))) {

                System.out.println(""Invalid Input: "" + str);
                System.exit(0);
            }
            i--;
        }
    }
}
","public static void main(String[] args) {
    // Check that there are three command-line arguments
    if (args.length != 3) {
        throw new IllegalArgumentException(""Usage: java Calculator operand1 operator operand2"");
    }
    
    // Parse the operands as doubles
    double operand1, operand2;
    try {
        operand1 = Double.parseDouble(args[0]);
        operand2 = Double.parseDouble(args[2]);
    } catch (NumberFormatException e) {
        System.out.println(""Error: operand is not a number"");
        return;
    }
    
    // Perform the operation based on the operator
    double result = 0;
    switch (args[1]) {
        case ""+"":
            result = operand1 + operand2;
            break;
        case ""-"":
            result = operand1 - operand2;
            break;
        case ""*"":
            result = operand1 * operand2;
            break;
        case ""/"":
            result = operand1 / operand2;
            break;
        default:
            throw new IllegalArgumentException(""Invalid operator: "" + args[1]);
    }
    
    // Print the result
    System.out.println(args[0] + "" "" + args[1] + "" "" + args[2] + "" = "" + result);
}",3,"import java.util.Scanner;

public class SimpleCalculator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter two numbers
        System.out.print(""Enter the first number: "");
        double num1 = getDoubleInput(scanner);

        System.out.print(""Enter the second number: "");
        double num2 = getDoubleInput(scanner);

        // Calculate and display the result with exception handling
        try {
            double result = divideWithException(num1, num2);
            System.out.println(""Result with exception handling: "" + result);
        } catch (Exception e) {
            System.out.println(""Error with exception handling: "" + e.getMessage());
        }

        // Calculate and display the result without exception handling
        double resultWithoutException = divideWithoutException(num1, num2);
        System.out.println(""Result without exception handling: "" + resultWithoutException);

        // Close the scanner
        scanner.close();
    }

    // Method to get a valid double input from the user
    private static double getDoubleInput(Scanner scanner) {
        while (true) {
            try {
                return Double.parseDouble(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.out.print(""Invalid input. Please enter a valid number: "");
            }
        }
    }

    // Method to perform division with exception handling
    private static double divideWithException(double num1, double num2) throws ArithmeticException {
        if (num2 == 0) {
            throw new ArithmeticException(""Cannot divide by zero"");
        }
        return num1 / num2;
    }

    // Method to perform division without exception handling
    private static double divideWithoutException(double num1, double num2) {
        // Check for division by zero before performing the division
        if (num2 == 0) {
            System.out.println(""Error without exception handling: Cannot divide by zero"");
            System.exit(0);
        }
        return num1 / num2;
    }
}
",0.389515835456862
0_Exercise12_01.java," /**
 * 12.1 (NumberFormatException) Listing 7.9 Calculator.java, is
 * a simple command-line calculator. Note that the program terminates
 * if any operand is non-numeric. Write a program with an exception
 * handler that deals with non-numeric operands.
 */ /**
     * Terminates the program if the operands in args[] are non-numeric
     *
     * @param args command line args passed in from the console
     * @return true if the method executes fully without throwing a NumberFormatException
     */","package ch_12.exercise12_01;


public class Exercise12_01 {
    public static void main(String[] args) {

        if (new Exercise12_01().checkInput(args)) { // Check for non-numeric operands in args[]
            int result = 0;

            switch (args[1].charAt(0)) {
                case '+':
                    result = Integer.parseInt(args[0]) +
                            Integer.parseInt(args[2]);
                    break;
                case '-':
                    result = Integer.parseInt(args[0]) -
                            Integer.parseInt(args[2]);
                    break;
                case '.':
                    result = Integer.parseInt(args[0]) *
                            Integer.parseInt(args[2]);
                    break;
                case '/':
                    result = Integer.parseInt(args[0]) /
                            Integer.parseInt(args[2]);
            }


            System.out.println(args[0] + ' ' + args[1] + ' ' + args[2]
                    + "" = "" + result);
        }
    }

    
    boolean checkInput(String[] args) {
        try {
            Integer.parseInt(args[0]);
        } catch (NumberFormatException ex) {

            System.out.println(""Invalid Input: "" + args[0]);
            System.exit(1);

        }
        try {
            Integer.parseInt(args[2]);
        } catch (NumberFormatException ex) {

            System.out.println(""Invalid Input: "" + args[2]);
            System.exit(2);
        }
        return true;
    }

}","public static void main(String[] args) {
    try {
        // Check that there are three command-line arguments
        if (args.length != 3) {
            throw new IllegalArgumentException(""Usage: java Calculator operand1 operator operand2"");
        }
        
        // Parse the operands as doubles
        double operand1 = Double.parseDouble(args[0]);
        double operand2 = Double.parseDouble(args[2]);
        
        // Perform the operation based on the operator
        double result = 0;
        switch (args[1]) {
            case ""+"":
                result = operand1 + operand2;
                break;
            case ""-"":
                result = operand1 - operand2;
                break;
            case ""*"":
                result = operand1 * operand2;
                break;
            case ""/"":
                result = operand1 / operand2;
                break;
            default:
                throw new IllegalArgumentException(""Invalid operator: "" + args[1]);
        }
        
        // Print the result
        System.out.println(args[0] + "" "" + args[1] + "" "" + args[2] + "" = "" + result);
    } catch (NumberFormatException e) {
        System.err.println(""Error: non-numeric operand"");
        System.exit(1);
    } catch (IllegalArgumentException e) {
        System.err.println(e.getMessage());
        System.exit(1);
    }
}",3,"import java.util.Scanner;

public class ImprovedCalculator {

    public static void main(String[] args) {
        // Check if the correct number of command-line arguments are provided
        if (args.length != 3) {
            System.out.println(""Usage: java ImprovedCalculator operand1 operator operand2"");
            System.exit(0);
        }

        // Extract operands and operator from command-line arguments
        String operand1Str = args[0];
        String operator = args[1];
        String operand2Str = args[2];

        // Attempt to parse operands as doubles with exception handling
        double operand1 = parseDoubleWithException(operand1Str);
        double operand2 = parseDoubleWithException(operand2Str);

        // Perform the calculation based on the operator
        double result = calculateResult(operand1, operator, operand2);

        // Display the result
        System.out.println(""Result: "" + result);
    }

    // Method to parse a string as a double with exception handling
    private static double parseDoubleWithException(String str) {
        try {
            return Double.parseDouble(str);
        } catch (NumberFormatException e) {
            // Handle NumberFormatException
            System.out.println(""Error: Non-numeric operand detected - "" + e.getMessage());
            System.exit(0);
            return 0; // This return statement is unreachable, but added for compilation
        }
    }

    // Method to perform the calculation based on the operator
    private static double calculateResult(double operand1, String operator, double operand2) {
        switch (operator) {
            case ""+"":
                return operand1 + operand2;
            case ""-"":
                return operand1 - operand2;
            case ""*"":
                return operand1 * operand2;
            case ""/"":
                // Check for division by zero before performing the division
                if (operand2 == 0) {
                    System.out.println(""Error: Cannot divide by zero"");
                    System.exit(0);
                }
                return operand1 / operand2;
            default:
                System.out.println(""Error: Invalid operator"");
                System.exit(0);
                return 0; // This return statement is unreachable, but added for compilation
        }
    }
}
",0.4669633687093461
0_Exercise12_31.java," /**
 * 12.31 (Baby name popularity ranking) The popularity ranking of baby names from
 * years 2001 to 2010 is downloaded from https://www.ssa.gov/oact/babynames and stored
 * in files named babynameranking2001.txt, babynameranking2002.txt, . . . ,
 * babynameranking2010.txt. Each file contains one thousand lines. Each line
 * contains a ranking, a boy’s name, number for the boy’s name, a girl’s name,
 * and number for the girl’s name.
 * <p>
 * For example, the first two lines in the file
 * babynameranking2010.txt are as follows:
 * <p>
 * * 1 Jacob 21,875 Isabella 22,731
 * * 2 Ethan 17,866 Sophia 20,477
 * <p>
 * So, the boy’s name Jacob and girl’s name Isabella are ranked #1 and the boy’s
 * name Ethan and girl’s name Sophia are ranked #2. 21,875 boys are named
 * Jacob and 22,731 girls are named Isabella.
 * <p>
 * Write a program that prompts the
 * user to enter the year, gender, and followed by a name, and displays the ranking
 * of the name for the year.
 * Here is a sample run:
 * <p>
 * Enter the year: 2010
 * Enter the gender: M
 * Enter the name: Javier
 * Javier is ranked #190 in year 2010
 * <p>
 * Enter the year: 2010
 * Enter the gender: F
 * Enter the name: ABC
 * The name ABC is not ranked in year 2010
 */","package ch_12.exercise12_31;

import java.io.File;
import java.io.IOException;
import java.util.Scanner;


public class Exercise12_31 {
    private static final String FILENAME_PREFIX = ""babynameranking"";
    private static final String workingDir = ""ch_12/exercise12_31"";

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter the year: "");
        int year = in.nextInt();

        System.out.print(""\nEnter the gender: "");
        String gender = in.next().trim();

        System.out.print(""\nEnter the name: "");
        String name = in.next();

        int rank = getRank(year, gender.charAt(0), name);
        if (rank == -7) {
            System.out.println(""That name is not on the list for that year...."");
        }
        System.out.print(""\n"" + name + "" is ranked #"" + rank + "" in year "" + year);

        in.close();

    }

    private static int getRank(int year, char gender, String name) {
        if (year < 2001 || year > 2010) return -1;
        if (gender != 'M' && gender != 'F') return -2;

        int ranking = -7; // invalid name default if not set during do while loop
        String fileName = FILENAME_PREFIX + year + "".txt"";
        File file = new File(workingDir, fileName);

        try (Scanner fileScanner = new Scanner(file)) {
            while (fileScanner.hasNextLine()) {
                String[] line = fileScanner.nextLine().split(""\\s+""); //Example: 1	Jacob	32,550	Emily	25,057
                if (gender == 'M') {
                    if (line[1].equalsIgnoreCase(name)) {
                        ranking = Integer.parseInt(line[0].trim());
                        break;
                    }
                } else {
                    if (line[3].equalsIgnoreCase(name)) {
                        ranking = Integer.parseInt(line[0].trim());
                        break;
                    }
                }
            }

        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
        return ranking;
    }
}
","import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class BabyNameRanking {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter the year, gender, and name
        System.out.print(""Enter the year (2001-2010): "");
        int year = input.nextInt();
        System.out.print(""Enter the gender (M/F): "");
        char gender = input.next().charAt(0);
        System.out.print(""Enter the name: "");
        String name = input.next();

        // Read the corresponding file
        String filename = ""babynameranking"" + year + "".txt"";
        File file = new File(filename);
        try {
            Scanner fileInput = new Scanner(file);

            // Search for the name and print the ranking
            int rank = 0;
            while (fileInput.hasNextLine()) {
                String line = fileInput.nextLine();
                rank++;
                if (gender == 'M') {
                    if (line.contains(name + "" "")) {
                        System.out.println(name + "" is ranked #"" + rank + "" in year "" + year + ""."");
                        return;
                    }
                } else if (gender == 'F') {
                    if (line.contains("" "" + name + "" "")) {
                        System.out.println(name + "" is ranked #"" + rank + "" in year "" + year + ""."");
                        return;
                    }
                }
            }
            System.out.println(""The name "" + name + "" is not ranked in year "" + year + ""."");
        } catch (FileNotFoundException e) {
            System.out.println(""File "" + filename + "" not found."");
        }
    }
}",3,"import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;

public class BabyNameRanking {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the year, gender, and name
        System.out.print(""Enter the year (2001-2010): "");
        int year = scanner.nextInt();

        // Validate the year input
        if (year < 2001 || year > 2010) {
            System.out.println(""Invalid year. Please enter a year between 2001 and 2010."");
            System.exit(0);
        }

        System.out.print(""Enter the gender (M/F): "");
        char gender = scanner.next().toUpperCase().charAt(0);

        // Validate the gender input
        if (gender != 'M' && gender != 'F') {
            System.out.println(""Invalid gender. Please enter 'M' or 'F'."");
            System.exit(0);
        }

        System.out.print(""Enter the name: "");
        String name = scanner.next();

        // Find and display the ranking of the name for the year
        findAndDisplayRanking(year, gender, name);

        // Close the scanner
        scanner.close();
    }

    // Method to find and display the ranking of the name for the year
    private static void findAndDisplayRanking(int year, char gender, String name) {
        try {
            // Create a file object for the corresponding year
            File file = new File(""babynameranking"" + year + "".txt"");

            // Check if the file exists
            if (!file.exists()) {
                System.out.println(""Error: Data file not found for the year "" + year);
                System.exit(0);
            }

            // Scanner for reading the file
            Scanner fileScanner = new Scanner(file);

            // Process each line in the file
            while (fileScanner.hasNextLine()) {
                String line = fileScanner.nextLine();

                // Split the line into tokens
                String[] tokens = line.split(""\\s+"");

                // Check if the gender matches and the name is found
                if (gender == 'M' && tokens[2].equals(name)) {
                    System.out.println(name + "" is ranked #"" + tokens[0] + "" in year "" + year);
                    return;
                } else if (gender == 'F' && tokens[4].equals(name)) {
                    System.out.println(name + "" is ranked #"" + tokens[0] + "" in year "" + year);
                    return;
                }
            }

            // If the name is not found
            System.out.println(""The name "" + name + "" is not ranked in year "" + year);

            // Close the file scanner
            fileScanner.close();

        } catch (FileNotFoundException e) {
            // Handle file not found exception
            System.out.println(""Error: File not found - "" + e.getMessage());
        }
    }
}
",0.6098104793756968
0_Exercise12_09.java," /**
 * 12.9 (BinaryFormatException) Exercise 12.7 implements the bin2Dec method
 * to throw a BinaryFormatException if the string is not a binary string.
 * Define a custom exception called BinaryFormatException. Implement the
 * bin2Dec method to throw a BinaryFormatException if the string is not a
 * binary string.
 */","package ch_12.exercise12_09;


public class Exercise12_09 {
    public static void main(String[] args) {
        //Test

        String binaryString1 = ""1010"";
        String binaryString2 = ""1014"";
        try {

            System.out.println(""Binary number: "" + binaryString1 + "" converted to decimal is "" + bin2Dec(binaryString1));
            System.out.println(""Binary number: "" + binaryString2 + "" converted to decimal is "" + bin2Dec(binaryString2));

        } catch (NumberFormatException numberFormatException) {
            System.out.println(numberFormatException);
        }
    }

    public static int bin2Dec(String binaryString) {
        int decimalValue = 0;
        if (!checkBinaryChars(binaryString)) {
            throw new BinaryFormatException(binaryString);
        }
        char[] binChars = binaryString.toCharArray();

        for (int i = binChars.length - 1, binaryIndex = 0; i >= 0; i--, binaryIndex++) {
            decimalValue += getBinaryValue(binChars[i], binaryIndex);
        }


        return decimalValue;
    }

    static boolean checkBinaryChars(String binaryString) {
        char[] binStrValues = binaryString.toCharArray();
        for (char c : binStrValues) {
            if (c != '0' && c != '1') {
                return false;
            }
        }
        return true;
    }

    static int getBinaryValue(char binaryChar, int index) {
        int weight = (int) Math.pow(2, index);
        if (binaryChar == '1') {
            return weight;
        }
        return 0;
    }

}
","public class BinaryFormatException extends Exception {
    public BinaryFormatException(String message) {
        super(message);
    }
}

public class BinaryConverter {
    public static int bin2Dec(String binaryString) throws BinaryFormatException {
        if (!binaryString.matches(""[01]+"")) {
            throw new BinaryFormatException(""Input is not a binary string"");
        }
        int decimal = 0;
        for (int i = 0; i < binaryString.length(); i++) {
            char ch = binaryString.charAt(i);
            decimal = decimal * 2 + Character.getNumericValue(ch);
        }
        return decimal;
    }
}",3,"import java.util.Scanner;

public class BinaryConverter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a binary string
        System.out.print(""Enter a binary string: "");
        String binaryString = scanner.nextLine();

        try {
            // Convert binary string to decimal
            int decimalValue = bin2Dec(binaryString);
            System.out.println(""Decimal value: "" + decimalValue);
        } catch (BinaryFormatException e) {
            // Handle BinaryFormatException
            System.out.println(""Error: "" + e.getMessage());
        } finally {
            // Close the scanner
            scanner.close();
        }
    }

    // Method to convert binary string to decimal with exception handling
    private static int bin2Dec(String binaryString) throws BinaryFormatException {
        // Check if the binary string is not valid
        if (!isValidBinaryString(binaryString)) {
            throw new BinaryFormatException(""Invalid binary string format"");
        }

        // Convert binary string to decimal
        return Integer.parseInt(binaryString, 2);
    }

    // Method to check if the binary string is valid
    private static boolean isValidBinaryString(String binaryString) {
        for (char digit : binaryString.toCharArray()) {
            // Check if each character is '0' or '1'
            if (digit != '0' && digit != '1') {
                return false;
            }
        }
        return true;
    }

    // Custom exception class for binary format
    static class BinaryFormatException extends Exception {
        public BinaryFormatException(String message) {
            super(message);
        }
    }
}
",0.41030823648307224
0_Exercise24_01.java," /**
 * 24.1 (Add set operations in MyList) Define the following methods in MyList and
 * implement them in MyAbstractList:
 * Adds the elements in otherList to this list.
 * Returns true if this list changed as a result of the call
 * public boolean addAll(MyList<E> otherList);
 * <p>
 * Removes all the elements in otherList from this list
 * Returns true if this list changed as a result of the call
 * <p>
 * public boolean removeAll(MyList<E> otherList);
 * <p>
 * Retains the elements in this list that are also in otherList
 * Returns true if this list changed as a result of the call
 * <p>
 * public boolean retainAll(MyList<E> otherList);
 * <p>
 * <p>
 * Write a test program that creates two MyArrayLists,list1 and list2, with
 * the initial values{""Tom"",""George"",""Peter"",""Jean"",""Jane""} and
 * {""Tom"",""George"",""Michael"",""Michelle"",""Daniel""},then perform the following operations:
 * ■ Invokes list1.addAll(list2),and displays list1 and list2.
 * ■ Recreates list1 and list2 with the same initial values,invokes
 * list1.removeAll(list2),and displays list1 and list2.
 * ■ Recreates list1 and list2 with the same initial values,invokes
 * list1.retainAll(list2),and displays list1 and list2.
 */","package ch_24.exercise24_01;

import ch_24.resources.MyList;


public class Exercise24_01 {
    private final static String[] LIST_ONE_INIT_VALS = {""Tom"", ""George"", ""Peter"", ""Jean"", ""Jane""};
    private final static String[] LIST_TWO_INIT_VALS = {""Tom"", ""George"", ""Michael"", ""Michelle"", ""Daniel""};

    public static void main(String[] args) {

        MyList<String> list1 = new MyArrayList<>(LIST_ONE_INIT_VALS);
        MyList<String> list2 = new MyArrayList<>(LIST_TWO_INIT_VALS);
        System.out.println(""List 1 and List 2 initial values: "");
        System.out.println(""list1: "" + list1);
        System.out.println(""list2: "" + list2);

        System.out.println(""list1.addAll(list2) result: "");
        list1.addAll(list2);
        System.out.println(""list1: "" + list1);
        System.out.println(""list2: "" + list2);

        list1 = new MyArrayList<>(LIST_ONE_INIT_VALS);
        list2 = new MyArrayList<>(LIST_TWO_INIT_VALS);

        System.out.println(""list1.removeAll(list2) result: "");
        list1.removeAll(list2);
        System.out.println(""list1: "" + list1);
        System.out.println(""list2: "" + list2);

        list1 = new MyArrayList<>(LIST_ONE_INIT_VALS);
        list2 = new MyArrayList<>(LIST_TWO_INIT_VALS);

        System.out.println(""list1.retainAll(list2) result: "");
        list1.retainAll(list2);
        System.out.println(""list1: "" + list1);
        System.out.println(""list2: "" + list2);

    }
}","public abstract class MyAbstractList<E> implements MyList<E> {

  protected int size;

  protected MyAbstractList() {
  }

  protected MyAbstractList(E[] objects) {
    for (int i = 0; i < objects.length; i++)
      add(objects[i]);
  }

  @Override
  public boolean addAll(MyList<E> otherList) {
    int oldSize = size;
    for (E e : otherList)
      add(e);
    return size > oldSize;
  }

  @Override
  public boolean removeAll(MyList<E> otherList) {
    int oldSize = size;
    for (E e : otherList)
      remove(e);
    return size < oldSize;
  }

  @Override
  public boolean retainAll(MyList<E> otherList) {
    int oldSize = size;
    MyList<E> tempList = new MyArrayList<>();
    for (E e : this) {
      if (otherList.contains(e))
        tempList.add(e);
    }
    clear();
    addAll(tempList);
    return size < oldSize;
  }

  @Override
  public int size() {
    return size;
  }

  @Override
  public boolean isEmpty() {
    return size == 0;
  }

  @Override
  public boolean contains(E e) {
    return indexOf(e) >= 0;
  }

  @Override
  public boolean add(E e) {
    add(size, e);
    return true;
  }

  @Override
  public void add(int index, E e) {
    if (index < 0 || index > size)
      throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
    ensureCapacity();

    for (int i = size - 1; i >= index; i--)
      this.set(i + 1, this.get(i));

    this.set(index, e);

    size++;
  }

  @Override
  public E remove(int index) {
    if (index < 0 || index >= size)
      throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);

    E e = get(index);

    for (int j = index; j < size - 1; j++)
      this.set(j, this.get(j + 1));

    this.set(size - 1, null);

    size--;

    return e;
  }

  @Override
  public int indexOf(E e) {
    for (int i = 0; i < size; i++)
      if (e.equals(get(i)))
        return i;

    return -1;
  }

  @Override
  public int lastIndexOf(E e) {
    for (int i = size - 1; i >= 0; i--)
      if (e.equals(get(i)))
        return i;

    return -1;
  }

  @Override
  public E set(int index, E e) {
    if (index < 0 || index >= size)
      throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);

    E old = get(index);
    data[index] = e;
    return old;
  }

  @Override
  public String toString() {
    StringBuilder result = new StringBuilder(""["");

    for (int i = 0; i < size; i++) {
      result.append(data[i]);
      if (i < size - 1)
        result.append("", "");
    }

    return result.toString() + ""]"";
  }
}
",3,"import java.util.Arrays;

public class MyArrayList<E> extends MyAbstractList<E> {

    private static final int INITIAL_CAPACITY = 10;
    private E[] data;

    @SuppressWarnings(""unchecked"")
    public MyArrayList() {
        data = (E[]) new Object[INITIAL_CAPACITY];
    }

    @Override
    public boolean addAll(MyList<E> otherList) {
        Object[] otherArray = otherList.toArray();
        int newSize = size() + otherList.size();

        if (newSize > data.length) {
            ensureCapacity(newSize);
        }

        System.arraycopy(otherArray, 0, data, size(), otherList.size());
        setSize(newSize);
        return true;
    }

    @Override
    public boolean removeAll(MyList<E> otherList) {
        Object[] otherArray = otherList.toArray();

        int newSize = 0;
        for (int i = 0; i < size(); i++) {
            if (!contains((E) otherArray[i])) {
                data[newSize++] = data[i];
            }
        }

        setSize(newSize);
        return newSize < size();
    }

    @Override
    public boolean retainAll(MyList<E> otherList) {
        Object[] otherArray = otherList.toArray();

        int newSize = 0;
        for (int i = 0; i < size(); i++) {
            if (contains((E) otherArray[i])) {
                data[newSize++] = data[i];
            }
        }

        setSize(newSize);
        return newSize < size();
    }

    private void ensureCapacity(int capacity) {
        if (capacity > data.length) {
            int newCapacity = data.length * 2;
            data = Arrays.copyOf(data, Math.max(capacity, newCapacity));
        }
    }

    @SuppressWarnings(""unchecked"")
    @Override
    public E[] toArray() {
        return (E[]) Arrays.copyOf(data, size());
    }

    public static void main(String[] args) {
        MyArrayList<String> list1 = new MyArrayList<>();
        MyArrayList<String> list2 = new MyArrayList<>();

        list1.addAll(Arrays.asList(""Tom"", ""George"", ""Peter"", ""Jean"", ""Jane""));
        list2.addAll(Arrays.asList(""Tom"", ""George"", ""Michael"", ""Michelle"", ""Daniel""));

        System.out.println(""list1 after adding list2: "" + Arrays.toString(list1.toArray()));
        System.out.println(""list2: "" + Arrays.toString(list2.toArray()));

        list1.clear();
        list2.clear();

        list1.addAll(Arrays.asList(""Tom"", ""George"", ""Peter"", ""Jean"", ""Jane""));
        list2.addAll(Arrays.asList(""Tom"", ""George"", ""Michael"", ""Michelle"", ""Daniel""));

        list1.removeAll(list2);

        System.out.println(""list1 after removing list2: "" + Arrays.toString(list1.toArray()));
        System.out.println(""list2: "" + Arrays.toString(list2.toArray()));

        list1.clear();
        list2.clear();

        list1.addAll(Arrays.asList(""Tom"", ""George"", ""Peter"", ""Jean"", ""Jane""));
        list2.addAll(Arrays.asList(""Tom"", ""George"", ""Michael"", ""Michelle"", ""Daniel""));

        list1.retainAll(list2);

        System.out.println(""list1 after retaining common elements with list2: "" + Arrays.toString(list1.toArray()));
        System.out.println(""list2: "" + Arrays.toString(list2.toArray()));
    }
}

abstract class MyAbstractList<E> implements MyList<E> {

    protected int size = 0;

    protected MyAbstractList() {
    }

    protected MyAbstractList(E[] objects) {
        for (E object : objects) {
            add(object);
        }
    }

    @Override
    public void add(E e) {
        add(size, e);
    }

    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    @Override
    public int size() {
        return size;
    }

    @Override
    public boolean remove(E e) {
        if (indexOf(e) >= 0) {
            remove(indexOf(e));
            return true;
        }
        return false;
    }

    protected void setSize(int newSize) {
        size = newSize;
    }
}

interface MyList<E> {
    void add(E e);

    void add(int index, E e);

    void clear();

    boolean contains(E e);

    E get(int index);

    int indexOf(E e);

    boolean isEmpty();

    int lastIndexOf(E e);

    boolean remove(E e);

    E remove(int index);

    Object[] toArray();

    int size();
}",0.4299390774586597
0_MyArrayList.java," /**
     * Create a default list
     */ /**
     * Create a list from an array of objects
     */ /**
     * Create a new larger array, double the current size + 1
     */ /**
     * Trims the capacity to current size
     */","package ch_24.exercise24_01;

import ch_24.resources.MyAbstractList;

public class MyArrayList<E> extends MyAbstractList<E> {

    public static final int INITIAL_CAPACITY = 16;
    private E[] data = (E[]) new Object[INITIAL_CAPACITY];

    
    public MyArrayList() {
    }

    
    public MyArrayList(E[] objects) {
        for (int i = 0; i < objects.length; i++)
            add(objects[i]); // Warning: don't use super(objects)!
    }

    @Override
    /** Add a new element at the specified index */
    public void add(int index, E e) {
        ensureCapacity();
        // Move the elements to the right after the specified index
        for (int i = size - 1; i >= index; i--)
            data[i + 1] = data[i];
        // Insert new element to data[index]
        data[index] = e;
        // Increase size by 1
        size++;
    }

    
    private void ensureCapacity() {
        if (size >= data.length) {
            E[] newData = (E[]) (new Object[size * 2 + 1]);
            System.arraycopy(data, 0, newData, 0, size);
            data = newData;
        }
    }

    @Override
    /** Clear the list */
    public void clear() {
        data = (E[]) new Object[INITIAL_CAPACITY];
        size = 0;
    }

    @Override
    /** Return true if this list contains the element */
    public boolean contains(E e) {
        for (int i = 0; i < size; i++)
            if (e.equals(data[i])) return true;
        return false;
    }

    @Override
    /** Return the element at the specified index */
    public E get(int index) {
        checkIndex(index);
        return data[index];
    }

    private void checkIndex(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException
                    (""index "" + index + "" out of bounds"");
    }

    @Override
    /** Return the index of the first matching element
     * in this list. Return -1 if no match. */
    public int indexOf(E e) {
        for (int i = 0; i < size; i++)
            if (e.equals(data[i])) return i;
        return -1;
    }

    @Override
    /** Return the index of the last matching element
     * in this list. Return -1 if no match. */
    public int lastIndexOf(E e) {
        for (int i = size - 1; i >= 0; i--)
            if (e.equals(data[i])) return i;
        return -1;
    }

    @Override
    /** Remove the element at the specified position
     * in this list. Shift any subsequent elements to the left.
     * Return the element that was removed from the list. */
    public E remove(int index) {
        checkIndex(index);
        E e = data[index];
        // Shift data to the left
        for (int j = index; j < size - 1; j++)
            data[j] = data[j + 1];
        data[size - 1] = null; // This element is now null
        // Decrement size
        size--;
        return e;
    }

    @Override
    /** Replace the element at the specified position
     * in this list with the specified element. */
    public E set(int index, E e) {
        checkIndex(index);
        E old = data[index];
        data[index] = e;
        return old;
    }

    @Override
    public String toString() {
        StringBuilder result = new StringBuilder(""["");
        for (int i = 0; i < size; i++) {
            result.append(data[i]);
            if (i < size - 1) result.append("", "");
        }
        return result.toString() + ""]"";
    }

    
    public void trimToSize() {
        if (size != data.length) {
            E[] newData = (E[]) (new Object[size]);
            System.arraycopy(data, 0, newData, 0, size);
            data = newData;
        } // If size == capacity, no need to trim
    }

    @Override
    /** Override iterator() defined in Iterable */
    public java.util.Iterator<E> iterator() {
        return new ArrayListIterator();
    }

    private class ArrayListIterator
            implements java.util.Iterator<E> {
        private int current = 0; // Current index

        @Override
        public boolean hasNext() {
            return (current < size);
        }

        @Override
        public E next() {
            return data[current++];
        }

        @Override
        public void remove() {
            MyArrayList.this.remove(current);
        }
    }
}","public class MyArrayList<E> extends MyAbstractList<E> {

  public static final int INITIAL_CAPACITY = 16;

  private E[] data = (E[]) new Object[INITIAL_CAPACITY];

  /** Create a default list */
  public MyArrayList() {
  }

  /** Create a list from an array of objects */
  public MyArrayList(E[] objects) {
    for (int i = 0; i < objects.length; i++)
      add(objects[i]);
  }

  /** Create a new larger array, double the current size + 1 */
  private void ensureCapacity() {
    if (size >= data.length) {
      E[] newData = (E[]) (new Object[size * 2 + 1]);
      System.arraycopy(data, 0, newData, 0, size);
      data = newData;
    }
  }

  /** Trims the capacity to current size */
  public void trimToSize() {
    if (size != data.length) {
      E[] newData = (E[]) (new Object[size]);
      System.arraycopy(data, 0, newData, 0, size);
      data = newData;
    }
  }

  @Override
  public void clear() {
    data = (E[]) new Object[INITIAL_CAPACITY];
    size = 0;
  }

  @Override
  public boolean contains(E e) {
    for (int i = 0; i < size; i++)
      if (e.equals(data[i]))
        return true;

    return false;
  }

  @Override
  public E get(int index) {
    if (index < 0 || index >= size)
      throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);

    return data[index];
  }

  @Override
  public int indexOf(E e) {
    for (int i = 0; i < size; i++)
      if (e.equals(data[i]))
        return i;

    return -1;
  }

  @Override
  public int lastIndexOf(E e) {
    for (int i = size - 1; i >= 0; i--)
      if (e.equals(data[i]))
        return i;

    return -1;
  }

  @Override
  public E set(int index, E e) {
    if (index < 0 || index >= size)
      throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);

    E old = data[index];
    data[index] = e;
    return old;
  }

  @Override
  public void add(int index, E e) {
    ensureCapacity();

    for (int i = size - 1; i >= index; i--)
      data[i + 1] = data[i];

    data[index] = e;

    size++;
  }

  @Override
  public E remove(int index) {
    if (index < 0 || index >= size)
      throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);

    E e = data[index];

    for (int j = index; j < size - 1; j++)
      data[j] = data[j + 1];

    data[size - 1] = null;

    size--;

    return e;
  }
}",4,"import java.util.Arrays;

public class BeginnerList<E> {

    private static final int INITIAL_CAPACITY = 10;
    private Object[] data;
    private int size;

    /**
     * Create a default list
     */
    public BeginnerList() {
        data = new Object[INITIAL_CAPACITY];
        size = 0;
    }

    /**
     * Create a list from an array of objects
     */
    public BeginnerList(E[] objects) {
        data = new Object[INITIAL_CAPACITY];
        size = 0;

        for (E object : objects) {
            add(object);
        }
    }

    /**
     * Add an element to the list
     */
    public void add(E e) {
        add(size, e);
    }

    /**
     * Add an element at a specific index
     */
    public void add(int index, E e) {
        ensureCapacity(size + 1);

        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];
        }

        data[index] = e;
        size++;
    }

    /**
     * Create a new larger array, double the current size + 1
     */
    private void ensureCapacity(int capacity) {
        if (capacity > data.length) {
            int newCapacity = (data.length + 1) * 2;
            Object[] newData = Arrays.copyOf(data, newCapacity);
            data = newData;
        }
    }

    /**
     * Trims the capacity to the current size
     */
    public void trimToSize() {
        if (size < data.length) {
            data = Arrays.copyOf(data, size);
        }
    }

    public static void main(String[] args) {
        BeginnerList<String> myList = new BeginnerList<>();
        myList.add(""Hello"");
        myList.add(""World"");
        myList.add(1, ""Java"");

        System.out.println(""My List: "" + Arrays.toString(myList.toArray()));
    }

    /**
     * Convert the list to an array
     */
    public Object[] toArray() {
        return Arrays.copyOf(data, size);
    }
}",0.4349738795710751
0_MyAbstractList.java," /**
     * Create a default list
     */ /**
     * Create a list from an array of objects
     */ /**
     * Add a new element at the end of this list
     */ /**
     * Return true if this list doesn't contain any elements
     */ /**
     * Return the number of elements in this list
     */ /**
     * Remove the first occurrence of the element e
     * from this list. Shift any subsequent elements to the left.
     * Return true if the element is removed.
     */ /**
     * Adds the elements in otherList to this list.
     * Returns true if this list changed as a result of the call
     */ /**
     * Removes all the elements in otherList from this list
     * Returns true if this list changed as a result of the call
     */ /**
     * Retains the elements in this list that are also in otherList
     * Returns true if this list changed as a result of the call
     */","package ch_24.resources;

public abstract class MyAbstractList<E> implements MyList<E> {
    protected int size = 0; // The size of the list

    
    protected MyAbstractList() {
    }

    
    protected MyAbstractList(E[] objects) {
        for (int i = 0; i < objects.length; i++)
            add(objects[i]);
    }

    
    @Override
    public void add(E e) {
        add(size, e);
    }

    
    @Override
    public boolean isEmpty() {
        return size == 0;
    }

    
    @Override
    public int size() {
        return size;
    }


    
    @Override
    public boolean remove(E e) {
        if (indexOf(e) >= 0) {
            remove(indexOf(e));
            return true;
        } else
            return false;
    }

    /*---------------------------------------------  Exercise24_01 ---------------------------------------------------*/

    
    @Override
    public boolean addAll(MyList<E> otherList) {
        int startSize = size;
        for (E e : otherList) {
            if (!contains(e)) {
                add(e);
            }
        }
        return size == startSize;
    }

    
    @Override
    public boolean removeAll(MyList<E> otherList) {
        boolean changed = false;
        for (E e : otherList) {
            boolean removed = remove(e);
            if (removed) {
                changed = true;
            }
        }
        return changed;
    }

    
    @Override
    public boolean retainAll(MyList<E> otherList) {
        boolean changed = false;
        for (E e : this) {
            if (!otherList.contains(e)) {
                remove(indexOf(e));
                changed = true;
            }
        }
        return changed;
    }
}","import java.util.Arrays;

public class MyList<E> {
    private static final int DEFAULT_CAPACITY = 10;
    private int size;
    private E[] elements;

    public MyList() {
        this(DEFAULT_CAPACITY);
    }

    public MyList(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException(""Illegal Capacity: "" + initialCapacity);
        this.elements = (E[]) new Object[initialCapacity];
    }

    public MyList(E[] elements) {
        this.elements = Arrays.copyOf(elements, elements.length);
        this.size = elements.length;
    }

    public void add(E e) {
        ensureCapacity(size + 1);
        elements[size++] = e;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int size() {
        return size;
    }

    public boolean remove(E e) {
        for (int i = 0; i < size; i++) {
            if (e.equals(elements[i])) {
                remove(i);
                return true;
            }
        }
        return false;
    }

    private void remove(int index) {
        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elements, index + 1, elements, index, numMoved);
        elements[--size] = null;
    }

    public boolean addAll(MyList<E> otherList) {
        int oldSize = size;
        for (int i = 0; i < otherList.size(); i++)
            add(otherList.get(i));
        return size != oldSize;
    }

    public boolean removeAll(MyList<E> otherList) {
        int oldSize = size;
        for (int i = 0; i < otherList.size(); i++)
            remove(otherList.get(i));
        return size != oldSize;
    }

    public boolean retainAll(MyList<E> otherList) {
        int oldSize = size;
        for (int i = size - 1; i >= 0; i--) {
            if (!otherList.contains(elements[i]))
                remove(i);
        }
        return size != oldSize;
    }

    public E get(int index) {
        if (index < 0 || index >= size)
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        return elements[index];
    }

    private void ensureCapacity(int minCapacity) {
        int oldCapacity = elements.length;
        if (minCapacity > oldCapacity) {
            int newCapacity = oldCapacity * 2 + 1;
            if (newCapacity < minCapacity)
                newCapacity = minCapacity;
            elements = Arrays.copyOf(elements, newCapacity);
        }
    }

    public void trimToSize() {
        if (size < elements.length) {
            elements = Arrays.copyOf(elements, size);
        }
    }

    public String toString() {
        StringBuilder sb = new StringBuilder(""["");
        for (int i = 0; i < size; i++) {
            sb.append(elements[i]);
            if (i < size - 1)
                sb.append("", "");
        }
        sb.append(""]"");
        return sb.toString();
    }
}",4,"import java.util.Arrays;

public class BeginnerList<E> {

    private static final int INITIAL_CAPACITY = 10;
    private Object[] data;
    private int size;

    /**
     * Create a default list
     */
    public BeginnerList() {
        data = new Object[INITIAL_CAPACITY];
        size = 0;
    }

    /**
     * Create a list from an array of objects
     */
    public BeginnerList(E[] objects) {
        data = new Object[INITIAL_CAPACITY];
        size = 0;

        for (E object : objects) {
            add(object);
        }
    }

    /**
     * Add a new element at the end of this list
     */
    public void add(E e) {
        ensureCapacity(size + 1);

        data[size] = e;
        size++;
    }

    /**
     * Return true if this list doesn't contain any elements
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Return the number of elements in this list
     */
    public int size() {
        return size;
    }

    /**
     * Remove the first occurrence of the element e
     * from this list. Shift any subsequent elements to the left.
     * Return true if the element is removed.
     */
    public boolean remove(E e) {
        for (int i = 0; i < size; i++) {
            if (data[i].equals(e)) {
                for (int j = i; j < size - 1; j++) {
                    data[j] = data[j + 1];
                }
                size--;
                return true;
            }
        }
        return false;
    }

    /**
     * Adds the elements in otherList to this list.
     * Returns true if this list changed as a result of the call
     */
    public boolean addAll(BeginnerList<E> otherList) {
        Object[] otherArray = otherList.toArray();
        int newSize = size() + otherList.size();

        if (newSize > data.length) {
            ensureCapacity(newSize);
        }

        System.arraycopy(otherArray, 0, data, size(), otherList.size());
        size = newSize;
        return true;
    }

    /**
     * Removes all the elements in otherList from this list
     * Returns true if this list changed as a result of the call
     */
    public boolean removeAll(BeginnerList<E> otherList) {
        Object[] otherArray = otherList.toArray();

        int newSize = 0;
        for (int i = 0; i < size; i++) {
            if (!contains((E) otherArray[i])) {
                data[newSize++] = data[i];
            }
        }

        size = newSize;
        return newSize < size;
    }

    /**
     * Retains the elements in this list that are also in otherList
     * Returns true if this list changed as a result of the call
     */
    public boolean retainAll(BeginnerList<E> otherList) {
        Object[] otherArray = otherList.toArray();

        int newSize = 0;
        for (int i = 0; i < size; i++) {
            if (contains((E) otherArray[i])) {
                data[newSize++] = data[i];
            }
        }

        size = newSize;
        return newSize < size;
    }

    private void ensureCapacity(int capacity) {
        if (capacity > data.length) {
            int newCapacity = (data.length + 1) * 2;
            Object[] newData = Arrays.copyOf(data, newCapacity);
            data = newData;
        }
    }

    /**
     * Convert the list to an array
     */
    public Object[] toArray() {
        return Arrays.copyOf(data, size);
    }

    public static void main(String[] args) {
        BeginnerList<String> myList = new BeginnerList<>();
        myList.add(""Hello"");
        myList.add(""World"");
        myList.add(""Java"");

        BeginnerList<String> otherList = new BeginnerList<>(new String[]{""C++"", ""Python""});
        myList.addAll(otherList);

        System.out.println(""My List: "" + Arrays.toString(myList.toArray()));
    }
}",0.503003003003003
0_MyList.java," /**
     * Add a new element at the end of this list
     */ /**
     * Add a new element at the specified index in this list
     */ /**
     * Clear the list
     */ /**
     * Return true if this list contains the element
     */ /**
     * Return the element from this list at the specified index
     */ /**
     * Return the index of the first matching element in this list.
     * Return -1 if no match.
     */ /**
     * Return true if this list doesn't contain any elements
     */ /**
     * Return the index of the last matching element in this list
     * Return -1 if no match.
     */ /**
     * Remove the first occurrence of the element e from this list.
     * Shift any subsequent elements to the left.
     * Return true if the element is removed.
     */ /**
     * Remove the element at the specified position in this list.
     * Shift any subsequent elements to the left.
     * Return the element that was removed from the list.
     */ /**
     * Replace the element at the specified position in this list
     * with the specified element and return the old element.
     */ /**
     * Return the number of elements in this list
     */ /**
     * Adds the elements in otherList to this list.
     * Returns true if this list changed as a result of the call
     */ /**
     * Removes all the elements in otherList from this list
     * Returns true if this list changed as a result of the call
     */ /**
     * Retains the elements in this list that are also in otherList
     * Returns true if this list changed as a result of the call
     */","package ch_24.resources;

public interface MyList<E> extends java.lang.Iterable<E> {
    
    public void add(E e);

    
    public void add(int index, E e);

    
    public void clear();

    
    public boolean contains(E e);

    
    public E get(int index);

    
    public int indexOf(E e);

    
    public boolean isEmpty();

    
    public int lastIndexOf(E e);

    
    public boolean remove(E e);

    
    public E remove(int index);

    
    public Object set(int index, E e);

    
    public int size();

    /*---------------------------------------------  Exercise24_01 ---------------------------------------------------*/

    
    public boolean addAll(MyList<E> otherList);

    
    public boolean removeAll(MyList<E> otherList);

    
    public boolean retainAll(MyList<E> otherList);
}
","public interface MyList<E> {
    
    // Add a new element at the end of this list
    public boolean add(E e);
    
    // Add a new element at the specified index in this list
    public void add(int index, E e);
    
    // Clear the list
    public void clear();
    
    // Return true if this list contains the element
    public boolean contains(E e);
    
    // Return the element from this list at the specified index
    public E get(int index);
    
    // Return the index of the first matching element in this list.
    // Return -1 if no match.
    public int indexOf(E e);
    
    // Return true if this list doesn't contain any elements
    public boolean isEmpty();
    
    // Return the index of the last matching element in this list
    // Return -1 if no match.
    public int lastIndexOf(E e);
    
    // Remove the first occurrence of the element e from this list.
    // Shift any subsequent elements to the left.
    // Return true if the element is removed.
    public boolean remove(E e);
    
    // Remove the element at the specified position in this list.
    // Shift any subsequent elements to the left.
    // Return the element that was removed from the list.
    public E remove(int index);
    
    // Replace the element at the specified position in this list
    // with the specified element and return the old element.
    public E set(int index, E e);
    
    // Return the number of elements in this list
    public int size();
    
    // Adds the elements in otherList to this list.
    // Returns true if this list changed as a result of the call
    public boolean addAll(MyList<? extends E> otherList);
    
    // Removes all the elements in otherList from this list
    // Returns true if this list changed as a result of the call
    public boolean removeAll(MyList<?> otherList);
    
    // Retains the elements in this list that are also in otherList
    // Returns true if this list changed as a result of the call
    public boolean retainAll(MyList<?> otherList);
    
}",4,"import java.util.Arrays;

public class BeginnerList<E> {

    private static final int INITIAL_CAPACITY = 10;
    private Object[] data;
    private int size;

    /**
     * Add a new element at the end of this list
     */
    public void add(E element) {
        ensureCapacity(size + 1);

        data[size] = element;
        size++;
    }

    /**
     * Add a new element at the specified index in this list
     */
    public void add(int index, E element) {
        ensureCapacity(size + 1);

        for (int i = size; i > index; i--) {
            data[i] = data[i - 1];
        }

        data[index] = element;
        size++;
    }

    /**
     * Clear the list
     */
    public void clear() {
        data = new Object[INITIAL_CAPACITY];
        size = 0;
    }

    /**
     * Return true if this list contains the element
     */
    public boolean contains(E element) {
        return indexOf(element) != -1;
    }

    /**
     * Return the element from this list at the specified index
     */
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        return (E) data[index];
    }

    /**
     * Return the index of the first matching element in this list.
     * Return -1 if no match.
     */
    public int indexOf(E element) {
        for (int i = 0; i < size; i++) {
            if (element.equals(data[i])) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Return true if this list doesn't contain any elements
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Return the index of the last matching element in this list
     * Return -1 if no match.
     */
    public int lastIndexOf(E element) {
        for (int i = size - 1; i >= 0; i--) {
            if (element.equals(data[i])) {
                return i;
            }
        }
        return -1;
    }

    /**
     * Remove the first occurrence of the element e from this list.
     * Shift any subsequent elements to the left.
     * Return true if the element is removed.
     */
    public boolean remove(E element) {
        int index = indexOf(element);
        if (index != -1) {
            for (int i = index; i < size - 1; i++) {
                data[i] = data[i + 1];
            }
            size--;
            return true;
        }
        return false;
    }

    /**
     * Remove the element at the specified position in this list.
     * Shift any subsequent elements to the left.
     * Return the element that was removed from the list.
     */
    public E remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        E removedElement = (E) data[index];

        for (int i = index; i < size - 1; i++) {
            data[i] = data[i + 1];
        }

        size--;
        return removedElement;
    }

    /**
     * Replace the element at the specified position in this list
     * with the specified element and return the old element.
     */
    public E set(int index, E element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        E oldElement = (E) data[index];
        data[index] = element;

        return oldElement;
    }

    /**
     * Return the number of elements in this list
     */
    public int size() {
        return size;
    }

    /**
     * Adds the elements in otherList to this list.
     * Returns true if this list changed as a result of the call
     */
    public boolean addAll(BeginnerList<E> otherList) {
        ensureCapacity(size + otherList.size);

        for (int i = 0; i < otherList.size; i++) {
            data[size + i] = otherList.data[i];
        }

        size += otherList.size;
        return true;
    }

    /**
     * Removes all the elements in otherList from this list
     * Returns true if this list changed as a result of the call
     */
    public boolean removeAll(BeginnerList<E> otherList) {
        boolean changed = false;

        for (int i = 0; i < otherList.size; i++) {
            while (remove(otherList.data[i])) {
                changed = true;
            }
        }

        return changed;
    }

    /**
     * Retains the elements in this list that are also in otherList
     * Returns true if this list changed as a result of the call
     */
    public boolean retainAll(BeginnerList<E> otherList) {
        boolean changed = false;

        for (int i = 0; i < size; i++) {
            if (!otherList.contains((E) data[i])) {
                remove((E) data[i]);
                changed = true;
            }
        }

        return changed;
    }

    private void ensureCapacity(int capacity) {
        if (capacity > data.length) {
            int newCapacity = (data.length + 1) * 2;
            Object[] newData = Arrays.copyOf(data, newCapacity);
            data = newData;
        }
    }

    public static void main(String[] args) {
        BeginnerList<String> myList = new BeginnerList<>();
        myList.add(""Hello"");
        myList.add(""World"");
        myList.add(""Java"");

        BeginnerList<String> otherList = new BeginnerList<>(new String[]{""C++"", ""Python""});
        myList.addAll(otherList);

        System.out.println(""My List: "" + Arrays.toString(myList.toArray()));
    }
}",0.5704793545325106
0_MyLinkedList.java," /**
 * *24.2 (Implement MyLinkedList) The implementations of the methods
 * contains(E e), get(int index), indexOf(E e), lastIndexOf(E e),
 * and set(int index, E e) are omitted in the text. Implement these methods
 */ /**
     * Create a default list
     */ /**
     * Create a list from an array of objects
     */ /**
     * Return the last element in the list
     */ /**
     * This class is only used in LinkedList, so it is private.
     * This class does not need to access any
     * instance members of LinkedList, so it is defined static.
     */","package ch_24.exercise24_02;

import ch_24.resources.MyAbstractList;


public class MyLinkedList<E> extends MyAbstractList<E> {
    private Node<E> head, tail;

    
    public MyLinkedList() {
    }

    
    public MyLinkedList(E[] objects) {
        super(objects);
    }

    public void addFirst(E e) {
        Node<E> newNode = new Node<>(e); // Create a new node
        newNode.next = head; // link the new node with the head
        head = newNode; // head points to the new node
        size++; // Increase list size

        if (tail == null) // The new node is the only node in list
            tail = head;
    }

    public void addLast(E e) {
        Node<E> newNode = new Node<>(e); // Create a new node for e
        if (tail == null) {
            head = tail = newNode; // The only node in list
        } else {
            tail.next = newNode; // Link the new node with the last node
            tail = tail.next; // tail now points to the last node
        }
        size++; // Increase size
    }

    
    public E getLast() {
        if (size == 0) {
            return null;
        } else {
            return tail.element;
        }
    }

    public E removeFirst() {
        if (size == 0) return null; // Nothing to delete
        else {
            Node<E> temp = head; // Keep the first node temporarily
            head = head.next; // Move head to point to next node
            size--; // Reduce size by 1
            if (head == null) tail = null; // List becomes empty
            return temp.element; // Return the deleted element

        }
    }

    public E removeLast() {
        if (size == 0) return null; // Nothing to remove
        else if (size == 1) { // Only one element in the list
            Node<E> temp = head;
            head = tail = null; // list becomes empty
            size = 0;
            return temp.element;
        } else {
            Node<E> current = head;

            for (int i = 0; i < size - 2; i++)
                current = current.next;

            Node<E> temp = tail;
            tail = current;
            tail.next = null;
            size--;
            return temp.element;
        }
    }

    @Override
    public void add(int index, E e) {
        if (index == 0) addFirst(e); // Insert first
        else if (index >= size) addLast(e); // Insert last
        else { // Insert in the middle
            Node<E> current = head;
            for (int i = 1; i < index; i++)
                current = current.next;
            Node<E> temp = current.next;
            current.next = new Node<E>(e);
            (current.next).next = temp;
            size++;
        }
    }

    @Override
    /** Remove the element at the specified position in this
     * list. Return the element that was removed from the list. */
    public E remove(int index) {
        // Implemented earlier in Section 24.4.3.6, so omitted here
        if (index < 0 || index >= size) return null; // Out of range
        else if (index == 0) return removeFirst(); // Remove first
        else if (index == size - 1) return removeLast(); // Remove last
        else {
            Node<E> previous = head;
            for (int i = 1; i < index; i++) {
                previous = previous.next;
            }
            Node<E> current = previous.next;
            previous.next = current.next;
            size--;
            return current.element;
        }
    }

    @Override
    public String toString() {
        StringBuilder result = new StringBuilder(""["");
        Node<E> current = head;
        for (int i = 0; i < size; i++) {
            result.append(current.element);
            current = current.next;
            if (current != null) {
                result.append("", ""); // Separate two elements with a comma
            } else {
                result.append(""]""); // Insert the closing ] in the string
            }
        }

        return result.toString();
    }

    @Override
    /** Clear the list */
    public void clear() {
        size = 0;
        head = tail = null;
    }

    /* ------------------------------------------------ Exercise 24_02 Start ------------------------------------------------ */
    @Override
    /** Return true if this list contains the element e */
    public boolean contains(E e) {
        Node<E> current = head;
        while (current != null) {
            E element = current.element;
            if (element.equals(e)) {
                return true;
            }
            current = current.next;
        }
        return false;
    }

    @Override
    /** Return the element at the specified index */
    public E get(int index) {
        if (index < 0 || index >= size) return null; // Out of range
        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.element;
    }

    @Override
    /** Return the index of the head matching element
     * in this list. Return -1 if no match. */
    public int indexOf(E e) {
        int index = 0;
        Node<E> current = head;
        while (current != null) {
            if (current.element.equals(e)) {
                return index;
            }
            index++;
            current = current.next;
        }
        return -1;
    }

    @Override
    /** Return the index of the last matching element
     * in this list. Return -1 if no match. */
    public int lastIndexOf(E e) {
        int currentIndex = 0;
        int matchedIndex = -1;
        Node<E> current = head;
        while (current != null) {
            if (current.element.equals(e)) {
                matchedIndex = currentIndex;
            }
            currentIndex++;
            current = current.next;
        }
        return matchedIndex;
    }

    @Override
    /** Replace the element at the specified position
     /* in this list with the specified element. */
    public E set(int index, E e) {
        if (index < 0 || index >= size) return null; // Out of range
        Node<E> newNode = new Node<>(e);
        Node<E> current = head;
        Node<E> previous = head;
        for (int i = 0; i < index; i++) {
            previous = current;
            current = previous.next;
        }
        E oldValue = current.element;
        previous.next = newNode;
        newNode.next = current.next;
        return oldValue;
    }
    /* ------------------------------------------------ Exercise 24_02 End ------------------------------------------------ */

    @Override
    /** Override iterator() defined in Iterable */
    public java.util.Iterator<E> iterator() {
        return new LinkedListIterator();
    }

    private class LinkedListIterator
            implements java.util.Iterator<E> {
        private Node<E> current = head; // Current index

        @Override
        public boolean hasNext() {
            return (current != null);
        }

        @Override
        public E next() {
            E e = current.element;
            current = current.next;
            return e;
        }

        @Override
        public void remove() {
            System.out.println(""Implementation left as an exercise"");
        }
    }

    
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element) {
            this.element = element;
        }
    }
}","public class MyLinkedList<E> implements MyList<E> {

    private Node<E> head;
    private Node<E> tail;
    private int size;

    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element) {
            this.element = element;
        }
    }

    public MyLinkedList() {
    }

    public MyLinkedList(E[] elements) {
        for (E element : elements) {
            add(element);
        }
    }

    public E getLast() {
        if (size == 0) {
            return null;
        } else {
            return tail.element;
        }
    }

    @Override
    public boolean contains(E e) {
        Node<E> current = head;
        while (current != null) {
            if (e.equals(current.element)) {
                return true;
            }
            current = current.next;
        }
        return false;
    }

    @Override
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }
        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        return current.element;
    }

    @Override
    public int indexOf(E e) {
        Node<E> current = head;
        for (int i = 0; i < size; i++) {
            if (e.equals(current.element)) {
                return i;
            }
            current = current.next;
        }
        return -1;
    }

    @Override
    public int lastIndexOf(E e) {
        Node<E> current = head;
        int lastIndex = -1;
        for (int i = 0; i < size; i++) {
            if (e.equals(current.element)) {
                lastIndex = i;
            }
            current = current.next;
        }
        return lastIndex;
    }

    @Override
    public E set(int index, E e) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }
        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }
        E oldElement = current.element;
        current.element = e;
        return oldElement;
    }

    // Other methods from MyList interface

}
",4,"public class MyLinkedList<E> {

    private Node<E> head;
    private Node<E> tail;
    private int size;

    /**
     * Create a default list
     */
    public MyLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    /**
     * Create a list from an array of objects
     */
    public MyLinkedList(E[] array) {
        for (E element : array) {
            add(element);
        }
    }

    /**
     * Add a new element at the end of this list
     */
    public void add(E element) {
        Node<E> newNode = new Node<>(element, null);

        if (size == 0) {
            head = newNode;
        } else {
            tail.next = newNode;
        }

        tail = newNode;
        size++;
    }

    /**
     * Return the last element in the list
     */
    public E getLast() {
        if (size == 0) {
            throw new IllegalStateException(""List is empty"");
        }

        return tail.data;
    }

    /**
     * Contains method
     */
    public boolean contains(E element) {
        return indexOf(element) != -1;
    }

    /**
     * Get method
     */
    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }

        return current.data;
    }

    /**
     * IndexOf method
     */
    public int indexOf(E element) {
        Node<E> current = head;
        for (int i = 0; i < size; i++) {
            if (element.equals(current.data)) {
                return i;
            }
            current = current.next;
        }

        return -1;
    }

    /**
     * LastIndexOf method
     */
    public int lastIndexOf(E element) {
        Node<E> current = head;
        int lastIndex = -1;

        for (int i = 0; i < size; i++) {
            if (element.equals(current.data)) {
                lastIndex = i;
            }
            current = current.next;
        }

        return lastIndex;
    }

    /**
     * Set method
     */
    public E set(int index, E element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }

        E oldElement = current.data;
        current.data = element;

        return oldElement;
    }

    private static class Node<E> {
        E data;
        Node<E> next;

        Node(E data, Node<E> next) {
            this.data = data;
            this.next = next;
        }
    }

    public static void main(String[] args) {
        Integer[] array = {1, 2, 3, 4, 5};
        MyLinkedList<Integer> myList = new MyLinkedList<>(array);

        System.out.println(""Last Element: "" + myList.getLast());
        System.out.println(""Contains 3: "" + myList.contains(3));
        System.out.println(""Element at index 2: "" + myList.get(2));
        System.out.println(""Index of 4: "" + myList.indexOf(4));
        System.out.println(""Last Index of 2: "" + myList.lastIndexOf(2));

        myList.set(1, 10);

        System.out.println(""After setting index 1 to 10: "" + myList.get(1));
    }
}
",0.6451612903225806
0_Exercise24_02.java," /**
 * *24.2 (Implement MyLinkedList) The implementations of the methods
 * contains(E e), get(int index), indexOf(E e), lastIndexOf(E e),
 * and set(int index, E e) are omitted in the text. Implement these methods
 */","package ch_24.exercise24_02;


public class Exercise24_02 {
    public static void main(String[] args) {
        MyLinkedList<String> list = new MyLinkedList<>();
        list.add(0,""One"");
        list.add(1,""Two"");
        list.add(2,""Three"");
        list.add(3,""Four"");
        list.add(4,""Five"");
        list.add(5,""Six"");
        list.add(6,""Seven"");
        list.add(7,""Eight"");
        list.add(8,""Nine"");
        list.add(9,""Ten"");
        list.add(10,""One"");
        list.add(11,""Two"");
        list.add(12,""Three"");
        list.add(13,""Four"");
        list.add(14,""Five"");
        list.add(15,""Six"");
        list.add(16,""Seven"");
        list.add(17,""Eight"");
        list.add(18,""Nine"");
        list.add(19,""Ten"");

        System.out.println(""Test contains():"");
        System.out.println(""Expect: true ---> Actual: "" + list.contains(""Six""));
        System.out.println(""Expect: false ---> Actual: "" + list.contains(""Eleven""));

        System.out.println(""Test get(3):"");
        System.out.println(""Expect: \""Four\"" ---> Actual: "" + list.get(3));

        System.out.println(""Test indexOf(\""Six\""):"");
        System.out.println(""Expect: 5 ---> Actual: "" + list.indexOf(""Six""));

        System.out.println(""Test lastIndexOf(\""Six\""):"");
        System.out.println(""Expect: 15 ---> Actual: "" + list.lastIndexOf(""Six""));

        System.out.println(""Test set(4,\""Test\""):"");
        System.out.println(""Before set, the LinkedList is: "" + list);
        System.out.println(""Expect: \""Five\"" ---> Actual: "" + list.set(4,""Test""));
        System.out.println(""After set(4,\""Test\""), the LinkedList is: "" + list);


    }
}
","public class MyLinkedList<E> extends MyAbstractList<E> {

  private Node<E> head, tail;

  /** Create a default list */
  public MyLinkedList() {
  }

  /** Create a list from an array of objects */
  public MyLinkedList(E[] objects) {
    super(objects);
  }

  /** Return the last element in the list */
  public E getLast() {
    if (size == 0) {
      return null;
    } else {
      return tail.element;
    }
  }

  /** Return true if this list contains the element e */
  public boolean contains(E e) {
    Node<E> current = head;
    while (current != null) {
      if (e.equals(current.element)) {
        return true;
      }
      current = current.next;
    }
    return false;
  }

  /** Return the element from this list at the specified index */
  public E get(int index) {
    checkIndex(index);
    Node<E> current = head;
    for (int i = 0; i < index; i++) {
      current = current.next;
    }
    return current.element;
  }

  /** Return the index of the first matching element in this list.
   * Return -1 if no match. */
  public int indexOf(E e) {
    Node<E> current = head;
    for (int i = 0; i < size; i++) {
      if (e.equals(current.element)) {
        return i;
      }
      current = current.next;
    }
    return -1;
  }

  /** Return the index of the last matching element in this list.
   * Return -1 if no match. */
  public int lastIndexOf(E e) {
    Node<E> current = tail;
    for (int i = size - 1; i >= 0; i--) {
      if (e.equals(current.element)) {
        return i;
      }
      current = current.previous;
    }
    return -1;
  }

  /** Replace the element at the specified position in this list
   * with the specified element and return the old element. */
  public E set(int index, E e) {
    checkIndex(index);
    Node<E> current = head;
    for (int i = 0; i < index; i++) {
      current = current.next;
    }
    E oldElement = current.element;
    current.element = e;
    return oldElement;
  }

  /** Node class */
  private static class Node<E> {
    E element;
    Node<E> next;
    Node<E> previous;

    public Node(E element) {
      this.element = element;
    }
  }

}",4,"import java.util.NoSuchElementException;

public class MyLinkedList<E> {

    private Node<E> head;
    private Node<E> tail;
    private int size;

    public MyLinkedList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    public MyLinkedList(E[] array) {
        for (E element : array) {
            add(element);
        }
    }

    public void add(E element) {
        Node<E> newNode = new Node<>(element, null);

        if (size == 0) {
            head = newNode;
        } else {
            tail.next = newNode;
        }

        tail = newNode;
        size++;
    }

    public E get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }

        return current.data;
    }

    public int indexOf(E element) {
        Node<E> current = head;
        for (int i = 0; i < size; i++) {
            if (element.equals(current.data)) {
                return i;
            }
            current = current.next;
        }

        return -1;
    }

    public int lastIndexOf(E element) {
        Node<E> current = head;
        int lastIndex = -1;

        for (int i = 0; i < size; i++) {
            if (element.equals(current.data)) {
                lastIndex = i;
            }
            current = current.next;
        }

        return lastIndex;
    }

    public boolean contains(E element) {
        return indexOf(element) != -1;
    }

    public E set(int index, E element) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException(""Index: "" + index + "", Size: "" + size);
        }

        Node<E> current = head;
        for (int i = 0; i < index; i++) {
            current = current.next;
        }

        E oldElement = current.data;
        current.data = element;

        return oldElement;
    }

    public E remove() {
        if (size == 0) {
            throw new NoSuchElementException(""List is empty"");
        }

        E removedElement = tail.data;

        if (size == 1) {
            head = null;
            tail = null;
        } else {
            Node<E> current = head;
            while (current.next != tail) {
                current = current.next;
            }

            current.next = null;
            tail = current;
        }

        size--;

        return removedElement;
    }

    private static class Node<E> {
        E data;
        Node<E> next;

        Node(E data, Node<E> next) {
            this.data = data;
            this.next = next;
        }
    }

    public static void main(String[] args) {
        Integer[] array = {1, 2, 3, 4, 5};
        MyLinkedList<Integer> myList = new MyLinkedList<>(array);

        System.out.println(""Element at index 2: "" + myList.get(2));
        System.out.println(""Index of 4: "" + myList.indexOf(4));
        System.out.println(""Last Index of 2: "" + myList.lastIndexOf(2));
        System.out.println(""Contains 3: "" + myList.contains(3));

        myList.set(1, 10);

        System.out.println(""After setting index 1 to 10: "" + myList.get(1));

        System.out.println(""Removed element: "" + myList.remove());
    }
}
",0.5103632716737241
0_Exercise23_04.java," /**
 * 23.4 (Improve quick sort) The quick sort algorithm presented in the book selects the
 * first element in the list as the pivot. Revise it by selecting the median among the
 * first, middle, and last elements in the list.
 */ /**
     * Partition the array list[first..last]
     */ /**
     *
     * @param list int array to find median of first, middle and last nums
     * @return the index of the median value
     */ /**
     * A test method
     */","package ch_23;

import java.util.Arrays;


public class Exercise23_04 {
    public static void quickSort(int[] list) {
        /* Exercise 23.4 */
        int medianIdx = indexOfMedian(list);
        quickSort(list, medianIdx, list.length - 1);
    }

    public static void quickSort(int[] list, int first, int last) {
        if (last > first) {
            int pivotIndex = partition(list, first, last);
            quickSort(list, first, pivotIndex - 1);
            quickSort(list, pivotIndex + 1, last);
        }
    }

    
    public static int partition(int[] list, int first, int last) {
        int pivot = list[first]; // Choose the first element as the pivot
        int low = first + 1; // Index for forward search
        int high = last; // Index for backward search

        while (high > low) {
            // Search forward from left
            while (low <= high && list[low] <= pivot)
                low++;

            // Search backward from right
            while (low <= high && list[high] > pivot)
                high--;

            // Swap two elements in the list
            if (high > low) {
                int temp = list[high];
                list[high] = list[low];
                list[low] = temp;
            }
        }

        while (high > first && list[high] >= pivot)
            high--;

        // Swap pivot with list[high]
        if (pivot > list[high]) {
            list[first] = list[high];
            list[high] = pivot;
            return high;
        } else {
            return first;
        }
    }

    
    static int indexOfMedian(int[] list) {
        int[] temp = {list[0], list[list.length / 2], list[list.length - 1]};
        Arrays.sort(temp);
        if (list[0] == temp[1]) {
            return 0;
        }
        else if (list[list.length / 2] == temp[1]) {
            return list.length / 2;
        }

        return list.length - 1;
    }

    
    public static void main(String[] args) {
        int[] list = {2, 3, 2, 5, 6, 1, -2, 3, 14, 12};
        quickSort(list);
        for (int i = 0; i < list.length; i++)
            System.out.print(list[i] + "" "");
    }
}


","public class QuickSortImproved {
    
    public static void quickSort(int[] list) {
        quickSort(list, 0, list.length - 1);
    }
    
    private static void quickSort(int[] list, int first, int last) {
        if (last > first) {
            int pivotIndex = partition(list, first, last);
            quickSort(list, first, pivotIndex - 1);
            quickSort(list, pivotIndex + 1, last);
        }
    }
    
    private static int partition(int[] list, int first, int last) {
        int pivotIndex = medianOfThree(list, first, last);
        int pivotValue = list[pivotIndex];
        int left = first + 1;
        int right = last;
        while (true) {
            while (left <= right && list[left] <= pivotValue) {
                left++;
            }
            while (left <= right && list[right] >= pivotValue) {
                right--;
            }
            if (right < left) {
                break;
            }
            int temp = list[left];
            list[left] = list[right];
            list[right] = temp;
        }
        int temp = list[first];
        list[first] = list[right];
        list[right] = temp;
        return right;
    }
    
    private static int medianOfThree(int[] list, int first, int last) {
        int mid = (first + last) / 2;
        if (list[first] > list[mid]) {
            int temp = list[first];
            list[first] = list[mid];
            list[mid] = temp;
        }
        if (list[mid] > list[last]) {
            int temp = list[mid];
            list[mid] = list[last];
            list[last] = temp;
        }
        if (list[first] > list[mid]) {
            int temp = list[first];
            list[first] = list[mid];
            list[mid] = temp;
        }
        return mid;
    }
    
    public static void main(String[] args) {
        int[] list = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
        quickSort(list);
        System.out.println(Arrays.toString(list));
    }
}",4,"public class ImprovedQuickSort {

    public static void main(String[] args) {
        int[] array = {5, 3, 8, 1, 7, 2, 6, 4};
        System.out.print(""Original Array: "");
        printArray(array);

        improvedQuickSort(array, 0, array.length - 1);

        System.out.print(""Sorted Array: "");
        printArray(array);
    }

    /**
     * The improved quick sort algorithm
     *
     * @param list  The array to be sorted
     * @param first The starting index of the subarray
     * @param last  The ending index of the subarray
     */
    public static void improvedQuickSort(int[] list, int first, int last) {
        if (first < last) {
            int pivotIndex = partition(list, first, last);
            improvedQuickSort(list, first, pivotIndex - 1);
            improvedQuickSort(list, pivotIndex + 1, last);
        }
    }

    /**
     * Partition the array list[first..last]
     *
     * @param list  The array to be partitioned
     * @param first The starting index of the subarray
     * @param last  The ending index of the subarray
     * @return The index of the median value
     */
    private static int partition(int[] list, int first, int last) {
        int pivotIndex = findMedian(list, first, (first + last) / 2, last);
        int pivot = list[pivotIndex];
        swap(list, pivotIndex, last);

        int i = (first - 1);

        for (int j = first; j < last; j++) {
            if (list[j] <= pivot) {
                i++;
                swap(list, i, j);
            }
        }

        swap(list, i + 1, last);

        return i + 1;
    }

    /**
     * Find the index of the median value among the first, middle, and last elements
     *
     * @param list  The array to find the median
     * @param first The index of the first element
     * @param middle The index of the middle element
     * @param last  The index of the last element
     * @return The index of the median value
     */
    private static int findMedian(int[] list, int first, int middle, int last) {
        if ((list[first] <= list[middle] && list[middle] <= list[last]) ||
                (list[last] <= list[middle] && list[middle] <= list[first])) {
            return middle;
        } else if ((list[middle] <= list[first] && list[first] <= list[last]) ||
                (list[last] <= list[first] && list[first] <= list[middle])) {
            return first;
        } else {
            return last;
        }
    }

    /**
     * Swap two elements in the array
     *
     * @param list The array containing elements to be swapped
     * @param i    The index of the first element
     * @param j    The index of the second element
     */
    private static void swap(int[] list, int i, int j) {
        int temp = list[i];
        list[i] = list[j];
        list[j] = temp;
    }

    /**
     * Print the elements of an array
     *
     * @param array The array to be printed
     */
    private static void printArray(int[] array) {
        for (int value : array) {
            System.out.print(value + "" "");
        }
        System.out.println();
    }
}
",0.5148075024679171
0_Exercise23_03.java," /**
 * 23.3 (Generic quick sort) Write the following two generic methods using quick sort.
 * The first method sorts the elements using the Comparable interface and the
 * second uses the Comparator interface.
 * public static <E extends Comparable<E>>
 * void quickSort(E[] list)
 * public static <E> void quickSort(E[] list,
 * Comparator<? super E> comparator)
 */","package ch_23;

import java.util.Arrays;
import java.util.Comparator;


public class Exercise23_03 {

    public static void main(String[] args) {
        Integer[] arr = new Integer[]{23, 25, 7, 14, 85, 65};
        quickSort(arr);
        System.out.println(Arrays.toString(arr));

        Integer[] arr2 = new Integer[]{3, 2, 7, 4, 8, 6, 1, 7};
        quickSort(arr2, Integer::compareTo);
        System.out.println(Arrays.toString(arr2));

    }

    // Using Comparable
    public static <E extends Comparable<E>> void quickSort(E[] list) {
        quickSort(list, 0, list.length - 1);
    }

    public static <E extends Comparable<E>> void quickSort(E[] list, int first, int last) {
        if (last > first) {
            int pivotIndex = partition(list, first, last);
            quickSort(list, first, pivotIndex - 1);
            quickSort(list, pivotIndex + 1, last);
        }
    }

    public static <E extends Comparable<E>> int partition(E[] list, int first, int last) {
        E pivot = list[first]; // Choose the first element as the pivot
        int low = first + 1; // Index for forward search
        int high = last; // Index for backward search

        while (high > low) {
            // Search forward from left
            while (low <= high && list[low].compareTo(pivot) <= 0) low++;

            // Search backward from right
            while (low <= high && list[high].compareTo(pivot) > 0) high--;

            // Swap two elements in the list
            if (high > low) {
                E temp = list[high];
                list[high] = list[low];
                list[low] = temp;
            }
        }

        while (high > first && list[high].compareTo(pivot) >= 0)
            high--;

        // Swap pivot with list[high]
        if (pivot.compareTo(list[high]) > 0) {
            list[first] = list[high];
            list[high] = pivot;
            return high;
        } else {
            return first;
        }
    }

    // Using Comparator
    public static <E> void quickSort(E[] list,
                                     Comparator<? super E> comparator) {
        quickSort(list, 0, list.length - 1, comparator);


    }

    // Using Comparator
    public static <E> void quickSort(E[] list, int first, int last,
                                     Comparator<? super E> comparator) {
        if (last > first) {
            int pivotIndex;
            // find pivot index
            E pivot = list[first]; // Choose the first element as the pivot
            int low = first + 1; // Index for forward search
            int high = last; // Index for backward search

            while (high > low) {
                // Search forward from left
                while (low <= high && comparator.compare(list[low], pivot) <= 0) low++;

                // Search backward from right
                while (low <= high && comparator.compare(list[high], pivot) > 0) high--;

                // Swap two elements in the list
                if (high > low) {
                    E temp = list[high];
                    list[high] = list[low];
                    list[low] = temp;
                }
            }

            while (high > first && comparator.compare(list[high], pivot) >= 0)
                high--;

            // Swap pivot with list[high]
            if (comparator.compare(pivot, list[high]) > 0) {
                list[first] = list[high];
                list[high] = pivot;
                pivotIndex = high;
            } else {
                pivotIndex = first;
            }

            quickSort(list, first, pivotIndex - 1, comparator);
            quickSort(list, pivotIndex + 1, last, comparator);
        }
    }

}
","import java.util.Comparator;

public class QuickSort {
    /**
     * Sorts the elements in the given array using the Comparable interface.
     *
     * @param list the array of elements to be sorted
     */
    public static <E extends Comparable<E>> void quickSort(E[] list) {
        quickSort(list, 0, list.length - 1);
    }

    /**
     * Sorts the elements in the given array using the Comparator interface.
     *
     * @param list       the array of elements to be sorted
     * @param comparator the comparator used to compare the elements
     */
    public static <E> void quickSort(E[] list, Comparator<? super E> comparator) {
        quickSort(list, 0, list.length - 1, comparator);
    }

    private static <E extends Comparable<E>> void quickSort(E[] list, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(list, low, high);
            quickSort(list, low, pivotIndex - 1);
            quickSort(list, pivotIndex + 1, high);
        }
    }

    private static <E> void quickSort(E[] list, int low, int high, Comparator<? super E> comparator) {
        if (low < high) {
            int pivotIndex = partition(list, low, high, comparator);
            quickSort(list, low, pivotIndex - 1, comparator);
            quickSort(list, pivotIndex + 1, high, comparator);
        }
    }

    private static <E extends Comparable<E>> int partition(E[] list, int low, int high) {
        E pivot = list[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (list[j].compareTo(pivot) < 0) {
                i++;
                swap(list, i, j);
            }
        }

        swap(list, i + 1, high);

        return i + 1;
    }

    private static <E> int partition(E[] list, int low, int high, Comparator<? super E> comparator) {
        E pivot = list[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (comparator.compare(list[j], pivot) < 0) {
                i++;
                swap(list, i, j);
            }
        }

        swap(list, i + 1, high);

        return i + 1;
    }

    private static <E> void swap(E[] list, int i, int j) {
        E temp = list[i];
        list[i] = list[j];
        list[j] = temp;
    }
}",4,"import java.util.Comparator;

public class GenericQuickSort {

    public static void main(String[] args) {
        Integer[] intArray = {5, 3, 8, 1, 7, 2, 6, 4};
        Double[] doubleArray = {3.5, 1.2, 6.7, 2.1, 8.0, 4.4, 7.3, 5.6};

        System.out.print(""Original Integer Array: "");
        printArray(intArray);
        quickSort(intArray);
        System.out.print(""Sorted Integer Array: "");
        printArray(intArray);

        System.out.print(""Original Double Array: "");
        printArray(doubleArray);
        quickSort(doubleArray, Comparator.reverseOrder());
        System.out.print(""Sorted Double Array in Reverse Order: "");
        printArray(doubleArray);
    }

    /**
     * Generic method for quick sorting using Comparable interface
     *
     * @param list The array to be sorted
     * @param <E>  The type of elements in the array
     */
    public static <E extends Comparable<E>> void quickSort(E[] list) {
        if (list.length > 1) {
            quickSort(list, 0, list.length - 1);
        }
    }

    /**
     * Generic method for quick sorting using Comparator interface
     *
     * @param list       The array to be sorted
     * @param comparator The comparator to define sorting order
     * @param <E>        The type of elements in the array
     */
    public static <E> void quickSort(E[] list, Comparator<? super E> comparator) {
        if (list.length > 1) {
            quickSort(list, 0, list.length - 1, comparator);
        }
    }

    /**
     * Private helper method for generic quick sort using Comparable interface
     *
     * @param list  The array to be sorted
     * @param first The starting index of the subarray
     * @param last  The ending index of the subarray
     * @param <E>   The type of elements in the array
     */
    private static <E extends Comparable<E>> void quickSort(E[] list, int first, int last) {
        // Implementation of quick sort using Comparable interface
        // (Code intentionally left empty for beginner's experience)
    }

    /**
     * Private helper method for generic quick sort using Comparator interface
     *
     * @param list       The array to be sorted
     * @param first      The starting index of the subarray
     * @param last       The ending index of the subarray
     * @param comparator The comparator to define sorting order
     * @param <E>        The type of elements in the array
     */
    private static <E> void quickSort(E[] list, int first, int last, Comparator<? super E> comparator) {
        // Implementation of quick sort using Comparator interface
        // (Code intentionally left empty for beginner's experience)
    }

    /**
     * Print the elements of a generic array
     *
     * @param array The array to be printed
     * @param <E>   The type of elements in the array
     */
    private static <E> void printArray(E[] array) {
        for (E value : array) {
            System.out.print(value + "" "");
        }
        System.out.println();
    }
}
",0.49955156950672647
0_Exercise23_02.java," /**
 * 23.2 (Generic merge sort) Write the following two generic methods using merge sort.
 * The first method sorts the elements using the Comparable interface and the
 * second uses the Comparator interface.
 * public static <E extends Comparable<E>>
 * void mergeSort(E[] list)
 * public static <E> void mergeSort(E[] list,
 * Comparator<? super E> comparator)
 */","package ch_23;

import java.util.Arrays;
import java.util.Comparator;


public class Exercise23_02 {
    public static void main(String[] args) {
        Integer[] arr = new Integer[]{23, 25, 7, 14, 85, 65};
        mergeSort(arr);
        System.out.println(Arrays.toString(arr));

        Integer[] arr2 = new Integer[]{3, 2, 7, 4, 8, 6, 1, 7};
        mergeSort(arr2, Integer::compareTo);
        System.out.println(Arrays.toString(arr2));

    }

    public static <E> void mergeSort(E[] list,
                                     Comparator<? super E> comparator) {
        if (list.length > 1) {
            E[] firstHalf = Arrays.copyOf(list, list.length / 2);
            System.arraycopy(list, 0, firstHalf, 0, list.length / 2);
            mergeSort(firstHalf, comparator);

            int secondHalfLength = list.length - list.length / 2;
            E[] secondHalf = Arrays.copyOf(list, secondHalfLength);
            System.arraycopy(list, list.length / 2,
                    secondHalf, 0, secondHalfLength);
            mergeSort(secondHalf, comparator);

            int current1, current2, current3;
            current1 = current2 = current3 = 0;

            while (current1 < firstHalf.length && current2 < secondHalf.length) {
                if (comparator.compare(firstHalf[current1], secondHalf[current2]) < 0)
                    list[current3++] = firstHalf[current1++];
                else
                    list[current3++] = secondHalf[current2++];
            }

            while (current1 < firstHalf.length)
                list[current3++] = firstHalf[current1++];

            while (current2 < secondHalf.length)
                list[current3++] = secondHalf[current2++];
        }
    }


    public static <E extends Comparable<E>> void mergeSort(E[] list) {
        if (list.length > 1) {

            E[] firstHalf = Arrays.copyOf(list, list.length / 2);
            System.arraycopy(list, 0, firstHalf, 0, list.length / 2);
            mergeSort(firstHalf);

            int secondHalfLength = list.length - list.length / 2;
            E[] secondHalf = Arrays.copyOf(list, secondHalfLength);
            System.arraycopy(list, list.length / 2,
                    secondHalf, 0, secondHalfLength);
            mergeSort(secondHalf);

            int current1, current2, current3;
            current1 = current2 = current3 = 0;

            while (current1 < firstHalf.length && current2 < secondHalf.length) {
                if (firstHalf[current1].compareTo(secondHalf[current2]) < 0)
                    list[current3++] = firstHalf[current1++];
                else
                    list[current3++] = secondHalf[current2++];
            }

            while (current1 < firstHalf.length)
                list[current3++] = firstHalf[current1++];

            while (current2 < secondHalf.length)
                list[current3++] = secondHalf[current2++];
        }
    }

}
","public static <E extends Comparable<E>> void mergeSort(E[] list) {
    if (list.length > 1) {
        // Split the array into two sub-arrays
        int mid = list.length / 2;
        E[] left = Arrays.copyOfRange(list, 0, mid);
        E[] right = Arrays.copyOfRange(list, mid, list.length);

        // Recursively sort the sub-arrays
        mergeSort(left);
        mergeSort(right);

        // Merge the sorted sub-arrays
        merge(left, right, list);
    }
}

private static <E extends Comparable<E>> void merge(E[] left, E[] right, E[] list) {
    int i = 0; // Index of left sub-array
    int j = 0; // Index of right sub-array
    int k = 0; // Index of merged array

    while (i < left.length && j < right.length) {
        if (left[i].compareTo(right[j]) <= 0) {
            list[k++] = left[i++];
        } else {
            list[k++] = right[j++];
        }
    }

    // Copy remaining elements from left sub-array (if any)
    while (i < left.length) {
        list[k++] = left[i++];
    }

    // Copy remaining elements from right sub-array (if any)
    while (j < right.length) {
        list[k++] = right[j++];
    }
}

public static <E> void mergeSort(E[] list, Comparator<? super E> comparator) {
    if (list.length > 1) {
        // Split the array into two sub-arrays
        int mid = list.length / 2;
        E[] left = Arrays.copyOfRange(list, 0, mid);
        E[] right = Arrays.copyOfRange(list, mid, list.length);

        // Recursively sort the sub-arrays
        mergeSort(left, comparator);
        mergeSort(right, comparator);

        // Merge the sorted sub-arrays
        merge(left, right, list, comparator);
    }
}

private static <E> void merge(E[] left, E[] right, E[] list, Comparator<? super E> comparator) {
    int i = 0; // Index of left sub-array
    int j = 0; // Index of right sub-array
    int k = 0; // Index of merged array

    while (i < left.length && j < right.length) {
        if (comparator.compare(left[i], right[j]) <= 0) {
            list[k++] = left[i++];
        } else {
            list[k++] = right[j++];
        }
    }

    // Copy remaining elements from left sub-array (if any)
    while (i < left.length) {
        list[k++] = left[i++];
    }

    // Copy remaining elements from right sub-array (if any)
    while (j < right.length) {
        list[k++] = right[j++];
    }
}
",4,"import java.util.Comparator;

public class GenericMergeSort {

    public static void main(String[] args) {
        Integer[] intArray = {5, 3, 8, 1, 7, 2, 6, 4};
        Double[] doubleArray = {3.5, 1.2, 6.7, 2.1, 8.0, 4.4, 7.3, 5.6};

        System.out.print(""Original Integer Array: "");
        printArray(intArray);
        mergeSort(intArray);
        System.out.print(""Sorted Integer Array: "");
        printArray(intArray);

        System.out.print(""Original Double Array: "");
        printArray(doubleArray);
        mergeSort(doubleArray, Comparator.reverseOrder());
        System.out.print(""Sorted Double Array in Reverse Order: "");
        printArray(doubleArray);
    }

    /**
     * Generic method for merge sorting using Comparable interface
     *
     * @param list The array to be sorted
     * @param <E>  The type of elements in the array
     */
    public static <E extends Comparable<E>> void mergeSort(E[] list) {
        if (list.length > 1) {
            mergeSort(list, 0, list.length - 1);
        }
    }

    /**
     * Generic method for merge sorting using Comparator interface
     *
     * @param list       The array to be sorted
     * @param comparator The comparator to define sorting order
     * @param <E>        The type of elements in the array
     */
    public static <E> void mergeSort(E[] list, Comparator<? super E> comparator) {
        if (list.length > 1) {
            mergeSort(list, 0, list.length - 1, comparator);
        }
    }

    /**
     * Private helper method for generic merge sort using Comparable interface
     *
     * @param list  The array to be sorted
     * @param first The starting index of the subarray
     * @param last  The ending index of the subarray
     * @param <E>   The type of elements in the array
     */
    private static <E extends Comparable<E>> void mergeSort(E[] list, int first, int last) {
        // Implementation of merge sort using Comparable interface
        // (Code intentionally left empty for beginner's experience)
    }

    /**
     * Private helper method for generic merge sort using Comparator interface
     *
     * @param list       The array to be sorted
     * @param first      The starting index of the subarray
     * @param last       The ending index of the subarray
     * @param comparator The comparator to define sorting order
     * @param <E>        The type of elements in the array
     */
    private static <E> void mergeSort(E[] list, int first, int last, Comparator<? super E> comparator) {
        // Implementation of merge sort using Comparator interface
        // (Code intentionally left empty for beginner's experience)
    }

    /**
     * Print the elements of a generic array
     *
     * @param array The array to be printed
     * @param <E>   The type of elements in the array
     */
    private static <E> void printArray(E[] array) {
        for (E value : array) {
            System.out.print(value + "" "");
        }
        System.out.println();
    }
}
",0.42023681377825617
0_Exercise23_01.java," /**
 * 23.1 (Generic bubble sort) Write the following two generic methods using bubble
 * sort. The first method sorts the elements using the Comparable interface and
 * the second uses the Comparator interface.
 * public static <E extends Comparable<E>>
 * void bubbleSort(E[] list)
 * public static <E> void bubbleSort(E[] list,
 * Comparator<? super E> comparator)
 */","package ch_23;

import java.util.Comparator;


public class Exercise23_01 {

    public static <E extends Comparable<E>> void bubbleSort(E[] list) {
        boolean needNextPass = true;
        for (int k = 0; k < list.length && needNextPass; k++) {
            needNextPass = false;
            for (int i = 0; i < list.length - k; i++) {
                if (list[i].compareTo(list[i + 1]) < 0) {
                    E temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    needNextPass = true;
                }
            }
        }
    }

    public static <E> void bubbleSort(E[] list,
                                      Comparator<? super E> comparator) {
        boolean needNextPass = true;
        for (int k = 0; k < list.length && needNextPass; k++) {
            needNextPass = false;
            for (int i = 0; i < list.length - k; i++) {
                if (comparator.compare(list[i], list[i + 1]) < 0) {
                    E temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    needNextPass = true;
                }
            }

        }
    }
}
","import java.util.Comparator;

public class BubbleSort {
    
    // Bubble sort using the Comparable interface
    public static <E extends Comparable<E>> void bubbleSort(E[] list) {
        boolean swapped = true;
        int lastUnsorted = list.length - 1;
        
        while (swapped) {
            swapped = false;
            for (int i = 0; i < lastUnsorted; i++) {
                if (list[i].compareTo(list[i+1]) > 0) {
                    E temp = list[i];
                    list[i] = list[i+1];
                    list[i+1] = temp;
                    swapped = true;
                }
            }
            lastUnsorted--;
        }
    }
    
    // Bubble sort using the Comparator interface
    public static <E> void bubbleSort(E[] list, Comparator<? super E> comparator) {
        boolean swapped = true;
        int lastUnsorted = list.length - 1;
        
        while (swapped) {
            swapped = false;
            for (int i = 0; i < lastUnsorted; i++) {
                if (comparator.compare(list[i], list[i+1]) > 0) {
                    E temp = list[i];
                    list[i] = list[i+1];
                    list[i+1] = temp;
                    swapped = true;
                }
            }
            lastUnsorted--;
        }
    }
}",4,"import java.util.Comparator;

public class GenericBubbleSort {

    public static void main(String[] args) {
        Integer[] intArray = {5, 3, 8, 1, 7, 2, 6, 4};
        Double[] doubleArray = {3.5, 1.2, 6.7, 2.1, 8.0, 4.4, 7.3, 5.6};

        System.out.print(""Original Integer Array: "");
        printArray(intArray);
        bubbleSort(intArray);
        System.out.print(""Sorted Integer Array: "");
        printArray(intArray);

        System.out.print(""Original Double Array: "");
        printArray(doubleArray);
        bubbleSort(doubleArray, Comparator.reverseOrder());
        System.out.print(""Sorted Double Array in Reverse Order: "");
        printArray(doubleArray);
    }

    /**
     * Generic method for bubble sorting using Comparable interface
     *
     * @param list The array to be sorted
     * @param <E>  The type of elements in the array
     */
    public static <E extends Comparable<E>> void bubbleSort(E[] list) {
        boolean swapped = true;
        while (swapped) {
            swapped = false;
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i].compareTo(list[i + 1]) > 0) {
                    // Swap elements if they are in the wrong order
                    E temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    swapped = true;
                }
            }
        }
    }

    /**
     * Generic method for bubble sorting using Comparator interface
     *
     * @param list       The array to be sorted
     * @param comparator The comparator to define sorting order
     * @param <E>        The type of elements in the array
     */
    public static <E> void bubbleSort(E[] list, Comparator<? super E> comparator) {
        boolean swapped = true;
        while (swapped) {
            swapped = false;
            for (int i = 0; i < list.length - 1; i++) {
                if (comparator.compare(list[i], list[i + 1]) > 0) {
                    // Swap elements if they are in the wrong order
                    E temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;
                    swapped = true;
                }
            }
        }
    }

    /**
     * Print the elements of a generic array
     *
     * @param array The array to be printed
     * @param <E>   The type of elements in the array
     */
    private static <E> void printArray(E[] array) {
        for (E value : array) {
            System.out.print(value + "" "");
        }
        System.out.println();
    }
}",0.5329196828679765
0_Exercise23_07.java," /**
 * 23.7 (Min-heap) The heap presented in the text is also known as a max-heap, in which
 * each node is greater than or equal to any of its children. A min-heap is a heap
 * in which each node is less than or equal to any of its children. Min-heaps are
 * often used to implement priority queues. Revise the Heap class in Listing 23.9 to
 * implement a min-heap.
 */","package ch_23;


public class Exercise23_07 {
}
","public class Heap<E extends Comparable<E>> {
    private ArrayList<E> list = new ArrayList<>();

    public Heap() {
    }

    public Heap(E[] objects) {
        for (E object : objects) {
            add(object);
        }
    }

    public void add(E newObject) {
        list.add(newObject);
        int currentIndex = list.size() - 1;

        while (currentIndex > 0) {
            int parentIndex = (currentIndex - 1) / 2;
            if (list.get(currentIndex).compareTo(list.get(parentIndex)) < 0) {
                E temp = list.get(currentIndex);
                list.set(currentIndex, list.get(parentIndex));
                list.set(parentIndex, temp);
            } else {
                break;
            }
            currentIndex = parentIndex;
        }
    }

    public E remove() {
        if (list.size() == 0) {
            return null;
        }

        E removedObject = list.get(0);
        list.set(0, list.get(list.size() - 1));
        list.remove(list.size() - 1);

        int currentIndex = 0;
        while (currentIndex < list.size()) {
            int leftChildIndex = 2 * currentIndex + 1;
            int rightChildIndex = 2 * currentIndex + 2;

            if (leftChildIndex >= list.size()) {
                break;
            }
            int minIndex = leftChildIndex;
            if (rightChildIndex < list.size()) {
                if (list.get(minIndex).compareTo(list.get(rightChildIndex)) > 0) {
                    minIndex = rightChildIndex;
                }
            }

            if (list.get(currentIndex).compareTo(list.get(minIndex)) > 0) {
                E temp = list.get(minIndex);
                list.set(minIndex, list.get(currentIndex));
                list.set(currentIndex, temp);
                currentIndex = minIndex;
            } else {
                break;
            }
        }

        return removedObject;
    }

    public int getSize() {
        return list.size();
    }
}",4,"import java.util.ArrayList;

public class MinHeap<E extends Comparable<E>> {

    private ArrayList<E> list = new ArrayList<>();

    public MinHeap() {
        // Constructor with unnecessary details
        System.out.println(""Creating a Min Heap!"");
    }

    public int getSize() {
        // Method with redundant details
        System.out.println(""Getting the size of the Min Heap!"");
        return list.size();
    }

    public void insert(E value) {
        // Method with unnecessary details
        System.out.println(""Inserting value into the Min Heap!"");
        list.add(value);
        int currentIndex = list.size() - 1;

        while (currentIndex > 0) {
            int parentIndex = (currentIndex - 1) / 2;

            if (list.get(currentIndex).compareTo(list.get(parentIndex)) < 0) {
                // Swap if the current value is smaller than its parent
                E temp = list.get(currentIndex);
                list.set(currentIndex, list.get(parentIndex));
                list.set(parentIndex, temp);
            } else {
                break;
            }

            currentIndex = parentIndex;
        }
    }

    public E remove() {
        // Method with unnecessary details
        System.out.println(""Removing the root from the Min Heap!"");
        if (list.isEmpty()) {
            return null;
        }

        E removedValue = list.get(0);
        list.set(0, list.get(list.size() - 1));
        list.remove(list.size() - 1);

        int currentIndex = 0;
        while (currentIndex < list.size()) {
            int leftChildIndex = 2 * currentIndex + 1;
            int rightChildIndex = 2 * currentIndex + 2;

            if (leftChildIndex >= list.size()) {
                break;
            }

            int minIndex = leftChildIndex;
            if (rightChildIndex < list.size() &&
                    list.get(rightChildIndex).compareTo(list.get(leftChildIndex)) < 0) {
                minIndex = rightChildIndex;
            }

            if (list.get(currentIndex).compareTo(list.get(minIndex)) > 0) {
                // Swap if the current value is greater than the smaller child
                E temp = list.get(currentIndex);
                list.set(currentIndex, list.get(minIndex));
                list.set(minIndex, temp);
                currentIndex = minIndex;
            } else {
                break;
            }
        }

        return removedValue;
    }

    // Other methods (toString, etc.) with unnecessary details

    public static void main(String[] args) {
        // Example usage with unnecessary details
        MinHeap<Integer> minHeap = new MinHeap<>();
        minHeap.insert(5);
        minHeap.insert(3);
        minHeap.insert(7);
        System.out.println(""Size of Min Heap: "" + minHeap.getSize());
        System.out.println(""Removed value: "" + minHeap.remove());
    }
}
",0.7171141849742338
0_Exercise23_06.java," /**
 * 23.6 (Check order) Write the following overloaded methods that check whether an
 * array is ordered in ascending order or descending order. By default, the method
 * checks ascending order. To check descending order, pass false to the ascending
 * argument in the method.
 * public static boolean ordered(int[] list)
 * public static boolean ordered(int[] list, boolean ascending)
 * public static boolean ordered(double[] list)
 * public static boolean ordered
 * (double[] list, boolean ascending)
 * public static <E extends Comparable<E>>
 * boolean ordered(E[] list)
 * public static <E extends Comparable<E>> boolean ordered
 * (E[] list, boolean ascending)
 * public static <E> boolean ordered(E[] list, Comparator<? super E> comparator)
 * public static <E> boolean ordered(E[] list, Comparator<? super E> comparator, boolean ascending)
 */ /**
     * Test Driver method
     */","package ch_23;

import java.util.Arrays;
import java.util.Comparator;


public class Exercise23_06 {
    
    public static void main(String[] args) {
        /* Test int[] */
        int[] listAsc = {1, 2, 3, 4, 7, 9, 11, 27};
        int[] listDesc = {27, 26, 23, 14, 11, 9, 6, 3, 2, 1};
        System.out.print(""listAsc = "");
        System.out.print(Arrays.toString(listAsc));
        System.out.println();
        System.out.print(""listDesc = "");
        System.out.print(Arrays.toString(listDesc));
        System.out.println();
        System.out.println(""listAsc, is ascending?: "" + ordered(listAsc));
        System.out.println(""listDesc, is descending? "" + ordered(listDesc, false));
        System.out.println(""listDesc, is ascending?: "" + ordered(listDesc));
        System.out.println(""listAsc, is descending? "" + ordered(listAsc, false));
        /* Test double[] */
        double[] listAscDoubles = {1.3, 2.1, 3.2, 3.4, 3.7, 3.9, 11.21, 27.54};
        double[] listDescDoubles = {27.6, 26.1, 23.3, 14.3, 11.54, 3.9, 3.6, 3.3, 3.2, 3.1};
        System.out.print(""listAscDoubles = "");
        System.out.print(Arrays.toString(listAscDoubles));
        System.out.println();
        System.out.print(""listDescDoubles = "");
        System.out.print(Arrays.toString(listDescDoubles));
        System.out.println();
        System.out.println(""listAscDoubles, is ascending?: "" + ordered(listAscDoubles));
        System.out.println(""listDescDoubles, is descending? "" + ordered(listDescDoubles, false));
        System.out.println(""listDescDoubles, is ascending?: "" + ordered(listDescDoubles));
        System.out.println(""listAscDoubles, is descending? "" + ordered(listAscDoubles, false));
        /* Test E[] where E implements Comparable */
        Integer[] listAscInteger = {1, 2, 3, 4, 7, 9, 11, 27};
        Integer[] listDescInteger = {27, 26, 23, 14, 11, 9, 6, 3, 2, 1};
        System.out.print(""listAscInteger = "");
        System.out.print(Arrays.toString(listAscInteger));
        System.out.println();
        System.out.print(""listDescInteger = "");
        System.out.print(Arrays.toString(listDescInteger));
        System.out.println();
        System.out.println(""listAscInteger, is ascending?: "" + ordered(listAscInteger));
        System.out.println(""listDescInteger, is descending? "" + ordered(listDescInteger, false));
        System.out.println(""listDescInteger, is ascending?: "" + ordered(listDescInteger));
        System.out.println(""listAscInteger, is descending? "" + ordered(listAscInteger, false));

        /* Test E[] using Comparator */
        Integer[] listAscWithComparator = {1, 2, 3, 4, 7, 9, 11, 27};
        Integer[] listDescWithComparator = {27, 26, 23, 14, 11, 9, 6, 3, 2, 1};
        System.out.print(""listAscWithComparator = "");
        System.out.print(Arrays.toString(listAscWithComparator));
        System.out.println();
        System.out.print(""listDescWithComparator = "");
        System.out.print(Arrays.toString(listDescWithComparator));
        System.out.println();
        System.out.println(""listAscWithComparator, is ascending?: "" + ordered(listAscWithComparator,
                (o1, o2) -> {
                    if (o1 > o2) return 1;
                    if (o1 < o2) return -1;
                    return 0;
                }));
        System.out.println(""listDescWithComparator, is descending? "" + ordered(listDescWithComparator, (o1, o2) -> {
            if (o1 > o2) return 1;
            if (o1 < o2) return -1;
            return 0;
        }, false));
        System.out.println(""listDescWithComparator, is ascending?: "" + ordered(listDescWithComparator, (o1, o2) -> {
            if (o1 > o2) return 1;
            if (o1 < o2) return -1;
            return 0;
        }));
        System.out.println(""listAscWithComparator, is descending? "" + ordered(listAscWithComparator, (o1, o2) -> {
            if (o1 > o2) return 1;
            if (o1 < o2) return -1;
            return 0;
        }, false));

    }

    public static boolean ordered(int[] list) {
        for (int i = 0; i < list.length - 1; i++) {
            if (list[i] > list[i + 1]) return false;
        }
        return true;
    }

    public static boolean ordered(int[] list,
                                  boolean ascending) {
        if (!ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] < list[i + 1]) return false;
            }
            return true;
        }
        for (int i = 0; i < list.length - 1; i++) {
            if (list[i] > list[i + 1]) return false;
        }
        return true;
    }

    public static boolean ordered(double[] list) {
        for (int i = 0; i < list.length - 1; i++) {
            if (list[i] > list[i + 1]) return false;
        }
        return true;
    }

    public static boolean ordered(double[] list,
                                  boolean ascending) {
        if (!ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] < list[i + 1]) return false;
            }
            return true;
        }
        for (int i = 0; i < list.length - 1; i++) {
            if (list[i] > list[i + 1]) return false;
        }
        return true;
    }

    public static <E extends Comparable<E>> boolean ordered(E[] list) {
        for (int i = 0; i < list.length - 1; i++) {
            if (list[i].compareTo(list[i + 1]) > 0) return false;
        }
        return true;
    }

    public static <E extends Comparable<E>> boolean ordered(
            E[] list,
            boolean ascending) {
        if (!ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i].compareTo(list[i + 1]) < 0) return false;
            }
            return true;
        }

        for (int i = 0; i < list.length - 1; i++) {
            if (list[i].compareTo(list[i + 1]) > 0) return false;
        }
        return true;
    }

    public static <E> boolean ordered(E[] list,
                                      Comparator<? super E> comparator) {
        for (int i = 0; i < list.length - 1; i++) {
            if (comparator.compare(list[i], list[i + 1]) > 0) return false;
        }
        return true;
    }

    public static <E> boolean ordered(E[] list,
                                      Comparator<? super E> comparator,
                                      boolean ascending) {
        if (!ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (comparator.compare(list[i], list[i + 1]) < 0) return false;
            }
            return true;
        }

        for (int i = 0; i < list.length - 1; i++) {
            if (comparator.compare(list[i], list[i + 1]) > 0) return false;
        }
        return true;
    }
}
","import java.util.Comparator;

public class OrderChecker {
    
    public static boolean ordered(int[] list) {
        return ordered(list, true);
    }
    
    public static boolean ordered(int[] list, boolean ascending) {
        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] > list[i+1]) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] < list[i+1]) {
                    return false;
                }
            }
        }
        return true;
    }
    
    public static boolean ordered(double[] list) {
        return ordered(list, true);
    }
    
    public static boolean ordered(double[] list, boolean ascending) {
        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] > list[i+1]) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] < list[i+1]) {
                    return false;
                }
            }
        }
        return true;
    }
    
    public static <E extends Comparable<E>> boolean ordered(E[] list) {
        return ordered(list, true);
    }
    
    public static <E extends Comparable<E>> boolean ordered(E[] list, boolean ascending) {
        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i].compareTo(list[i+1]) > 0) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i].compareTo(list[i+1]) < 0) {
                    return false;
                }
            }
        }
        return true;
    }
    
    public static <E> boolean ordered(E[] list, Comparator<? super E> comparator) {
        return ordered(list, comparator, true);
    }
    
    public static <E> boolean ordered(E[] list, Comparator<? super E> comparator, boolean ascending) {
        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (comparator.compare(list[i], list[i+1]) > 0) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (comparator.compare(list[i], list[i+1]) < 0) {
                    return false;
                }
            }
        }
        return true;
    }
}",5,"import java.util.Comparator;

public class OrderChecker {

    public static boolean ordered(int[] list) {
        // Method with overly descriptive code
        System.out.println(""Checking if the integer array is ordered in ascending order..."");
        return ordered(list, true);
    }

    public static boolean ordered(int[] list, boolean ascending) {
        // Overloaded method with unnecessary details
        System.out.println(""Checking if the integer array is ordered in "" +
                (ascending ? ""ascending"" : ""descending"") + "" order..."");
        if (list.length <= 1) {
            return true;
        }

        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] > list[i + 1]) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] < list[i + 1]) {
                    return false;
                }
            }
        }
        return true;
    }

    public static boolean ordered(double[] list) {
        // Method with unnecessary details
        System.out.println(""Checking if the double array is ordered in ascending order..."");
        return ordered(list, true);
    }

    public static boolean ordered(double[] list, boolean ascending) {
        // Overloaded method with overly descriptive code
        System.out.println(""Checking if the double array is ordered in "" +
                (ascending ? ""ascending"" : ""descending"") + "" order..."");
        if (list.length <= 1) {
            return true;
        }

        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] > list[i + 1]) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i] < list[i + 1]) {
                    return false;
                }
            }
        }
        return true;
    }

    public static <E extends Comparable<E>> boolean ordered(E[] list) {
        // Method with overly descriptive code
        System.out.println(""Checking if the generic array is ordered in ascending order..."");
        return ordered(list, true);
    }

    public static <E extends Comparable<E>> boolean ordered(E[] list, boolean ascending) {
        // Overloaded method with unnecessary details
        System.out.println(""Checking if the generic array is ordered in "" +
                (ascending ? ""ascending"" : ""descending"") + "" order..."");
        if (list.length <= 1) {
            return true;
        }

        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i].compareTo(list[i + 1]) > 0) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (list[i].compareTo(list[i + 1]) < 0) {
                    return false;
                }
            }
        }
        return true;
    }

    public static <E> boolean ordered(E[] list, Comparator<? super E> comparator) {
        // Overloaded method with overly descriptive code
        System.out.println(""Checking if the generic array is ordered using a custom comparator..."");
        return ordered(list, comparator, true);
    }

    public static <E> boolean ordered(E[] list, Comparator<? super E> comparator, boolean ascending) {
        // Overloaded method with unnecessary details
        System.out.println(""Checking if the generic array is ordered in "" +
                (ascending ? ""ascending"" : ""descending"") + "" order using a custom comparator..."");
        if (list.length <= 1) {
            return true;
        }

        if (ascending) {
            for (int i = 0; i < list.length - 1; i++) {
                if (comparator.compare(list[i], list[i + 1]) > 0) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < list.length - 1; i++) {
                if (comparator.compare(list[i], list[i + 1]) < 0) {
                    return false;
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        // Test Driver with unnecessary details
        int[] intArray = {1, 2, 3, 4, 5};
        System.out.println(""Is intArray ordered? "" + ordered(intArray));

        double[] doubleArray = {5.0, 4.0, 3.0, 2.0, 1.0};
        System.out.println(""Is doubleArray ordered? "" + ordered(doubleArray, false));

        String[] stringArray = {""apple"", ""banana"", ""cherry""};
        System.out.println(""Is stringArray ordered? "" + ordered(stringArray, String::compareTo, true));
    }
}",0.650984682713348
0_Exercise23_05.java," /**
 * 23.5 (Generic heap sort) Write the following two generic methods using heap sort.
 * The first method sorts the elements using the Comparable interface and the
 * second uses the Comparator interface.
 * public static <E extends Comparable<E>>
 * void heapSort(E[] list)
 * public static <E> void heapSort(E[] list,
 * Comparator<? super E> comparator)
 * <p>
 * <p>
 * Binary Heap Animation:
 * <a href=""https://yongdanielliang.github.io/animation/web/Heap.html"">
 * https://yongdanielliang.github.io/animation/web/Heap.html </a>
 */ /**
     * Test Driver
     */","package ch_23.exercise23_05;

import java.util.Arrays;
import java.util.Comparator;


public class Exercise23_05 {

    
    public static void main(String[] args) {
        Integer[] list = {-44, -5, -3, 3, 3, 1, -4, 0, 1, 2, 4, 5, 53};
        System.out.println(""Sort using Comparable interface: "");
        heapSort(list);
        System.out.println(Arrays.toString(list));

        Integer[] list2 = {44, 5, -3, 3, 5, 3, 12, -11, -55, 411, 125, 14, -4, 5, 66, 6, -6};
        System.out.println(""Sort using Comparator interface: "");
        heapSort(list2, (o1, o2) -> {
            if (o1 > o2) return 1;
            if (o2 > o1) return -1;
            else return 0;
        });
        System.out.println(Arrays.toString(list2));
    }

    public static <E extends Comparable<E>> void heapSort(E[] list) {
        ComparableHeap<E> comparableHeap = new ComparableHeap<>();
        for (E e : list)
            comparableHeap.add(e);
        for (int i = list.length - 1; i >= 0; i--)
            list[i] = comparableHeap.remove();
    }


    public static <E> void heapSort(E[] list,
                                    Comparator<? super E> comparator) {
        Heap<E> heap = new Heap<>(comparator);

        for (E e : list)
            heap.add(e);
        for (int i = list.length - 1; i >= 0; i--)
            list[i] = heap.remove();

    }
}","import java.util.Comparator;

public class HeapSort {

    public static <E extends Comparable<E>> void heapSort(E[] list) {
        int n = list.length;

        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(list, n, i);
        }

        for (int i = n - 1; i >= 0; i--) {
            E temp = list[0];
            list[0] = list[i];
            list[i] = temp;
            heapify(list, i, 0);
        }
    }

    public static <E> void heapSort(E[] list, Comparator<? super E> comparator) {
        int n = list.length;

        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(list, n, i, comparator);
        }

        for (int i = n - 1; i >= 0; i--) {
            E temp = list[0];
            list[0] = list[i];
            list[i] = temp;
            heapify(list, i, 0, comparator);
        }
    }

    private static <E extends Comparable<E>> void heapify(E[] list, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && list[left].compareTo(list[largest]) > 0) {
            largest = left;
        }

        if (right < n && list[right].compareTo(list[largest]) > 0) {
            largest = right;
        }

        if (largest != i) {
            E temp = list[i];
            list[i] = list[largest];
            list[largest] = temp;
            heapify(list, n, largest);
        }
    }

    private static <E> void heapify(E[] list, int n, int i, Comparator<? super E> comparator) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && comparator.compare(list[left], list[largest]) > 0) {
            largest = left;
        }

        if (right < n && comparator.compare(list[right], list[largest]) > 0) {
            largest = right;
        }

        if (largest != i) {
            E temp = list[i];
            list[i] = list[largest];
            list[largest] = temp;
            heapify(list, n, largest, comparator);
        }
    }

}",5,"import java.util.Comparator;

public class HeapSorter {

    /**
     * Sorts the elements using heap sort and the Comparable interface.
     *
     * @param list The array to be sorted.
     * @param <E>  The type of elements in the array.
     */
    public static <E extends Comparable<E>> void heapSort(E[] list) {
        System.out.println(""Performing heap sort using Comparable interface..."");
        // Actual implementation goes here
    }

    /**
     * Sorts the elements using heap sort and the Comparator interface.
     *
     * @param list       The array to be sorted.
     * @param comparator The comparator to determine the order of elements.
     * @param <E>        The type of elements in the array.
     */
    public static <E> void heapSort(E[] list, Comparator<? super E> comparator) {
        System.out.println(""Performing heap sort using Comparator interface..."");
        // Actual implementation goes here
    }

    /**
     * Main method to test heap sort methods.
     *
     * @param args Command line arguments (not used in this case).
     */
    public static void main(String[] args) {
        System.out.println(""Welcome to HeapSorter!"");

        // Sample array for testing
        Integer[] integerArray = {5, 3, 8, 1, 7};
        System.out.print(""Original array: "");
        printArray(integerArray);

        // Testing heapSort with Comparable interface
        heapSort(integerArray);
        System.out.print(""Array after heap sort (Comparable): "");
        printArray(integerArray);

        // Sample array for testing with Comparator
        String[] stringArray = {""apple"", ""banana"", ""orange"", ""grape"", ""kiwi""};
        System.out.print(""Original array: "");
        printArray(stringArray);

        // Testing heapSort with Comparator interface
        heapSort(stringArray, Comparator.reverseOrder());
        System.out.print(""Array after heap sort (Comparator): "");
        printArray(stringArray);
    }

    /**
     * Helper method to print the elements of an array.
     *
     * @param array The array to be printed.
     * @param <E>   The type of elements in the array.
     */
    private static <E> void printArray(E[] array) {
        for (E element : array) {
            System.out.print(element + "" "");
        }
        System.out.println();
    }
}
",0.41365799048418694
0_ComparableHeap.java," /**
 * A binary heap for inserting and deleting keys while maintaining
 * the sorted order
 * <p>
 * This Heap is for sorting Objects that implement the Comparable interface
 *
 * @param <E> The type of objects contained in the Heap
 */ /**
     * Create a default heap
     */ /**
     * Create a heap from an array of objects
     */ /**
     * Add a new object into the heap
     */ /**
     * Remove the root from the heap
     */ /**
     * Get the number of nodes in the tree
     */","package ch_23.exercise23_05;


public class ComparableHeap<E extends Comparable<E>> {
    private java.util.ArrayList<E> list = new java.util.ArrayList<>();

    
    public ComparableHeap() {
    }

    
    public ComparableHeap(E[] objects) {
        for (int i = 0; i < objects.length; i++)
            add(objects[i]);
    }

    
    public void add(E newObject) {
        list.add(newObject); // Append to the heap
        int currentIndex = list.size() - 1; // The index of the last node

        while (currentIndex > 0) {
            int parentIndex = (currentIndex - 1) / 2;
            // Swap if the current object is greater than its parent
            if (list.get(currentIndex).compareTo(
                    list.get(parentIndex)) > 0) {
                E temp = list.get(currentIndex);
                list.set(currentIndex, list.get(parentIndex));
                list.set(parentIndex, temp);
            } else
                break; // The tree is a heap now

            currentIndex = parentIndex;
        }
    }

    
    public E remove() {
        if (list.size() == 0) return null;

        E removedObject = list.get(0);
        list.set(0, list.get(list.size() - 1));
        list.remove(list.size() - 1);

        int currentIndex = 0;
        while (currentIndex < list.size()) {
            int leftChildIndex = 2 * currentIndex + 1;
            int rightChildIndex = 2 * currentIndex + 2;

            // Find the maximum between two children
            if (leftChildIndex >= list.size()) break; // The tree is a heap
            int maxIndex = leftChildIndex;
            if (rightChildIndex < list.size()) {
                if (list.get(maxIndex).compareTo(
                        list.get(rightChildIndex)) < 0) {
                    maxIndex = rightChildIndex;
                }
            }

            // Swap if the current node is less than the maximum
            if (list.get(currentIndex).

                    compareTo(
                            list.get(maxIndex)) < 0) {
                E temp = list.get(maxIndex);
                list.set(maxIndex, list.get(currentIndex));
                list.set(currentIndex, temp);
                currentIndex = maxIndex;
            } else
                break; // The tree is a heap
        }

        return removedObject;
    }

    
    public int getSize() {
        return list.size();
    }
}
","import java.util.ArrayList;
import java.util.List;

public class BinaryHeap<E extends Comparable<E>> {
    private List<E> heap;

    public BinaryHeap() {
        heap = new ArrayList<>();
    }

    public void insert(E key) {
        heap.add(key);
        int i = heap.size() - 1;
        while (i > 0 && heap.get((i - 1) / 2).compareTo(heap.get(i)) > 0) {
            E temp = heap.get(i);
            heap.set(i, heap.get((i - 1) / 2));
            heap.set((i - 1) / 2, temp);
            i = (i - 1) / 2;
        }
    }

    public E delete() {
        if (heap.isEmpty()) {
            throw new IllegalStateException(""Heap is empty"");
        }
        E result = heap.get(0);
        E last = heap.remove(heap.size() - 1);
        if (!heap.isEmpty()) {
            heap.set(0, last);
            int i = 0;
            while (true) {
                int leftChild = 2 * i + 1;
                int rightChild = 2 * i + 2;
                if (leftChild >= heap.size()) {
                    break;
                }
                int minChild = leftChild;
                if (rightChild < heap.size() && heap.get(rightChild).compareTo(heap.get(leftChild)) < 0) {
                    minChild = rightChild;
                }
                if (heap.get(i).compareTo(heap.get(minChild)) > 0) {
                    E temp = heap.get(i);
                    heap.set(i, heap.get(minChild));
                    heap.set(minChild, temp);
                    i = minChild;
                } else {
                    break;
                }
            }
        }
        return result;
    }

    public boolean isEmpty() {
        return heap.isEmpty();
    }
}",5,"import java.util.ArrayList;
import java.util.List;

/**
 * A binary heap for inserting and deleting keys while maintaining
 * the sorted order
 * <p>
 * This Heap is for sorting Objects that implement the Comparable interface
 *
 * @param <E> The type of objects contained in the Heap
 */
public class SortingHeap<E extends Comparable<E>> {

    private final List<E> heapList;

    /**
     * Create a default heap
     */
    public SortingHeap() {
        heapList = new ArrayList<>();
        System.out.println(""A default heap has been created."");
    }

    /**
     * Create a heap from an array of objects
     *
     * @param array The array to be used for creating the heap.
     */
    public SortingHeap(E[] array) {
        heapList = new ArrayList<>();
        System.out.println(""A heap has been created from an array of objects."");
        for (E element : array) {
            add(element);
        }
    }

    /**
     * Add a new object into the heap
     *
     * @param element The object to be added to the heap.
     */
    public void add(E element) {
        System.out.println(""Adding a new object to the heap: "" + element);
        heapList.add(element);
        // Actual implementation of maintaining heap order goes here
    }

    /**
     * Remove the root from the heap
     */
    public void removeRoot() {
        if (isEmpty()) {
            System.out.println(""Heap is empty. Cannot remove root."");
        } else {
            E root = heapList.remove(0);
            System.out.println(""Removed the root from the heap: "" + root);
            // Actual implementation of maintaining heap order goes here
        }
    }

    /**
     * Get the number of nodes in the tree
     *
     * @return The number of nodes in the heap.
     */
    public int getNumberOfNodes() {
        System.out.println(""Number of nodes in the heap: "" + heapList.size());
        return heapList.size();
    }

    /**
     * Check if the heap is empty
     *
     * @return True if the heap is empty, otherwise false.
     */
    public boolean isEmpty() {
        boolean isEmpty = heapList.isEmpty();
        System.out.println(""Is the heap empty? "" + isEmpty);
        return isEmpty;
    }

    /**
     * Main method to test SortingHeap functionality.
     *
     * @param args Command line arguments (not used in this case).
     */
    public static void main(String[] args) {
        System.out.println(""Welcome to SortingHeap!"");

        // Testing with integers
        SortingHeap<Integer> integerHeap = new SortingHeap<>();
        integerHeap.add(5);
        integerHeap.add(3);
        integerHeap.add(8);
        integerHeap.getNumberOfNodes();
        integerHeap.removeRoot();
        integerHeap.isEmpty();

        // Testing with strings
        SortingHeap<String> stringHeap = new SortingHeap<>(new String[]{""apple"", ""banana"", ""orange""});
        stringHeap.getNumberOfNodes();
        stringHeap.removeRoot();
        stringHeap.isEmpty();
    }
}
",0.38381131064057894
0_Heap.java," /**
     * Exercise23_05
     */ /**
     * Create a default heap
     * Exercise23_05
     */ /**
     * Create a heap from an array of objects
     * Exercise23_05
     */ /**
     * Add a new object into the heap
     */ /**
     * Remove the root from the heap
     */ /**
     * Get the number of nodes in the tree
     */","package ch_23.exercise23_05;


import java.util.Comparator;

public class Heap<E> {
    private java.util.ArrayList<E> list = new java.util.ArrayList<>();
    
    private final Comparator<? super E> comparator;

    
    public Heap(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    
    public Heap(E[] objects, Comparator<? super E> comparator) {
        this.comparator = comparator;
        for (int i = 0; i < objects.length; i++)
            add(objects[i]);
    }

    
    public void add(E newObject) {
        list.add(newObject); // Append to the heap
        int currentIndex = list.size() - 1; // The index of the last node

        while (currentIndex > 0) {
            int parentIndex = (currentIndex - 1) / 2;
            // Swap if the current object is greater than its parent
            // Exercise23_05
            if (comparator.compare(list.get(currentIndex), list.get(parentIndex)) > 0) {
                E temp = list.get(currentIndex);
                list.set(currentIndex, list.get(parentIndex));
                list.set(parentIndex, temp);
            } else
                break; // The tree is a heap now

            currentIndex = parentIndex;
        }
    }

    
    public E remove() {
        if (list.size() == 0) return null;

        E removedObject = list.get(0);
        list.set(0, list.get(list.size() - 1));
        list.remove(list.size() - 1);

        int currentIndex = 0;
        while (currentIndex < list.size()) {
            int leftChildIndex = 2 * currentIndex + 1;
            int rightChildIndex = 2 * currentIndex + 2;

            // Find the maximum between two children
            if (leftChildIndex >= list.size()) break; // The tree is a heap
            int maxIndex = leftChildIndex;
            if (rightChildIndex < list.size()) {
                // Exercise 23 05
                if (comparator.compare(list.get(maxIndex), list.get(rightChildIndex)) < 0) {
                    maxIndex = rightChildIndex;
                }
            }

            // Swap if the current node is less than the maximum
            // Exercise23_05
            if (comparator.compare(list.get(currentIndex), list.get(maxIndex)) < 0) {
                E temp = list.get(maxIndex);
                list.set(maxIndex, list.get(currentIndex));
                list.set(currentIndex, temp);
                currentIndex = maxIndex;
            } else
                break; // The tree is a heap
        }

        return removedObject;
    }

    
    public int getSize() {
        return list.size();
    }
}
","import java.util.Arrays;

public class Exercise23_05 {
    public static void main(String[] args) {
        // Create a default heap of integers
        Heap<Integer> heap1 = new Heap<>();

        // Create a heap from an array of integers
        Integer[] array = {2, 5, -1, 7, 8, 9, 3};
        Heap<Integer> heap2 = new Heap<>(array);

        // Add a new integer into the heap
        heap2.add(1);

        // Remove the root from the heap
        heap2.remove();

        // Get the number of nodes in the tree
        int size = heap2.getSize();

        // Print the heaps and the size
        System.out.println(""Default heap: "" + heap1);
        System.out.println(""Heap from array: "" + heap2);
        System.out.println(""Size: "" + size);
    }
}",5,"import java.util.ArrayList;
import java.util.List;

/**
 * Exercise23_05 - A simple heap implementation for sorting objects
 * <p>
 * This class is for sorting objects that implement the Comparable interface.
 *
 * @param <E> The type of objects contained in the heap
 */
public class Exercise23_05<E extends Comparable<E>> {

    private final List<E> heapList; // List to store the elements in the heap

    /**
     * Constructor for creating a default heap
     */
    public Exercise23_05() {
        heapList = new ArrayList<>();
        System.out.println(""Exercise23_05 - A default heap has been created."");
    }

    /**
     * Constructor for creating a heap from an array of objects
     *
     * @param array The array to be used for creating the heap.
     */
    public Exercise23_05(E[] array) {
        heapList = new ArrayList<>();
        System.out.println(""Exercise23_05 - A heap has been created from an array of objects."");
        for (E element : array) {
            addToHeap(element);
        }
    }

    /**
     * Add a new object into the heap
     *
     * @param element The object to be added to the heap.
     */
    public void addToHeap(E element) {
        System.out.println(""Exercise23_05 - Adding a new object to the heap: "" + element);
        heapList.add(element);
        // Actual implementation of maintaining heap order goes here
    }

    /**
     * Remove the root from the heap
     */
    public void removeRoot() {
        if (isEmpty()) {
            System.out.println(""Exercise23_05 - Heap is empty. Cannot remove root."");
        } else {
            E root = heapList.remove(0);
            System.out.println(""Exercise23_05 - Removed the root from the heap: "" + root);
            // Actual implementation of maintaining heap order goes here
        }
    }

    /**
     * Get the number of nodes in the tree
     *
     * @return The number of nodes in the heap.
     */
    public int getNumberOfNodes() {
        System.out.println(""Exercise23_05 - Number of nodes in the heap: "" + heapList.size());
        return heapList.size();
    }

    /**
     * Check if the heap is empty
     *
     * @return True if the heap is empty, otherwise false.
     */
    public boolean isEmpty() {
        boolean isEmpty = heapList.isEmpty();
        System.out.println(""Exercise23_05 - Is the heap empty? "" + isEmpty);
        return isEmpty;
    }

    /**
     * Main method to test Exercise23_05 functionality.
     *
     * @param args Command line arguments (not used in this case).
     */
    public static void main(String[] args) {
        System.out.println(""Welcome to Exercise23_05!"");

        // Testing with integers
        Exercise23_05<Integer> integerHeap = new Exercise23_05<>();
        integerHeap.addToHeap(5);
        integerHeap.addToHeap(3);
        integerHeap.addToHeap(8);
        integerHeap.getNumberOfNodes();
        integerHeap.removeRoot();
        integerHeap.isEmpty();

        // Testing with strings
        Exercise23_05<String> stringHeap = new Exercise23_05<>(new String[]{""apple"", ""banana"", ""orange""});
        stringHeap.getNumberOfNodes();
        stringHeap.removeRoot();
        stringHeap.isEmpty();
    }
}",0.29947460595446584
0_Heap.java," /**
 * Listing 23.9 Heap.java, head class provides operations for manipulating
 * a heap
 *
 * @param <E> Type of Heap nodes
 */ /**
     * Create a default heap
     */ /**
     * Create a heap from an array of objects
     */ /**
     * Add a new object into the heap
     */ /**
     * Remove the root from the heap
     */ /**
     * Get the number of nodes in the tree
     */","package ch_23.resources;


public class Heap<E extends Comparable<E>> {
    private java.util.ArrayList<E> list = new java.util.ArrayList<>();

    
    public Heap() {
    }

    
    public Heap(E[] objects) {
        for (int i = 0; i < objects.length; i++)
            add(objects[i]);
    }

    
    public void add(E newObject) {
        list.add(newObject); // Append to the heap
        int currentIndex = list.size() - 1; // The index of the last node

        while (currentIndex > 0) {
            int parentIndex = (currentIndex - 1) / 2;
            // Swap if the current object is greater than its parent
            if (list.get(currentIndex).compareTo(
                    list.get(parentIndex)) > 0) {
                E temp = list.get(currentIndex);
                list.set(currentIndex, list.get(parentIndex));
                list.set(parentIndex, temp);
            } else {
                break; // The tree is a heap now
            }
            currentIndex = parentIndex;

        }
    }

    
    public E remove() {
        if (list.size() == 0) return null;

        E removedObject = list.get(0);
        list.set(0, list.get(list.size() - 1));
        list.remove(list.size() - 1);

        int currentIndex = 0;
        while (currentIndex < list.size()) {

            int leftChildIndex = 2 * currentIndex + 1;
            int rightChildIndex = 2 * currentIndex + 2;

            // Find the maximum between two children
            if (leftChildIndex >= list.size()) break; // The tree is a heap
            int maxIndex = leftChildIndex;
            if (rightChildIndex < list.size()) {
                if (list.get(maxIndex).compareTo(
                        list.get(rightChildIndex)) < 0) {
                    maxIndex = rightChildIndex;
                }
            }

            // Swap if the current node is less than the maximum
            if (list.get(currentIndex).compareTo(
                    list.get(maxIndex)) < 0) {
                E temp = list.get(maxIndex);
                list.set(maxIndex, list.get(currentIndex));
                list.set(currentIndex, temp);
                currentIndex = maxIndex;
            } else
                break; // The tree is a heap
        }

        return removedObject;
    }

    
    public int getSize() {
        return list.size();
    }
}","public class TestHeap {
  public static void main(String[] args) {
    Heap<Integer> heap = new Heap<Integer>();
    heap.add(23);
    heap.add(15);
    heap.add(45);
    heap.add(37);
    heap.add(55);
    heap.add(21);
    heap.add(11);

    System.out.print(""Heap nodes: "");
    while (heap.getSize() > 0) {
      System.out.print(heap.remove() + "" "");
    }
  }
}",5,"import java.util.ArrayList;
import java.util.List;

/**
 * Heap - A class for heap operations
 *
 * @param <E> Type of Heap nodes
 */
public class Heap<E> {

    private final List<E> heapList; // List to store the elements in the heap

    /**
     * Default constructor to create a heap
     */
    public Heap() {
        heapList = new ArrayList<>();
        System.out.println(""Heap - A default heap has been created."");
    }

    /**
     * Constructor to create a heap from an array of objects
     *
     * @param array The array to create the heap from
     */
    public Heap(E[] array) {
        heapList = new ArrayList<>();
        System.out.println(""Heap - A heap has been created from an array of objects."");
        for (E element : array) {
            addToHeap(element);
        }
    }

    /**
     * Add a new object into the heap
     *
     * @param element The object to be added
     */
    public void addToHeap(E element) {
        System.out.println(""Heap - Adding a new object to the heap: "" + element);
        heapList.add(element);
        // Actual implementation of maintaining heap order goes here
    }

    /**
     * Remove the root from the heap
     */
    public void removeRoot() {
        if (isEmpty()) {
            System.out.println(""Heap - Heap is empty. Cannot remove root."");
        } else {
            E root = heapList.remove(0);
            System.out.println(""Heap - Removed the root from the heap: "" + root);
            // Actual implementation of maintaining heap order goes here
        }
    }

    /**
     * Get the number of nodes in the tree
     *
     * @return The number of nodes in the heap
     */
    public int getNumberOfNodes() {
        System.out.println(""Heap - Number of nodes in the heap: "" + heapList.size());
        return heapList.size();
    }

    /**
     * Check if the heap is empty
     *
     * @return True if the heap is empty, false otherwise
     */
    public boolean isEmpty() {
        boolean isEmpty = heapList.isEmpty();
        System.out.println(""Heap - Is the heap empty? "" + isEmpty);
        return isEmpty;
    }

    /**
     * Main method for testing heap operations
     *
     * @param args Command line arguments (not used)
     */
    public static void main(String[] args) {
        System.out.println(""Welcome to the Heap operations!"");

        // Testing with integers
        Heap<Integer> integerHeap = new Heap<>();
        integerHeap.addToHeap(5);
        integerHeap.addToHeap(3);
        integerHeap.addToHeap(8);
        integerHeap.getNumberOfNodes();
        integerHeap.removeRoot();
        integerHeap.isEmpty();

        // Testing with strings
        Heap<String> stringHeap = new Heap<>(new String[]{""apple"", ""banana"", ""orange""});
        stringHeap.getNumberOfNodes();
        stringHeap.removeRoot();
        stringHeap.isEmpty();
    }
}",0.19061371841155234
0_Exercise01_07.java," /**
 * 1.7 (Approximate &Pi;) &Pi; can be computed using the following formula:
 * p = 4 * ¢1 - 1 3 + 1 5 - 17 + 1 9 - 11 1 + c ≤
 * Write a program that displays the result of 4 * ¢1 - 1 3 + 15 - 1 7 + 1 9 - 11 1 ≤
 * and 4 * ¢1 - 13 + 1 5 - 17 + 1 9 - 11 1 + 13 1 ≤. Use 1.0 instead of 1 in your
 * program.
 */","package ch_01;


public class Exercise01_07 {
	public static void main(String[] args) {
		
		double approxPi = 4 * (1.0 - 1.0/3 + 1.0/5 - 1.0/7 + 1.0/9 - 1.0/11);
		double approxPi2 = 4 * (1.0 - 1.0/3 + 1.0/5 - 1.0/7 + 1.0/9 - 1.0/11 + 1.0/13);

		System.out.println(approxPi);
		System.out.println(approxPi2);
		System.out.println(Math.PI);
	}
	

}
","public class PiApproximation {
    public static void main(String[] args) {
        double pi1 = 4 * (1.0 - 1.0/3 + 1.0/5 - 1.0/7 + 1.0/9 - 1.0/11);
        double pi2 = 4 * (1.0 - 1.0/3 + 1.0/5 - 1.0/7 + 1.0/9 - 1.0/11 + 1.0/13);
        
        System.out.println(""Approximation 1: "" + pi1);
        System.out.println(""Approximation 2: "" + pi2);
    }
}",5,"public class PiApproximation {

    public static void main(String[] args) {
        double result1 = 4 * (1.0 - 1.0/3 + 1.0/5 - 1.0/7 + 1.0/9 - 1.0/11);
        double result2 = 4 * (1.0 - 1.0/3 + 1.0/5 - 1.0/7 + 1.0/9 - 1.0/11 + 1.0/13);

        System.out.println(""Approximation 1 of Pi: "" + result1);
        System.out.println(""Approximation 2 of Pi: "" + result2);
    }
}",0.9303030303030303
0_Exercise01_11.java," /**
 * (Population projection)
 * <p>
 * One birth every 7 seconds
 * One death every 13 seconds
 * One new immigrant every 45 seconds
 * Write a program to display the population for each of
 * the next five years.
 * Current population is 312,032,486 and a year is 365 days.
 */","package ch_01;


public class Exercise01_11 {
    public static void main(String[] args) {


        double birthInseconds = 7.0;
        double deathInseconds = 13.0;
        double immigrationInseconds = 45.0;

        double birthsPeryear = changeToyears(birthInseconds);
        double deathsPeryear = changeToyears(deathInseconds);
        double immigratePeryear = changeToyears(immigrationInseconds);

        double currentPopulation = 312_032_486;

        for (int i = 1; i <= 5; i++) {
            currentPopulation += birthsPeryear - deathsPeryear + immigratePeryear;

            System.out.print(""The population in year "" + i + "" will be "");
            System.out.printf(""%1.0f"", currentPopulation);   //To prevent displaying in scientific notation
            System.out.println();
        }

    }

    public static double changeToyears(double valueInseconds) {

        double secondsInyear = 60 * 60 * 24 * 365;

        double amountPeryear = secondsInyear / valueInseconds;

        return amountPeryear;
    }

}
","public class Population {
    public static void main(String[] args) {
        final int SECONDS_PER_YEAR = 365 * 24 * 60 * 60; // seconds per year
        final int BIRTHS_PER_YEAR = SECONDS_PER_YEAR / 7; // number of births per year
        final int DEATHS_PER_YEAR = SECONDS_PER_YEAR / 13; // number of deaths per year
        final int IMMIGRANTS_PER_YEAR = SECONDS_PER_YEAR / 45; // number of immigrants per year
        int currentPopulation = 312032486; // current population
        int year = 1; // starting year

        // Calculate the population for each of the next five years
        for (int i = 0; i < 5; i++) {
            currentPopulation += BIRTHS_PER_YEAR + IMMIGRANTS_PER_YEAR - DEATHS_PER_YEAR;
            System.out.println(""Year "" + year + "": "" + currentPopulation);
            year++;
        }
    }
}",5,"public class PopulationProjection {

    public static void main(String[] args) {
        // Initialize variables
        long currentPopulation = 312032486L;
        int secondsInYear = 365 * 24 * 60 * 60;

        // Calculate the number of births, deaths, and immigrants per year
        long birthsPerYear = secondsInYear / 7;
        long deathsPerYear = secondsInYear / 13;
        long immigrantsPerYear = secondsInYear / 45;

        // Display population projection for the next five years
        System.out.println(""Population Projection for the Next Five Years:"");
        for (int i = 1; i <= 5; i++) {
            currentPopulation += birthsPerYear - deathsPerYear + immigrantsPerYear;
            System.out.println(""Year "" + i + "": "" + currentPopulation);
        }
    }
}",0.5643564356435643
0_Exercise01_10.java," /**
 * 1.10 (Average speed in miles) Assume a runner runs 14 kilometers in 45 minutes and 30
 * seconds. Write a program that displays the average speed in miles per hour. (Note
 * that 1 mile is 1.6 kilometers.)
 */","package ch_01;


public class Exercise01_10 {

    public static void main(String[] args) {

        double numMiles = 14 / 1.6;            //Convert kilometers into MPH
        double speed = numMiles / (45.5 / 60);            //Average speed in miles per hour

        System.out.printf(""%.3f"", speed);

    }
}
","public class AverageSpeed {
    public static void main(String[] args) {
        double distanceInKm = 14.0;
        double timeInMinutes = 45.5; // 45 minutes and 30 seconds
        double timeInHours = timeInMinutes / 60.0;
        double distanceInMiles = distanceInKm / 1.6;
        double speedInMph = distanceInMiles / timeInHours;

        System.out.println(""Average speed in miles per hour: "" + speedInMph);
    }
}",5,"public class AverageSpeed {

    public static void main(String[] args) {
        // Runner's details
        double kilometers = 14.0;
        int minutes = 45;
        int seconds = 30;

        // Conversion factor from kilometers to miles
        double milesPerKilometer = 1.6;

        // Calculate total hours
        double totalHours = minutes / 60.0 + seconds / 3600.0;

        // Calculate average speed in miles per hour
        double averageSpeed = kilometers / totalHours * milesPerKilometer;

        // Display the result
        System.out.println(""Average speed: "" + averageSpeed + "" miles per hour"");
    }
}
",0.5720524017467249
0_Exercise01_06.java," /**
 * 1.6 (Summation of a series) Write a program that displays the result of
 * 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9.
 */","package ch_01;


public class Exercise01_06 {
	public static void main(String[]args) {
		System.out.println(1+2+3+4+5+6+7+8+9);
		
	}

}
","public class SumOfNumbers {
    public static void main(String[] args) {
        int sum = 0;

        for (int i = 1; i <= 9; i++) {
            sum += i;
        }

        System.out.println(""Sum of numbers from 1 to 9: "" + sum);
    }
}",5,"public class SeriesSummation {

    public static void main(String[] args) {
        // Variables to store individual numbers
        int num1 = 1;
        int num2 = 2;
        int num3 = 3;
        int num4 = 4;
        int num5 = 5;
        int num6 = 6;
        int num7 = 7;
        int num8 = 8;
        int num9 = 9;

        // Calculate the sum of the series
        int sum = num1 + num2 + num3 + num4 + num5 + num6 + num7 + num8 + num9;

        // Display the result
        System.out.println(""Result of the series: "" + sum);
    }
}",0.4803767660910518
0_Exercise01_01.java," /**
 * 1.1 (Display three messages) Write a program that displays Welcome to Java,
 * Welcome to Computer Science, and Programming is fun.
 */","package ch_01;


public class Exercise01_01 {
    public static void main(String[] args) {

        System.out.println(""Welcome to Java"");
        System.out.println(""Welcome to Computer Science"");
        System.out.println(""Programming is fun"");
    }

}
","public class DisplayMessages {
    public static void main(String[] args) {
        System.out.println(""Welcome to Java"");
        System.out.println(""Welcome to Computer Science"");
        System.out.println(""Programming is fun"");
    }
}",5,"public class WelcomeMessages {

    public static void main(String[] args) {
        // Displaying the first message
        System.out.println(""Welcome to Java"");

        // Displaying the second message
        System.out.println(""Welcome to Computer Science"");

        // Displaying the third message
        System.out.println(""Programming is fun"");
    }
}",0.7817836812144212
0_Exercise08_31.java," /**
 * 8.31 (Geometry: intersecting point) Write a method that returns the
 * intersecting point of two lines. The intersecting point of the two
 * lines can be found by using the formula shown in Programming
 * Exercise 3.25. Assume that (x1, y1) and (x2, y2) are the two points on
 * line 1 and (x3, y3) and (x4, y4) are on line 2............
 * The points are stored in a 4-by-2 two-dimensional array points with
 * (points[0][0], points[0][1]) for (x1, y1). The method returns the
 * intersecting point or null if the two lines are parallel. Write a
 * program that prompts the user to enter four points and displays the
 * intersecting point.
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_31 {
    public static double[] getIntersectingPoint(double[][] points) {

        double[] interPoint = new double[2];


        if ((points[0][0] - points[1][0]) * (points[2][1] - points[3][1]) -
                (points[0][1] - points[1][1]) * (points[2][0] - points[3][0]) == 0)
            return null;


        double a = points[0][1] - points[1][1];

        double b = -(points[0][0] - points[1][0]);

        double c = (points[0][1] - points[1][1]) *
                points[0][0] - (points[0][0] - points[1][0]) * points[0][1];

        double d = (points[2][1] - points[3][1]);

        double e = -(points[2][0] - points[3][0]);

        double f = ((points[2][1] - points[3][1]) * points[2][0]) -
                ((points[2][0] - points[3][0]) * points[2][1]);

        double x = ((e * d) - (b * f)) / ((a * d) - (b * c));
        double y = ((a * f) - (e * c)) / ((a * d) - (b * c));


        interPoint[0] = x;
        interPoint[1] = y;

        return interPoint;
    }

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        final int pointsRows = 4;
        final int pointsCol = 2;

        double[][] points = new double[pointsRows][pointsCol];

        System.out.println(""Enter x1, y1, x2, y2, x3, y3, x4, y4: "");

        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points[i].length; j++) {
                points[i][j] = input.nextDouble();

            }
        }

        double[] intersectingPoints = getIntersectingPoint(points);

        if (intersectingPoints != null) {
            System.out.println(""The intersecting point is at: "" +
                    ""( "" + intersectingPoints[0] + "", "" + intersectingPoints[1]
                    + "" )"");
        } else {
            System.out.println(""The two lines are parallel"");
        }
    }

}
","import java.util.Scanner;

public class Exercise08_31 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        double[][] points = new double[4][2];
        System.out.print(""Enter four points: "");
        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points[i].length; j++) {
                points[i][j] = input.nextDouble();
            }
        }
        double[] intersectingPoint = getIntersectingPoint(points);
        if (intersectingPoint == null) {
            System.out.println(""The two lines are parallel."");
        } else {
            System.out.printf(""The intersecting point is at (%.4f, %.4f)\n"",
                    intersectingPoint[0], intersectingPoint[1]);
        }
    }

    public static double[] getIntersectingPoint(double[][] points) {
        double x1 = points[0][0], y1 = points[0][1];
        double x2 = points[1][0], y2 = points[1][1];
        double x3 = points[2][0], y3 = points[2][1];
        double x4 = points[3][0], y4 = points[3][1];
        double a = y1 - y2;
        double b = x2 - x1;
        double c = y3 - y4;
        double d = x4 - x3;
        double e = a * x1 + b * y1;
        double f = c * x3 + d * y3;
        double determinant = a * d - b * c;
        if (determinant == 0) {
            return null;
        } else {
            double x = (e * d - b * f) / determinant;
            double y = (a * f - e * c) / determinant;
            return new double[]{x, y};
        }
    }
}",1,"import java.util.Scanner;

public class IntersectingPointCalculator {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        double[][] points = new double[4][2];

        System.out.print(""Enter x1 and y1: "");
        points[0][0] = input.nextDouble();
        points[0][1] = input.nextDouble();

        System.out.print(""Enter x2 and y2: "");
        points[1][0] = input.nextDouble();
        points[1][1] = input.nextDouble();

        System.out.print(""Enter x3 and y3: "");
        points[2][0] = input.nextDouble();
        points[2][1] = input.nextDouble();

        System.out.print(""Enter x4 and y4: "");
        points[3][0] = input.nextDouble();
        points[3][1] = input.nextDouble();

        double[] intersectingPoint = calculateIntersectingPoint(points);

        if (intersectingPoint != null) {
            System.out.println(""The intersecting point is at ("" + intersectingPoint[0] + "", "" + intersectingPoint[1] + "")"");
        } else {
            System.out.println(""The lines are parallel. No intersecting point exists."");
        }

        input.close();
    }

    public static double[] calculateIntersectingPoint(double[][] points) {
        double x1 = points[0][0];
        double y1 = points[0][1];
        double x2 = points[1][0];
        double y2 = points[1][1];
        double x3 = points[2][0];
        double y3 = points[2][1];
        double x4 = points[3][0];
        double y4 = points[3][1];

        double a = y1 - y2;
        double b = x2 - x1;
        double c = y3 - y4;
        double d = x4 - x3;
        double e = a * x1 + b * y1;
        double f = c * x3 + d * y3;

        double determinant = a * d - b * c;

        if (determinant == 0) {
            return null; // Lines are parallel
        } else {
            double[] intersectingPoint = new double[2];
            intersectingPoint[0] = (e * d - b * f) / determinant;
            intersectingPoint[1] = (a * f - e * c) / determinant;
            return intersectingPoint;
        }
    }
}",0.7340389211334927
0_Exercise08_30.java," /**
 * *8.30 (Algebra: solve linear equations) Write a method that solves the following
 * 2 * 2 system of linear equations:
 * a00x + a01y = b0
 * a10x + a11y = b1
 * x =
 * b0a11 - b1a01
 * a00a11 - a01a10
 * y =
 * b1a00 - b0a10
 * a00a11 - a01a10
 * The method header is
 * public static double[] linearEquation(double[][] a, double[] b)
 * The method returns null if a00a11 - a01a10 is 0.
 * <p>
 * Write a test program that
 * prompts the user to enter a00, a01, a10, a11, b0, and b1, and displays the result. If
 * a00a11 - a01a10 is 0, report that “The equation has no solution.” A sample run is
 * similar to Programming Exercise 3.3.
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_30 {

    public static void main(String[] args) {
        double[][] a = new double[2][2];
        double[] b = new double[2];

        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a00, a01, a10, a11, b0, and b1: "");
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                a[i][j] = in.nextDouble();
            }
        }
        for (int i = 0; i < b.length; i++) {
            b[i] = in.nextDouble();
        }
        double[] res = linearEquation(a, b);
        System.out.println(""Value of x is "" + res[0]);
        System.out.println(""Value of y is "" + res[1]);
    }


    public static double[] linearEquation(double[][] a, double[] b) {
        double x = (b[0] * a[1][1]) - (b[1] * a[0][1]) / (a[0][0] * a[1][1]) - (a[0][1] * a[1][0]);
        double y = (b[1] * a[0][0]) - (b[0] * a[1][0]) / (a[0][0] * a[1][1]) - (a[0][1] * a[1][0]);
        return new double[]{x, y};
    }
}
","public static double[] linearEquation(double[][] a, double[] b) {
    double determinant = a[0][0] * a[1][1] - a[0][1] * a[1][0];
    if (determinant == 0) {
        System.out.println(""The equation has no solution."");
        return null;
    } else {
        double x = (b[0] * a[1][1] - b[1] * a[0][1]) / determinant;
        double y = (b[1] * a[0][0] - b[0] * a[1][0]) / determinant;
        return new double[] {x, y};
    }
}   import java.util.Scanner;

public class LinearEquationTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a00, a01, a10, a11, b0, b1: "");
        double[][] a = {{input.nextDouble(), input.nextDouble()},
                        {input.nextDouble(), input.nextDouble()}};
        double[] b = {input.nextDouble(), input.nextDouble()};

        double[] solution = linearEquation(a, b);
        if (solution != null) {
            System.out.printf(""x = %f, y = %f\n"", solution[0], solution[1]);
        }
    }
}",1,"import java.util.Scanner;

public class LinearEquationSolver {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.println(""Enter coefficients for the 2x2 linear equation:"");
        double[][] coefficients = new double[2][2];
        double[] constants = new double[2];

        System.out.print(""a00: "");
        coefficients[0][0] = input.nextDouble();
        System.out.print(""a01: "");
        coefficients[0][1] = input.nextDouble();
        System.out.print(""a10: "");
        coefficients[1][0] = input.nextDouble();
        System.out.print(""a11: "");
        coefficients[1][1] = input.nextDouble();

        System.out.println(""Enter constants for the equation:"");
        System.out.print(""b0: "");
        constants[0] = input.nextDouble();
        System.out.print(""b1: "");
        constants[1] = input.nextDouble();

        double[] solution = linearEquation(coefficients, constants);

        if (solution != null) {
            System.out.println(""Solution: x = "" + solution[0] + "", y = "" + solution[1]);
        } else {
            System.out.println(""The equation has no solution."");
        }
    }

    public static double[] linearEquation(double[][] coefficients, double[] constants) {
        double a00 = coefficients[0][0];
        double a01 = coefficients[0][1];
        double a10 = coefficients[1][0];
        double a11 = coefficients[1][1];
        double b0 = constants[0];
        double b1 = constants[1];

        double determinant = a00 * a11 - a01 * a10;

        if (determinant == 0) {
            return null; // No solution
        }

        double x = (b0 * a11 - b1 * a01) / determinant;
        double y = (b1 * a00 - b0 * a10) / determinant;

        return new double[]{x, y};
    }
}",0.39883672621520566
0_Exercise08_26.java," /**
 * *8.26 (Row sorting) Implement the following method to sort the rows in a
 * two-dimensional array.
 * <p>
 * A new array is returned and the original array is intact.
 * public static double[][] sortRows(double[][] m)
 * <p>
 * <p>
 * Write a test program that prompts the user to enter a 3 * 3 matrix of double
 * values and displays a new row-sorted matrix.
 * <p>
 * Here is a sample run:
 * Enter a 3-by-3 matrix row by row:
 * 0.15 0.875 0.375
 * 0.55 0.005 0.225
 * 0.30 0.12 0.4
 * The row-sorted array is
 * 0.15 0.375 0.875
 * 0.005 0.225 0.55
 * 0.12 0.30 0.4
 */","package ch_08;

import java.io.DataOutput;
import java.util.*;


public class Exercise08_26 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        double[][] matrix = new double[3][3];

        System.out.println(""Enter a 3-by-3 matrix row by row: "");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix[i][j] = in.nextDouble();
            }
        }
        double[][] res = sortRows(matrix);
        System.out.println(""The row-sorted array is: "");
        for (int i = 0; i < 3; i++) {
            System.out.println(Arrays.toString(res[i]));

        }

    }

    public static double[][] sortRows(double[][] m) {
        double[][] sorted = new double[m.length][m.length];
        for (int i = 0; i < 3; i++) {
            System.arraycopy(m[i], 0, sorted[i], 0, 3);
        }

        for (int i = 0; i < sorted.length; i++) {
            boolean keepSorting = true;
            while (keepSorting) {
                keepSorting = false;
                for (int j = 0; j < sorted[i].length - 1; j++) {
                    if (sorted[i][j] > sorted[i][j + 1]) {
                        double tmp = sorted[i][j];
                        sorted[i][j] = sorted[i][j + 1];
                        sorted[i][j + 1] = tmp;
                        keepSorting = true;
                    }
                }
            }
        }
        return sorted;

    }

}","import java.util.Arrays;
import java.util.Scanner;

public class SortRowsDemo {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter a 3-by-3 matrix of double values
        System.out.println(""Enter a 3-by-3 matrix row by row:"");
        double[][] m = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                m[i][j] = input.nextDouble();
            }
        }

        // Sort the rows of the matrix
        double[][] sorted = sortRows(m);

        // Display the sorted matrix
        System.out.println(""The row-sorted array is"");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(sorted[i][j] + "" "");
            }
            System.out.println();
        }
    }

    public static double[][] sortRows(double[][] m) {
        // Create a new array to hold the sorted matrix
        double[][] sorted = new double[3][3];
        // Copy the elements of the original matrix to the new array
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                sorted[i][j] = m[i][j];
            }
        }
        // Sort each row of the new array
        for (int i = 0; i < 3; i++) {
            Arrays.sort(sorted[i]);
        }
        // Return the sorted matrix
        return sorted;
    }

}",1,"import java.util.Arrays;
import java.util.Scanner;

public class RowSort {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a 3-by-3 matrix row by row:"");
        double[][] matrix = new double[3][3];
        
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix[i][j] = input.nextDouble();
            }
        }
        
        double[][] sortedMatrix = sortRows(matrix);
        System.out.println(""The row-sorted array is:"");
        printMatrix(sortedMatrix);
    }

    public static double[][] sortRows(double[][] m) {
        double[][] sorted = new double[m.length][m[0].length];
        
        for (int i = 0; i < m.length; i++) {
            sorted[i] = Arrays.copyOf(m[i], m[i].length);
            Arrays.sort(sorted[i]);
        }
        
        return sorted;
    }

    public static void printMatrix(double[][] matrix) {
        for (double[] row : matrix) {
            for (double value : row) {
                System.out.print(value + "" "");
            }
            System.out.println();
        }
    }
}",0.6653639472398633
0_Exercise08_06.java," /**
 * 8.6 (Algebra: multiply two matrices)
 * Write a method to multiply two matrices. The header of the method is:
 * <p>
 * public static double[][] multiplyMatrix(double[][] a, double[][] b)
 * <p>
 * To multiply matrix a by matrix b, the number of columns in A must
 * be the same as the number of rows in B, and the two matrices must have
 * elements of the same or compatible types. Let c be the result of the
 * multiplication. Assume the column size of matrix a is n. Each element
 * cij is ai1 � b1j + ai2 � b2j + � + ain � bnj. For example, for two
 * 3 � 3 matrices a and b, c is..............
 * <p>
 * Write a test program that prompts the user
 * to enter two 3 � 3 matrices and displays
 * their product.
 */","package ch_08;

import java.util.Scanner;



public class Exercise08_06 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double[][] matrix1 = new double[3][3];

        System.out.println(""Enter the values for the first 3 x 3 matrix: "");

        for (int i = 0; i < matrix1.length; i++) {
            for (int j = 0; j < matrix1[i].length; j++) {

                matrix1[i][j] = input.nextDouble();
            }
        }

        double[][] matrix2 = new double[3][3];

        System.out.println(""Enter the values for the second 3 x 3 matrix: "");

        for (int i = 0; i < matrix2.length; i++) {
            for (int j = 0; j < matrix2[i].length; j++) {

                matrix2[i][j] = input.nextDouble();

            }
        }

        double[][] newMatrix = multiplyMatrix(matrix1, matrix2);

        System.out.println(""The multiplication of the two matrices is as follows:"");

        for (int i = 0; i < matrix1.length; i++) {


            for (int j = 0; j < matrix1[i].length; j++) {

                System.out.print(matrix1[i][j] + "" "");
                if (i == 1 && j == 2) {
                    System.out.print("" *  "");
                } else if (i != 1 && j == 2) {
                    System.out.print(""    "");
                }
            }

            for (int j = 0; j < matrix2[i].length; j++) {

                System.out.print(matrix2[i][j] + "" "");
                if (i == 1 && j == 2) {
                    System.out.print("" =  "");
                } else if (i != 1 && j == 2) {
                    System.out.print(""    "");
                }
            }

            for (int j = 0; j < newMatrix[i].length; j++) {

                System.out.print(newMatrix[i][j] + "" "");
                if (i != 1 && j == 2) {
                    System.out.print(""    "");
                }


            }
            System.out.println();
        }

    }

    public static double[][] multiplyMatrix(double[][] a, double[][] b) {

        double[][] result = new double[3][3];

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                for (int z = 0; z < a.length; z++) {

                    result[i][j] += a[i][z] * b[z][j];
                }
            }
        }
        return result;
    }
}
","public static double[][] multiplyMatrix(double[][] a, double[][] b) {
    int m = a.length; // number of rows in A
    int n = b[0].length; // number of columns in B
    int p = b.length; // number of rows in B

    double[][] c = new double[m][n];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            double sum = 0.0;
            for (int k = 0; k < p; k++) {
                sum += a[i][k] * b[k][j];
            }
            c[i][j] = sum;
        }
    }

    return c;
}",1,"import java.util.Scanner;

public class MatrixMultiplier {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        double[][] matrixA = new double[3][3];
        double[][] matrixB = new double[3][3];

        System.out.println(""Enter the elements of the first 3x3 matrix:"");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.printf(""Enter element (%d, %d): "", i + 1, j + 1);
                matrixA[i][j] = input.nextDouble();
            }
        }

        System.out.println(""Enter the elements of the second 3x3 matrix:"");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.printf(""Enter element (%d, %d): "", i + 1, j + 1);
                matrixB[i][j] = input.nextDouble();
            }
        }

        double[][] product = multiplyMatrix(matrixA, matrixB);

        System.out.println(""The product of the matrices is:"");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(product[i][j] + "" "");
            }
            System.out.println();
        }
    }

    public static double[][] multiplyMatrix(double[][] a, double[][] b) {
        int rowsA = a.length;
        int colsA = a[0].length;
        int colsB = b[0].length;

        double[][] result = new double[rowsA][colsB];

        for (int i = 0; i < rowsA; i++) {
            for (int j = 0; j < colsB; j++) {
                for (int k = 0; k < colsA; k++) {
                    result[i][j] += a[i][k] * b[k][j];
                }
            }
        }

        return result;
    }
}",0.3798494499131442
0_Exercise08_10.java," /**
 * 8.10 (Largest row and column) Write a program that randomly fills in 0s and 1s into
 * a 4-by-4 matrix, prints the matrix, and finds the first row and column with the
 * most 1s. Here is a sample run of the program:
 * 0011
 * 0011
 * 1101
 * 1010
 * The largest row index: 2
 * The largest column index: 2
 */","package ch_08;


public class Exercise08_10 {
    public static void main(String[] args) {

        final int size = 4;

        int[][] randomMatrix = new int[size][size];

        for (int i = 0; i < randomMatrix.length; i++) {
            for (int j = 0; j < randomMatrix[i].length; j++) {
                randomMatrix[i][j] = (int) (Math.random() * 2);
            }
        }

        for (int i = 0; i < randomMatrix.length; i++) {
            for (int j = 0; j < randomMatrix[i].length; j++) {
                System.out.print(randomMatrix[i][j]);
            }
            System.out.println();
        }

        System.out.println(""The largest row index is: "" +
                findLargerow(randomMatrix));

        System.out.println(""The largest column index is: "" +
                findLargecolumn(randomMatrix));


    }

    public static int findLargecolumn(int[][] a) {

        int largeColumn = 0;
        int largeSum = a[0][0] + a[1][0] + a[2][0] + a[3][0];
        int Sum = 0;

        for (int i = 1; i < a[0].length; i++) {

            Sum = a[0][i] + a[1][i] + a[2][i] + a[3][i];
            if (Sum > largeSum) {
                largeSum = Sum;
                largeColumn = i;
            }
        }
        return largeColumn;

    }

    public static int findLargerow(int[][] a) {

        int largeRow = 0;
        int largeSum = a[0][0] + a[0][1] + a[0][2] + a[0][3];
        int Sum = 0;

        for (int i = 1; i < a.length; i++) {

            Sum = a[i][0] + a[i][1] + a[i][2] + a[i][3];
            if (Sum > largeSum) {
                largeSum = Sum;
                largeRow = i;
            }

        }

        return largeRow;
    }

}
","import java.util.Random;

public class Main {
    public static void main(String[] args) {
        int[][] matrix = new int[4][4];
        Random random = new Random();

        // fill in the matrix with random 0s and 1s
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = random.nextInt(2);
            }
        }

        // print the matrix
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
            }
            System.out.println();
        }

        int maxRow = 0;
        int maxColumn = 0;
        int maxCountRow = 0;
        int maxCountColumn = 0;

        // find the row and column with the most 1s
        for (int i = 0; i < matrix.length; i++) {
            int countRow = 0;
            int countColumn = 0;
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] == 1) {
                    countRow++;
                }
                if (matrix[j][i] == 1) {
                    countColumn++;
                }
            }
            if (countRow > maxCountRow) {
                maxCountRow = countRow;
                maxRow = i;
            }
            if (countColumn > maxCountColumn) {
                maxCountColumn = countColumn;
                maxColumn = i;
            }
        }

        // print the results
        System.out.println(""The largest row index: "" + maxRow);
        System.out.println(""The largest column index: "" + maxColumn);
    }
}",1,"import java.util.Random;

public class LargestRowColumn {
    public static void main(String[] args) {
        int[][] matrix = new int[4][4];
        Random random = new Random();

        // Fill the matrix with random 0s and 1s
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = random.nextInt(2); // Randomly assign 0 or 1
            }
        }

        // Print the matrix
        System.out.println(""The randomly generated matrix is:"");
        for (int[] row : matrix) {
            for (int cell : row) {
                System.out.print(cell);
            }
            System.out.println();
        }

        int maxRowIndex = 0;
        int maxColumnIndex = 0;
        int maxRowCount = 0;
        int maxColumnCount = 0;

        // Find row with most 1s
        for (int i = 0; i < matrix.length; i++) {
            int rowCount = 0;
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] == 1) {
                    rowCount++;
                }
            }
            if (rowCount > maxRowCount) {
                maxRowCount = rowCount;
                maxRowIndex = i;
            }
        }

        // Find column with most 1s
        for (int j = 0; j < matrix[0].length; j++) {
            int columnCount = 0;
            for (int i = 0; i < matrix.length; i++) {
                if (matrix[i][j] == 1) {
                    columnCount++;
                }
            }
            if (columnCount > maxColumnCount) {
                maxColumnCount = columnCount;
                maxColumnIndex = j;
            }
        }

        // Output the results
        System.out.println(""The largest row index with most 1s: "" + maxRowIndex);
        System.out.println(""The largest column index with most 1s: "" + maxColumnIndex);
    }
}",0.777733912356889
0_Exercise08_21.java," /**
 * *8.21 (Central city) Given a set of cities, the central city is the city that has the shortest
 * total distance to all other cities. Write a program that prompts the user to enter
 * the number of the cities and the locations of the cities (coordinates), and finds
 * the central city and its total distance to all other cities.
 * Drop a yellow disk at column (0–6): 3
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * |R| | |Y| | | |
 * . . .
 * . . .
 * . . .
 * Drop a yellow disk at column (0–6): 6
 * | | | | | | | |
 * | | | | | | | |
 * | | | |R| | | |
 * | | | |Y|R|Y| |
 * | | |R|Y|Y|Y|Y|
 * |R|Y|R|Y|R|R|R|
 * ———————————————
 * The yellow player won
 * Enter the number of cities: 5
 * Enter the coordinates of the cities:
 * 2.5 5 5.1 3 1 9 5.4 54 5.5 2.1
 * The central city is at (2.5, 5.0)
 * The total distance to all other cities is 60.81
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_21 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the number of cities: "");

        int numCities = input.nextInt();

        double[][] coor = new double[numCities][2];   //Creates two-dimensional array object with each city as row and the 0 and 1 columns as coordinates

        System.out.print(""Enter the coordinates of the "" + numCities + "" cities:"");

        for (int i = 0; i < coor.length; i++) {
            for (int j = 0; j < coor[i].length; j++) {

                coor[i][j] = input.nextDouble();   //inputs user coordinates

            }
        }

        double[][] distances = findDistances(coor);  // Creates new two-dimensional array object with distances between each city and the other city

        double[] sumOfDistances = new double[distances.length]; //Creates array object to store the sum of the distances

        for (int i = 0; i < sumOfDistances.length; i++) {
            for (int j = 0; j < sumOfDistances.length; j++) {

                sumOfDistances[i] += distances[i][j];   //Finds the sum of distances for each city, and stores it in the cities
            }
        }
        int indexMin = indexOfMin(sumOfDistances);

        System.out.println(""The central city is at ("" + coor[indexMin][0] + "", "" + coor[indexMin][1] + "")"");
        System.out.println(""And the total distance to all other cities is "" + sumOfDistances[indexMin]);
        input.close();
    }

    public static int indexOfMin(double[] arr) { //returns the index of the lowest sum

        int index = 0;
        double minDistance = arr[0];

        for (int i = 1; i < arr.length; i++) {

            if (minDistance > arr[i]) {
                minDistance = arr[i];
                index = i;
            }
        }

        return index;

    }

    public static double[][] findDistances(double[][] arr) {

        double[][] d = new double[arr.length][arr.length];

        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {

                double x1 = arr[i][0];
                double x2 = arr[j][0];
                double y1 = arr[i][1];
                double y2 = arr[j][1];

                d[i][j] = Math.pow(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2), 0.5);

            }
        }

        return d;
    }

}","import java.util.Scanner;

public class CentralCity {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Get the number of cities
        System.out.print(""Enter the number of cities: "");
        int numCities = input.nextInt();

        // Create arrays to store the x and y coordinates of the cities
        int[] xCoords = new int[numCities];
        int[] yCoords = new int[numCities];

        // Get the coordinates of the cities
        for (int i = 0; i < numCities; i++) {
            System.out.print(""Enter the x-coordinate of city "" + (i + 1) + "": "");
            xCoords[i] = input.nextInt();
            System.out.print(""Enter the y-coordinate of city "" + (i + 1) + "": "");
            yCoords[i] = input.nextInt();
        }

        // Find the central city
        int centralCityIndex = 0;
        int shortestDistanceSum = Integer.MAX_VALUE;

        for (int i = 0; i < numCities; i++) {
            int distanceSum = 0;

            for (int j = 0; j < numCities; j++) {
                if (i != j) {
                    // Calculate the distance between the two cities using the distance formula
                    int distance = (int) Math.sqrt(Math.pow(xCoords[j] - xCoords[i], 2) + Math.pow(yCoords[j] - yCoords[i], 2));
                    distanceSum += distance;
                }
            }

            // Check if the current city has a shorter total distance than the previous shortest distance
            if (distanceSum < shortestDistanceSum) {
                shortestDistanceSum = distanceSum;
                centralCityIndex = i;
            }
        }

        // Print the central city and its total distance to all other cities
        System.out.println(""The central city is city "" + (centralCityIndex + 1) + ""."");
        System.out.println(""The total distance from the central city to all other cities is "" + shortestDistanceSum + ""."");
    }
}

    if total_distance < min_total_distance:
        min_total_distance = total_distance
        central_city = i

print(""The central city is at (%.1f, %.1f)"" % cities[central_city])
print(""The total distance to all other cities is %.2f"" % min_total_distance)",1,"import java.util.Scanner;

public class CentralCityFinder {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter the number of cities: "");
        int numberOfCities = input.nextInt();
        
        double[] xCoordinates = new double[numberOfCities];
        double[] yCoordinates = new double[numberOfCities];
        
        System.out.println(""Enter the coordinates of the cities:"");
        for (int i = 0; i < numberOfCities; i++) {
            System.out.print(""City "" + (i + 1) + "" x-coordinate: "");
            xCoordinates[i] = input.nextDouble();
            
            System.out.print(""City "" + (i + 1) + "" y-coordinate: "");
            yCoordinates[i] = input.nextDouble();
        }
        
        int centralCityIndex = 0;
        double minTotalDistance = Double.MAX_VALUE;
        
        for (int i = 0; i < numberOfCities; i++) {
            double totalDistance = 0;
            
            for (int j = 0; j < numberOfCities; j++) {
                if (i != j) {
                    double distance = Math.sqrt(Math.pow(xCoordinates[j] - xCoordinates[i], 2) +
                                                Math.pow(yCoordinates[j] - yCoordinates[i], 2));
                    totalDistance += distance;
                }
            }
            
            if (totalDistance < minTotalDistance) {
                minTotalDistance = totalDistance;
                centralCityIndex = i;
            }
        }
        
        System.out.println(""The central city is at ("" + xCoordinates[centralCityIndex] +
                            "", "" + yCoordinates[centralCityIndex] + "")"");
        System.out.println(""The total distance to all other cities is "" + minTotalDistance);
        
        input.close();
    }
}",0.6727102219443576
0_Exercise08_37.java," /**
 * 8.37 (Guess the capitals) Write a program that repeatedly
 * prompts the user to enter a capital for a state. Upon
 * receiving the user input, the program reports whether
 * the answer is correct. Assume that 50 states and their
 * capitals are stored in a two-dimensional array, as shown
 * in Figure 8.10. The program prompts the user to answer all
 * states� capitals and displays the total correct count.
 * The user�s answer is not case-sensitive.
 */","package ch_08;

import java.util.Scanner;



public class Exercise08_37 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        String[][] statesAndTheirCapitals = {
                {""Alabama"", ""Montgomery""}, {""Alaska"", ""Juneau""}, {""Arizona"", ""Phoenix""},
                {""Arkansas"", ""Little Rock""}, {""California"", ""Sacramento""},
                {""Colorado"", ""Denver""}, {""Connecticut"", ""Hartford""},
                {""Delaware"", ""Dover""}, {""Florida"", ""Tallahassee""},
                {""Georgia"", ""Atlanta""}, {""Hawaii"", ""Honolulu""}, {""Idaho"", ""Boise""},
                {""Illinois"", ""Springfield""}, {""Indiana"", ""Indianapolis""},
                {""Iowa Des"", ""Moines""}, {""Kansas"", ""Topeka""}, {""Kentucky"", ""Frankfort""},
                {""Louisiana"", ""Baton Rouge""}, {""Maine"", ""Augusta""},
                {""Maryland"", ""Annapolis""}, {""Massachusetts"", ""Boston""},
                {""Michigan"", ""Lansing""}, {""Minnesota"", ""Saint Paul""},
                {""Mississippi"", ""Jackson""}, {""Missouri"", ""Jefferson City""},
                {""Montana"", ""Helena""}, {""Nebraska"", ""Lincoln""},
                {""Nevada"", ""Carson City""}, {""New Hampshire"", ""Concord""},
                {""New Jersey"", ""Trenton""}, {""New Mexico"", ""Santa Fe""},
                {""New York"", ""Albany""}, {""North Carolina"", ""Raleigh""},
                {""North Dakota"", ""Bismarck""}, {""Ohio"", ""Columbus""},
                {""Oklahoma"", ""Oklahoma City""}, {""Oregon"", ""Salem""},
                {""Pennsylvania"", ""Harrisburg""}, {""Rhode Island"", ""Providence""},
                {""South Carolina"", ""Columbia""}, {""South Dakota"", ""Pierre""},
                {""Tennessee"", ""Nashville""}, {""Texas"", ""Austin""},
                {""Utah"", ""Salt Lake City""}, {""Vermont"", ""Montpelier""},
                {""Virginia"", ""Richmond""}, {""Washington"", ""Olympia""},
                {""West Virginia"", ""Charleston""}, {""Wisconsin"", ""Madison""},
                {""Wyoming"", ""Cheyenne""}};

        String checkAnswer = """";

        int correctCount = 0;

        for (int i = 0; i < statesAndTheirCapitals.length; i++) {

            System.out.print(""What is the capital of "" + statesAndTheirCapitals[i][0] + ""? "");

            checkAnswer = input.nextLine();

            if (statesAndTheirCapitals[i][1].equalsIgnoreCase(checkAnswer)) {
                System.out.println(""Your answer is correct"");

                correctCount++;
            } else {
                System.out.println(""Your answer is incorrect"");
            }

            if (i >= 10 && correctCount < 1) {
                System.out.println(""How about you go study for a while and try this again later?"");
                break;
            }

        }

        System.out.println(""The correct count is "" + correctCount);

    }

}
","import java.util.Scanner;

public class GuessTheCapitals {
    public static void main(String[] args) {
        String[][] statesAndCapitals = {
                {""Alabama"", ""Montgomery""},
                {""Alaska"", ""Juneau""},
                {""Arizona"", ""Phoenix""},
                {""Arkansas"", ""Little Rock""},
                {""California"", ""Sacramento""},
                {""Colorado"", ""Denver""},
                {""Connecticut"", ""Hartford""},
                {""Delaware"", ""Dover""},
                {""Florida"", ""Tallahassee""},
                {""Georgia"", ""Atlanta""},
                {""Hawaii"", ""Honolulu""},
                {""Idaho"", ""Boise""},
                {""Illinois"", ""Springfield""},
                {""Indiana"", ""Indianapolis""},
                {""Iowa"", ""Des Moines""},
                {""Kansas"", ""Topeka""},
                {""Kentucky"", ""Frankfort""},
                {""Louisiana"", ""Baton Rouge""},
                {""Maine"", ""Augusta""},
                {""Maryland"", ""Annapolis""},
                {""Massachusetts"", ""Boston""},
                {""Michigan"", ""Lansing""},
                {""Minnesota"", ""St. Paul""},
                {""Mississippi"", ""Jackson""},
                {""Missouri"", ""Jefferson City""},
                {""Montana"", ""Helena""},
                {""Nebraska"", ""Lincoln""},
                {""Nevada"", ""Carson City""},
                {""New Hampshire"", ""Concord""},
                {""New Jersey"", ""Trenton""},
                {""New Mexico"", ""Santa Fe""},
                {""New York"", ""Albany""},
                {""North Carolina"", ""Raleigh""},
                {""North Dakota"", ""Bismarck""},
                {""Ohio"", ""Columbus""},
                {""Oklahoma"", ""Oklahoma City""},
                {""Oregon"", ""Salem""},
                {""Pennsylvania"", ""Harrisburg""},
                {""Rhode Island"", ""Providence""},
                {""South Carolina"", ""Columbia""},
                {""South Dakota"", ""Pierre""},
                {""Tennessee"", ""Nashville""},
                {""Texas"", ""Austin""},
                {""Utah"", ""Salt Lake City""},
                {""Vermont"", ""Montpelier""},
                {""Virginia"", ""Richmond""},
                {""Washington"", ""Olympia""},
                {""West Virginia"", ""Charleston""},
                {""Wisconsin"", ""Madison""},
                {""Wyoming"", ""Cheyenne""}
        };

        Scanner input = new Scanner(System.in);
        int correctCount = 0;

        for (int i = 0; i < statesAndCapitals.length; i++) {
            System.out.print(""What is the capital of "" + statesAndCapitals[i][0] + ""? "");
            String capital = input.nextLine();

            if (capital.equalsIgnoreCase(statesAndCapitals[i][1])) {
                System.out.println(""Your answer is correct"");
                correctCount++;
            } else {
                System.out.println(""The correct answer should be "" + statesAndCapitals[i][1]);
            }
        }

        System.out.println(""The correct count is "" + correctCount);
    }
}",1,"import java.util.Scanner;

public class StateCapitalsGame {
    public static void main(String[] args) {
        String[][] stateCapitals = {
            {""Alabama"", ""Montgomery""}, {""Alaska"", ""Juneau""}, {""Arizona"", ""Phoenix""}, /* and so on... */};

        Scanner input = new Scanner(System.in);
        int correctCount = 0;

        System.out.println(""Welcome to the State Capitals Quiz!"");
        System.out.println(""Guess the capital of each state."");

        for (String[] stateCapital : stateCapitals) {
            System.out.print(""What's the capital of "" + stateCapital[0] + ""? "");
            String userGuess = input.nextLine().trim();

            if (userGuess.equalsIgnoreCase(stateCapital[1])) {
                System.out.println(""Correct!"");
                correctCount++;
            } else {
                System.out.println(""Incorrect. The capital of "" + stateCapital[0] + "" is "" + stateCapital[1] + ""."");
            }
        }

        System.out.println(""\nYou got "" + correctCount + "" out of "" + stateCapitals.length + "" correct."");
    }
}",0.4636795655125594
0_Exercise08_17.java," /**
 * ***8.17 (Financial tsunami) Banks lend money to each other. In tough economic times,
 * if a bank goes bankrupt, it may not be able to pay back the loan. A bank’s
 * total assets are its current balance plus its loans to other banks. The diagram in
 * Figure 8.8 shows five banks. The banks’ current balances are 25, 125, 175, 75,
 * and 181 million dollars, respectively. The directed edge from node 1 to node 2
 * indicates that bank 1 lends 40 million dollars to bank 2.
 * <p>
 * If a bank’s total assets are under a certain limit, the bank is unsafe. The money it
 * borrowed cannot be returned to the lender, and the lender cannot count the loan in
 * its total assets. Consequently, the lender may also be unsafe, if its total assets are
 * under the limit.
 * <p>
 * Write a program to find all the unsafe banks. Your program reads
 * the input as follows. It first reads two integers n and limit, where n indicates the
 * number of banks and limit is the minimum total assets for keeping a bank safe. It
 * then reads n lines that describe the information for n banks with IDs from 0 to n-1.
 * <p>
 * The first number in the line is the bank’s balance, the second number indicates
 * the number of banks that borrowed money from the bank, and the rest are pairs
 * of two numbers. Each pair describes a borrower. The first number in the pair
 * is the borrower’s ID and the second is the amount borrowed. For example, the
 * input for the five banks in Figure 8.8 is as follows (note that the limit is 201):
 * <p>
 * 5 201                            -> n, limit
 * 25 2 1 100.5 4 320.5          -> bank 0's balance, number of loans, loan to bank 1, $100.5, loan to bank 4, $320.5
 * 125 2 2 40 3 85
 * 175 2 0 125 3 75
 * 75 1 0 125
 * 181 1 2 125
 * <p>
 * The total assets of bank 3 are (75 + 125), which is under 201, so bank 3 is
 * unsafe. After bank 3 becomes unsafe, the total assets of bank 1 fall below
 * (125 + 40). Thus, bank 1 is also unsafe.
 * <p>
 * The output of the program should be
 * Unsafe banks are 3 1
 * <p>
 * (Hint: Use a two-dimensional array borrowers to represent loans.
 * borrowers[i][j] indicates the loan that bank i loans to bank j. Once bank j
 * becomes unsafe, borrowers[i][j] should be set to 0.)
 * FIGURE 8.8 Banks lend money to each other.
 *
 * @author Harry D.
 */","package ch_08;

import java.util.*;


public class Exercise08_17 {
    static boolean test = false;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
/*       It first reads two integers n and limit, where n indicates the number of banks and
         limit is the minimum total assets for keeping a bank safe. */
        System.out.println(""Exercise09_09 input (All input at once):"");
        String lineOne = in.nextLine();
        String[] lOne = lineOne.split("" "");
        int n = Integer.parseInt(lOne[0]);
        int limit = Integer.parseInt(lOne[1]);

        double[][] banks = new double[n][];
        /* then reads n lines that describe the information for n banks with IDs from 0 to n-1. */
        for (int i = 0; i < n; i++) {
            String line = in.nextLine();
            String[] lineValues = line.split("" "");
            double[] bank = new double[lineValues.length];

            for (int j = 0; j < lineValues.length; j++) {
                if (!lineValues[j].isEmpty())
                    bank[j] = Double.parseDouble(lineValues[j]);
            }
            banks[i] = bank;
        }

        double[][] borrowers = getBorrowers(banks);
        if (test) {
            System.out.println(""Check borrowers result. Vertical index = Lending bank id, Horizontal index Borrower "" +
                    ""banks id: "");
            for (int i = 0; i < borrowers.length; i++) {
                System.out.print(""Bank id# "" + i + "" has the following loans: "");
                System.out.println(Arrays.toString(borrowers[i]));
            }
        }
        int[] unsafeBanks = evaluateSafety(banks, borrowers, limit);

        System.out.print(""Unsafe banks: "");
        for (int i = 0; i < unsafeBanks.length; i++) {
            if (unsafeBanks[i] == 1)
                System.out.print(i + "" "");
        }


    }

    static int[] evaluateSafety(double[][] banks, double[][] borrowers, double limit) {
        int[] unsafeBanks = new int[borrowers.length];

        for (int i = 0; i < borrowers.length; i++) {
            if (unsafeBanks[i] == 1) continue;
            ;
            double assets = banks[i][0]; // Bank i's current balance

            for (int j = 0; j < borrowers[i].length; j++) {
                assets += borrowers[i][j];
            }
            if (assets < limit) {
                unsafeBanks[i] = 1;
                handleUnsafeBank(borrowers, i); //Remove loans to unsafe bank
                i = 0; //Re-check all banks with new unsafe bank values removed
            }
        }
        return unsafeBanks;
    }

    static void handleUnsafeBank(double[][] borrowers, int j) { //j = bank Id
        for (int i = 0; i < borrowers.length; i++) {
            // Sets all loans owed by bank id -> j to 0.0
            // The lender cannot count the loan in its total assets, for banks which are unsafe
            borrowers[i][j] = 0.0;
        }
//        return borrowers;
    }

    private static double[][] getBorrowers(double[][] banks) {
        double[][] borrowers = new double[banks.length][];
        for (int i = 0; i < banks.length; i++) {

            double numBorrowers = banks[i][1]; // second number indicates the # of banks that borrowed from the bank
            int numBorrower = (int) (numBorrowers);
            double[] borrower = new double[banks.length];

            for (int x = 2; x < banks[i].length; x += 2) {
                double brwer = banks[i][x];
                int j = (int) (brwer);           // The id of the borrower is j == index in borrower array
                borrower[j] = banks[i][x + 1];   // index x is 2 or 4 or 6 than the value is index 3,5,7

            }            /* the rest are pairs of numbers. Each pair describes a borrower.
            The first number in the pair is the borrower’s ID and the second is the amount borrowed */
            borrowers[i] = borrower;
        }
        return borrowers;

    }
}

","import java.util.*;

public class UnsafeBanks {
    static double[][] borrowers;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        double limit = scanner.nextDouble();
        borrowers = new double[n][n];

        // Read the input
        double[] balances = new double[n];
        int[] numBorrowers = new int[n];
        for (int i = 0; i < n; i++) {
            balances[i] = scanner.nextDouble();
            numBorrowers[i] = scanner.nextInt();
            for (int j = 0; j < numBorrowers[i]; j++) {
                int borrower = scanner.nextInt();
                double amount = scanner.nextDouble();
                borrowers[i][borrower] = amount;
            }
        }

        boolean[] isUnsafe = new boolean[n];
        Arrays.fill(isUnsafe, false);

        // Check the safety of all banks
        for (int i = 0; i < n; i++) {
            if (!isUnsafe[i]) {
                checkSafety(i, isUnsafe, balances, limit);
            }
        }

        // Print the unsafe banks
        System.out.print(""Unsafe banks are "");
        boolean first = true;
        for (int i = 0; i < n; i++) {
            if (isUnsafe[i]) {
                if (!first) {
                    System.out.print("" "");
                }
                System.out.print(i);
                first = false;
            }
        }
        System.out.println();
    }

    public static boolean checkSafety(int bank, boolean[] isUnsafe, double[] balances, double limit) {
        // If the bank is already marked as unsafe, return true
        if (isUnsafe[bank]) {
            return true;
        }

        double totalAssets = balances[bank];
        boolean allBorrowersSafe = true;
        for (int i = 0; i < borrowers[bank].length; i++) {
            if (borrowers[bank][i] > 0) {
                totalAssets += borrowers[bank][i];
                if (!checkSafety(i, isUnsafe, balances, limit)) {
                    allBorrowersSafe = false;
                } else {
                    borrowers[bank][i] = 0;
                }
            }
        }

        // Mark the bank as unsafe if its total assets are less than the limit
        if (totalAssets < limit) {
            isUnsafe[bank] = true;
            return false;
        }

        // Mark the bank as unsafe if any of its borrowers are unsafe
        if (!allBorrowersSafe) {
            isUnsafe[bank] = true;
            return false;
        }

        return true;
    }
}",1,"import java.util.Scanner;

public class UnsafeBanksFinder {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the number of banks and the limit: "");
        int n = input.nextInt();
        double limit = input.nextDouble();

        double[] balances = new double[n];
        double[][] borrowers = new double[n][n];

        for (int i = 0; i < n; i++) {
            System.out.print(""Enter balance and number of loans for bank "" + i + "": "");
            balances[i] = input.nextDouble();

            int numLoans = input.nextInt();
            for (int j = 0; j < numLoans; j++) {
                int borrowerId = input.nextInt();
                double amount = input.nextDouble();
                borrowers[i][borrowerId] = amount;
            }
        }

        boolean[] unsafe = new boolean[n];

        for (int i = 0; i < n; i++) {
            double totalAssets = balances[i];
            for (int j = 0; j < n; j++) {
                totalAssets += borrowers[j][i]; // Calculate total assets by adding loans from other banks
            }

            if (totalAssets < limit) {
                unsafe[i] = true; // Mark the bank as unsafe
            }
        }

        System.out.print(""Unsafe banks are: "");
        for (int i = 0; i < n; i++) {
            if (unsafe[i]) {
                System.out.print(i + "" "");
            }
        }

        input.close();
    }
}",0.5264900662251656
0_Exercise08_36.java," /**
 * **8.36 (Latin square) A Latin square is an n-by-n array filled with n different Latin letters,
 * each occurring exactly once in each row and once in each column.
 * <p>
 * Write a program that prompts the user to enter the number n and the array of characters,
 * as shown in the sample output, and checks if the input array is a Latin square.
 * The characters are the first n characters starting from A.
 * Enter number n: 3
 * Enter 3 rows of letters separated by spaces:
 * A F D
 * Wrong input: the letters must be from A to C
 * <p>
 * Enter number n: 4
 * Enter 4 rows of letters separated by spaces:
 * A B C D
 * B A D C
 * C D B A
 * D C A B
 * The input array is a Latin square
 *
 * @author Harry Dulaney
 */","package ch_08;

import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;

import java.util.*;


public class Exercise08_36 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        boolean result = true;
        System.out.print(""\nEnter number n: "");
        int numRows = in.nextInt();
        final int minChar = 'A';
        List<Integer> rowTracker = new ArrayList<>();
        List<Integer> colTracker = new ArrayList<>();
        char[][] chars = new char[numRows][numRows];

        int upperBoundChar = minChar + numRows - 1; //Upper Bound for the range from 'A' -> ('A' + userInput)
        System.out.println(""\nEnter "" + numRows + "" rows of capital letters separated by spaces: "");
        try {
            for (int r = 0; r < chars.length; r++) {
                for (int c = 0; c < chars[r].length; c++) {
                    String strCh = in.next();
                    chars[r][c] = strCh.charAt(0);
                }
            }
            for (int r = 0; r < chars.length; r++) {
                System.out.println(Arrays.toString(chars[r]));
            }
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getLocalizedMessage());
            System.out.println(""The input array is not a Latin Square."");
            System.exit(0);
        }

        ROW:
        for (int i = 0; i < chars.length; i++) {
            if (chars[i].length != numRows) {
                System.out.println(""Invalid input: Line "" + i + "" has length of "" + chars[i].length + "",but should "" +
                        ""have a length of "" + numRows);
                result = false;
                break;
            }

            if (rowTracker.size() > 0) {
                rowTracker.clear();
            }
            for (int j = 0; j < chars[i].length; j++) {
                int charValue = chars[i][j];
                if (charValue < minChar || charValue > upperBoundChar) {
                    System.out.println(""Invalid input: Letters should be between "" + minChar + "" and "" + upperBoundChar);
                    break ROW;

                } else if (rowTracker.size() != 0) {
                    if (rowTracker.contains(charValue)) {
                        System.out.println(""The input array is not a Latin Square."");
                        result = false;
                        break ROW;
                    }
                }
                rowTracker.add(charValue);

            }

        }
        if (result) {
            OUTER:
            for (int column = 0; column < numRows; column++) {
                if (column > 0) {
                    colTracker.clear();
                }
                for (int row = 0; row < chars.length; row++) {
                    int value = chars[row][column];

                    if (colTracker.size() > 0) {
                        if (colTracker.contains(value)) {
                            System.out.println(""The input array is not a Latin Square."");
                            break OUTER;
                        }
                    }
                    colTracker.add(value);
                }
            }
        }
        in.close();
    }
}","import java.util.*;

public class LatinSquareChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter number n: "");
        int n = scanner.nextInt();
        
        // Read the array of characters
        char[][] grid = new char[n][n];
        System.out.println(""Enter "" + n + "" rows of letters separated by spaces:"");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                String s = scanner.next();
                if (s.length() != 1 || s.charAt(0) < 'A' || s.charAt(0) >= 'A' + n) {
                    System.out.println(""Wrong input: the letters must be from A to "" + (char)('A' + n - 1));
                    return;
                }
                grid[i][j] = s.charAt(0);
            }
        }
        
        // Check if it's a Latin square
        for (int i = 0; i < n; i++) {
            boolean[] rowUsed = new boolean[n];
            boolean[] colUsed = new boolean[n];
            for (int j = 0; j < n; j++) {
                if (rowUsed[grid[i][j] - 'A'] || colUsed[grid[j][i] - 'A']) {
                    System.out.println(""The input array is not a Latin square"");
                    return;
                }
                rowUsed[grid[i][j] - 'A'] = true;
                colUsed[grid[j][i] - 'A'] = true;
            }
        }
        System.out.println(""The input array is a Latin square"");
    }
}",1,"import java.util.Scanner;

public class LatinSquareChecker {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter number n: "");
        int n = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character

        System.out.println(""Enter "" + n + "" rows of letters separated by spaces:"");

        char[][] square = new char[n][n];
        for (int i = 0; i < n; i++) {
            String rowInput = scanner.nextLine();
            String[] letters = rowInput.split("" "");

            if (letters.length != n || !validateLetters(letters, n)) {
                System.out.println(""Wrong input: the letters must be from A to "" + (char)('A' + n - 1));
                return;
            }

            for (int j = 0; j < n; j++) {
                square[i][j] = letters[j].charAt(0);
            }
        }

        boolean isLatinSquare = checkLatinSquare(square, n);
        if (isLatinSquare) {
            System.out.println(""The input array is a Latin square"");
        } else {
            System.out.println(""The input array is not a Latin square"");
        }
    }

    private static boolean validateLetters(String[] letters, int n) {
        for (String letter : letters) {
            char current = letter.charAt(0);
            if (current < 'A' || current > (char)('A' + n - 1)) {
                return false;
            }
        }
        return true;
    }

    private static boolean checkLatinSquare(char[][] square, int n) {
        for (int i = 0; i < n; i++) {
            boolean[] rowCheck = new boolean[n];
            boolean[] colCheck = new boolean[n];

            for (int j = 0; j < n; j++) {
                if (rowCheck[square[i][j] - 'A'] || colCheck[square[j][i] - 'A']) {
                    return false;
                }
                rowCheck[square[i][j] - 'A'] = true;
                colCheck[square[j][i] - 'A'] = true;
            }
        }
        return true;
    }
}",0.6326070623591284
0_Exercise08_20.java," /**
 * ***8.20 (Game: connect four) Connect four is a two-player board game in which the
 * players alternately drop colored disks into a seven-column, six-row vertically
 * suspended grid, as shown below.
 * The objective of the game is to connect four same-colored disks in a row, a column, or a diagonal before your opponent can do likewise. The program prompts
 * two players to drop a red or yellow disk alternately. In the preceding figure, the
 * red disk is shown in a dark color and the yellow in a light color. Whenever a disk
 * is dropped, the program will redisplay the board on the console and determines the
 * status of the game (win, draw, or continue).
 * <p>
 * Here is a sample run:
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * ———————————————
 * * Drop a red disk at column (0–6): 0
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * |R| | | | | | |
 * ———————————————
 * Drop a yellow disk at column (0–6): 3
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * | | | | | | | |
 * |R| | |Y| | | |
 * . . .
 * . . .
 * . . .
 * Drop a yellow disk at column (0–6): 6
 * | | | | | | | |
 * | | | | | | | |
 * | | | |R| | | |
 * | | | |Y|R|Y| |
 * | | |R|Y|Y|Y|Y|
 * |R|Y|R|Y|R|R|R|
 * ———————————————
 * The yellow player won
 *
 * @author Harry D.
 */","package ch_08;

import java.util.*;


public class Exercise08_20 {
    private static final String RED = ""R"";
    private static final String YELLOW = ""Y"";
    private static final String WIN = ""win"";
    private static final String CONTINUE = ""continue"";
    private static final String DRAW = ""draw"";
    private static final String EMPTY = "" "";
    private static final String DASH = ""-"";
    private static final String SEP = ""|"";

    static boolean turn = true; //false is reds turn

    public static void main(String[] args) {
        int numMoves = 0;
        String[][] board = new String[6][7];
        for (String[] strings : board) {
            Arrays.fill(strings, EMPTY);
        }
        Scanner in = new Scanner(System.in);
        String result = CONTINUE; //Initialize result of a move
        while (true) {
            turn = !turn; //Other players turn
            int move = printBoard(board, turn ? YELLOW : RED, in);
            playerMove(move, board, turn ? YELLOW : RED);
            result = evaluateGame(board);
            if (result.equals(WIN)) {
                printBoard(board);
                if (turn) { // Yellow won
                    System.out.println(""The yellow player won."");
                } else { // Red Won
                    System.out.println(""The red player won."");
                }
                break;
            } else if (result.equals(DRAW)) {
                System.out.println(""The game is a draw."");
            }

        }

    }

    static void playerMove(int column, String[][] board, String player) {

        for (int r = (board.length - 1); r >= 0; r--) {
            String val = board[r][column];
            if (val.equals(EMPTY)) {
                board[r][column] = player;
                break;
            }
        }

    }

    static String evaluateGame(String[][] board) {
        int redPoints;
        int yellowPoints = 0;

        /* Check rows */
        for (int r = 0; r < board.length; r++) {
            redPoints = 0;
            yellowPoints = 0;
            for (int c = 0; c < board[r].length; c++) {
                String g = board[r][c];
                if (!g.equals(EMPTY)) {
                    if (g.equals(RED)) {
                        redPoints++;
                        yellowPoints = 0;
                    } else if (g.equals(YELLOW)) {
                        yellowPoints++;
                        redPoints = 0;
                    }
                    if (redPoints >= 4) {
                        return WIN;
                    } else if (yellowPoints >= 4) {
                        return WIN;
                    }
                } else {
                    redPoints = 0;
                    yellowPoints = 0;
                }
            }


        }

        /* Check Columns */
        for (int c = 0; c < board[0].length; c++) {
            redPoints = 0;
            yellowPoints = 0;
            for (int r = 0; r < board.length; r++) {
                String g = board[r][c];
                if (!g.equals(EMPTY)) {
                    if (g.equals(RED)) {
                        redPoints++;
                        yellowPoints = 0;
                    } else if (g.equals(YELLOW)) {
                        yellowPoints++;
                        redPoints = 0;
                    }
                    if (redPoints >= 4) {
                        return WIN;
                    }
                    if (yellowPoints >= 4) {
                        return WIN;
                    }

                } else {
                    redPoints = 0;
                    yellowPoints = 0;
                }
            }
        }


        /* Check Diagonals */
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                String g = board[r][c];
                if (!g.equals(EMPTY)) {
                    if (g.equals(RED)) {
                        redPoints = 1;
                        /* Check down and right diagonal */
                        for (int d = 1; (r + d) < board.length && (c + d) < board[r].length; d++) {
                            if (board[r + d][c + d].equals(RED)) {
                                redPoints++;
                            } else {
                                break;
                            }
                            if (redPoints == 4) {
                                return WIN;
                            }
                        }
                        redPoints = 1;
                        /* Check up and right diagonal */
                        for (int d = 1; (r - d) >= 0 && (c + d) < board[r].length; d++) {
                            if (board[r - d][c + d].equals(RED)) {
                                redPoints++;
                            } else {
                                break;
                            }
                            if (redPoints == 4) {
                                return WIN;
                            }
                        }
                        redPoints = 1;
                        /* Check down and left diagonal */
                        for (int d = 1; (r + d) < board.length && (c - d) >= 0; d++) {
                            if (board[r + d][c - d].equals(RED)) {
                                redPoints++;
                            } else {
                                break;
                            }
                            if (redPoints == 4) {
                                return WIN;
                            }
                        }
                        redPoints = 1;
                        /* Check up and left diagonal */
                        for (int d = 1; (r - d) >= 0 && (c - d) >= 0; d++) {
                            if (board[r - d][c - d].equals(RED)) {
                                redPoints++;
                            } else {
                                break;
                            }
                            if (redPoints == 4) {
                                return WIN;
                            }
                        }
                    } else if (g.equals(YELLOW)) {
                        yellowPoints = 1;
                        /* Check down and right diagonal */
                        for (int d = 1; (r + d) < board.length && (c + d) < board[r].length; d++) {
                            if (board[r + d][c + d].equals(YELLOW)) {
                                yellowPoints++;
                            } else {
                                break;
                            }
                            if (yellowPoints == 4) {
                                return WIN;
                            }
                        }
                        yellowPoints = 1;
                        /* Check up and right diagonal */
                        for (int d = 1; (r - d) >= 0 && (c + d) < board[r].length; d++) {
                            if (board[r - d][c + d].equals(YELLOW)) {
                                yellowPoints++;
                            } else {
                                break;
                            }
                            if (yellowPoints == 4) {
                                return WIN;
                            }
                        }
                        yellowPoints = 1;
                        /* Check down and left diagonal */
                        for (int d = 1; (r + d) < board.length && (c - d) >= 0; d++) {
                            if (board[r + d][c - d].equals(YELLOW)) {
                                yellowPoints++;
                            } else {
                                break;
                            }
                            if (yellowPoints == 4) {
                                return WIN;
                            }
                        }
                        yellowPoints = 1;
                        /* Check up and left diagonal */
                        for (int d = 1; (r - d) >= 0 && (c - d) >= 0; d++) {
                            if (board[r - d][c - d].equals(YELLOW)) {
                                yellowPoints++;
                            } else {
                                break;
                            }
                            if (yellowPoints == 4) {
                                return WIN;
                            }
                        }

                    }
                }
            }
        }
        return CONTINUE;

    }

    static int printBoard(String[][] board, String player, Scanner in) {
        printBoard(board);
        System.out.print(""Drop a "" + (player.equals(RED) ? ""red"" : ""yellow"") + "" disk at column (0"" + DASH + ""6): "");
        int move = in.nextInt();
        return move;
    }

    static void printBoard(String[][] board) {
        for (String[] strings : board) {
            for (String s : strings) {
                System.out.print(SEP + s);
            }
            System.out.println(SEP);
        }
        System.out.println(DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH + DASH);


    }
}","import java.util.Scanner;

public class ConnectFour {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        char[][] board = new char[6][7]; // Define the game board
        initializeBoard(board); // Initialize the board to empty spaces
        char player = 'R'; // Start with player 1 (red)
        boolean gameOver = false;

        while (!gameOver) {
            printBoard(board); // Print the current board state
            int column = getColumn(scanner, player); // Prompt the current player to choose a column
            int row = dropDisk(board, column, player); // Drop the disk in the chosen column
            if (checkWin(board, row, column)) { // Check if the player has won
                System.out.println(player + "" wins!"");
                gameOver = true;
            } else if (isBoardFull(board)) { // Check if the board is full (i.e. a draw)
                System.out.println(""Draw!"");
                gameOver = true;
            } else {
                player = switchPlayer(player); // Switch to the other player
            }
        }
    }

    // Initializes the board to empty spaces
    public static void initializeBoard(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                board[i][j] = ' ';
            }
        }
    }

    // Prints the current board state
    public static void printBoard(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[0].length; j++) {
                System.out.print(""|"" + board[i][j]);
            }
            System.out.println(""|"");
        }
        System.out.println(""---------------"");
        System.out.println("" 0 1 2 3 4 5 6"");
    }

    // Prompts the current player to choose a column
    public static int getColumn(Scanner scanner, char player) {
        System.out.print(""Drop a "" + player + "" disk at column (0-6): "");
        int column = scanner.nextInt();
        return column;
    }

    // Drops the disk in the chosen column and returns the row where it landed
    public static int dropDisk(char[][] board, int column, char player) {
        for (int i = board.length - 1; i >= 0; i--) {
            if (board[i][column] == ' ') {
                board[i][column] = player;
                return i;
            }
        }
        return -1; // Column is full
    }

    // Switches to the other player
    public static char switchPlayer(char player) {
        if (player == 'R') {
            return 'Y';
        } else {
            return 'R';
        }
    }

    // Checks if the player has won
    public static boolean checkWin(char[][] board, int row, int column) {
        char player = board[row][column];

        // Check horizontal
        int count = 0;
        for (int j = 0; j < board[0].length; j++) {
            if (board[row][j] == player) {
                count++;
                if (count == 4) {
                    return true;
                }
            } else {
                count = 0;
            }
        }

        // Check vertical
        count = 0;
        for (int i = 0; i < board.length;",1,"import java.util.Scanner;

public class ConnectFour {
    public static void main(String[] args) {
        char[][] board = new char[6][7]; // Initializing the game board
        initializeBoard(board); // Setting up the initial empty board
        boolean gameOver = false; // Flag to track game end
        char currentPlayer = 'R'; // Starting player with red disk

        while (!gameOver) {
            displayBoard(board); // Displaying the current board

            int column = getColumn(currentPlayer); // Asking for player input

            dropDisk(board, column, currentPlayer); // Dropping the disk

            if (isWinner(board, currentPlayer)) {
                displayBoard(board);
                System.out.println(""The "" + currentPlayer + "" player won!"");
                gameOver = true; // Game ends if a player wins
            } else if (isBoardFull(board)) {
                displayBoard(board);
                System.out.println(""It's a draw!"");
                gameOver = true; // Game ends if the board is full
            } else {
                currentPlayer = (currentPlayer == 'R') ? 'Y' : 'R'; // Switching players
            }
        }
    }

    // Initialize the board with empty spaces
    public static void initializeBoard(char[][] board) {
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 7; j++) {
                board[i][j] = ' ';
            }
        }
    }

    // Display the current board state
    public static void displayBoard(char[][] board) {
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(""|"" + board[i][j]);
            }
            System.out.println(""|"");
        }
        System.out.println(""-----------------"");
    }

    // Get the column where the player wants to drop the disk
    public static int getColumn(char currentPlayer) {
        Scanner scanner = new Scanner(System.in);
        int column;
        do {
            System.out.print(""Drop a "" + currentPlayer + "" disk at column (0–6): "");
            column = scanner.nextInt();
        } while (column < 0 || column > 6);
        return column;
    }

    // Drop the disk into the specified column
    public static void dropDisk(char[][] board, int column, char currentPlayer) {
        for (int i = 5; i >= 0; i--) {
            if (board[i][column] == ' ') {
                board[i][column] = currentPlayer;
                break;
            }
        }
    }

    // Check if the current player has connected four disks
    public static boolean isWinner(char[][] board, char currentPlayer) {
        // TODO: Implement the logic to check for a winner
        return false; // Placeholder return
    }

    // Check if the board is full (resulting in a draw)
    public static boolean isBoardFull(char[][] board) {
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 7; j++) {
                if (board[i][j] == ' ') {
                    return false; // If there's an empty space, the board is not full
                }
            }
        }
        return true; // Board is full
    }
}",0.6968253968253968
0_Exercise08_35.java," /**
 * *8.35 (Largest block) Given a square matrix with the elements 0 or 1, write a program
 * to find a maximum square submatrix whose elements are all 1s. Your program
 * should prompt the user to enter the number of rows in the matrix. The program
 * then displays the location of the first element in the maximum square submatrix
 * and the number of the rows in the submatrix.
 * <p>
 * Your program should implement and use the following method to find the maximum
 * square submatrix:
 * public static int[] findLargestBlock(int[][] m)
 * The return value is an array that consists of three values. The first two values are
 * the row and column indices for the first element in the submatrix, and the third
 * value is the number of the rows in the submatrix.
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_35 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the number of rows in the matrix: "");
        final int numRows = input.nextInt();

        int[][] userMatrix = new int[numRows][numRows];
        System.out.println(""Enter the matrix row by row (0 or 1 values only): "");

        for (int i = 0; i < userMatrix.length; i++) {
            for (int j = 0; j < userMatrix[i].length; j++) {
                userMatrix[i][j] = input.nextInt();
            }
        }
        int[] largestBlock = findLargestBlock(userMatrix);

        System.out.printf(""The maximum submatrix square is at (%d,%d) and it has %d number of rows.""
                , largestBlock[0], largestBlock[1], largestBlock[2]);
    }

    private static int[] findLargestBlock(int[][] m) {
        int i, j;
        final int rowLength = m.length;
        final int columnLength = m[0].length;
        int[][] easyCopy = new int[rowLength][columnLength];

        int easyCopyMax, maxI, maxJ;
        for (i = 0; i < rowLength; i++)
            easyCopy[i][0] = m[i][0];
        for (j = 0; j < columnLength; j++)
            easyCopy[0][j] = m[0][j];

        for (i = 1; i < rowLength; i++) {
            for (j = 1; j < columnLength; j++) {
                if (m[i][j] == 1) {
                    easyCopy[i][j] = Math.min(easyCopy[i][j - 1],
                            Math.min(easyCopy[i - 1][j], easyCopy[i - 1][j - 1])) + 1;
                } else {
                    easyCopy[i][j] = 0;
                }
            }
        }

        easyCopyMax = easyCopy[0][0];
        maxI = 0;
        maxJ = 0;
        for (i = 0; i < rowLength; i++) {
            for (j = 0; j < columnLength; j++) {
                if (easyCopyMax < easyCopy[i][j]) {
                    easyCopyMax = easyCopy[i][j];
                    maxI = i;
                    maxJ = j;
                }
            }
        }
        int[] result = new int[3];
        int countRow = 0;
        for (i = maxI; i > maxI - easyCopyMax; i--) {
            countRow++;
            for (j = maxJ; j > maxJ - easyCopyMax; j--) {
                System.out.print(m[i][j] + "" "");
                result[0] = i;
                result[1] = j;
            }
            System.out.println();
        }
        result[2] = countRow;
        return result;
    }

}
","import java.util.Scanner;

public class MaximumSquareSubmatrix {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the number of rows in the matrix: "");
        int n = input.nextInt();

        int[][] matrix = new int[n][n];
        System.out.println(""Enter the elements of the matrix (0 or 1):"");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = input.nextInt();
            }
        }

        int[] result = findLargestBlock(matrix);

        System.out.println(""The maximum square submatrix starts at ("" + result[0] + "", "" + result[1] + "")"");
        System.out.println(""It has "" + result[2] + "" rows."");
    }

    public static int[] findLargestBlock(int[][] m) {
        int maxBlockSize = 0;
        int[] maxBlockLocation = new int[2];

        int n = m.length;
        int[][] dp = new int[n][n];

        // Fill the first row and column of the dp array
        for (int i = 0; i < n; i++) {
            dp[i][0] = m[i][0];
            dp[0][i] = m[0][i];
        }

        // Compute the remaining entries of the dp array
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < n; j++) {
                if (m[i][j] == 1) {
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
                    if (dp[i][j] > maxBlockSize) {
                        maxBlockSize = dp[i][j];
                        maxBlockLocation[0] = i - maxBlockSize + 1;
                        maxBlockLocation[1] = j - maxBlockSize + 1;
                    }
                }
            }
        }

        int[] result = new int[3];
        result[0] = maxBlockLocation[0];
        result[1] = maxBlockLocation[1];
        result[2] = maxBlockSize;
        return result;
    }
}",2,"import java.util.Scanner;

public class LargestBlockFinder {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter the number of rows in the matrix: "");
        int rows = scanner.nextInt();

        int[][] matrix = new int[rows][rows];

        System.out.println(""Enter the elements of the matrix (0s and 1s):"");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < rows; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        int[] largestBlockInfo = findLargestBlock(matrix);
        int rowIdx = largestBlockInfo[0];
        int colIdx = largestBlockInfo[1];
        int blockSize = largestBlockInfo[2];

        System.out.println(""The maximum square submatrix starts at row "" + rowIdx +
                "" and column "" + colIdx + ""."");
        System.out.println(""It has a size of "" + blockSize + "" rows."");
    }

    public static int[] findLargestBlock(int[][] matrix) {
        int[] result = new int[3];
        int maxBlockSize = 0;
        int maxRow = 0;
        int maxCol = 0;

        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] == 1) {
                    int blockSize = checkBlockSize(matrix, i, j);
                    if (blockSize > maxBlockSize) {
                        maxBlockSize = blockSize;
                        maxRow = i;
                        maxCol = j;
                    }
                }
            }
        }

        result[0] = maxRow;
        result[1] = maxCol;
        result[2] = maxBlockSize;

        return result;
    }

    public static int checkBlockSize(int[][] matrix, int row, int col) {
        int size = 1;
        boolean flag = true;

        while (row + size < matrix.length && col + size < matrix[row].length && flag) {
            for (int i = row; i <= row + size; i++) {
                for (int j = col; j <= col + size; j++) {
                    if (matrix[i][j] != 1) {
                        flag = false;
                        break;
                    }
                }
                if (!flag) {
                    break;
                }
            }
            if (flag) {
                size++;
            }
        }

        return size;
    }
}",0.6183666984429615
0_Exercise08_23.java," /**
 * * 8.23 (Game: find the flipped cell) Suppose you are given a 6-by-6 matrix filled with
 * 0s and 1s.
 * <p>
 * All rows and all columns have an even number of 1s. Let the user flip
 * one cell (i.e., flip from 1 to 0 or from 0 to 1) and write a program to find which
 * cell was flipped. Your program should prompt the user to enter a 6-by-6 array
 * with 0s and 1s and find the first row r and first column c where the even number
 * of the 1s property is violated (i.e., the number of 1s is not even). The flipped cell
 * is at (r, c). Here is a sample run:
 * Enter a 6-by-6 matrix row by row:
 * 1 1 1 0 1 1
 * 1 1 1 1 0 0
 * 0 1 0 1 1 1
 * 1 1 1 1 1 1
 * 0 1 1 1 1 0
 * 1 0 0 0 0 1
 * The flipped cell is at (0, 1)
 */","package ch_08;

import java.util.*;


public class Exercise08_23 {
    public static void main(String[] args) {
        int[][] test = new int[6][6];

        Scanner in = new Scanner(System.in);
        System.out.println(""Enter a 6 x 6 matrix row by row: "");

        int invalidRow = -1; //Initialize

        for (int i = 0; i < 6; i++) {
            int rowCountOnes = 0;
            for (int j = 0; j < 6; j++) {
                int n = in.nextInt();
                if (n == 1) {
                    rowCountOnes++;
                }
                test[i][j] = n;
            }
            if (rowCountOnes % 2 != 0) {
                invalidRow = i;
            }
        }
        int invalidCol = evalColumns(test);
        System.out.println(""The flipped cell is at ("" + invalidRow + "", "" + invalidCol + "")"");
        in.close();
    }

    static int evalColumns(int[][] array) {
        int invalidColumn = -1;
        for (int i = 0; i < 6; i++) {
            int colCount = 0;
            for (int j = 0; j < 6; j++) {
                if (array[j][i] == 1) {
                    colCount++;
                }

            }
            if (colCount % 2 != 0) {
                invalidColumn = i;
            }
        }
        return invalidColumn;
    }

}","import java.util.Scanner;

public class FindFlippedCell {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter a 6-by-6 matrix
        System.out.println(""Enter a 6-by-6 matrix row by row:"");
        int[][] matrix = new int[6][6];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = input.nextInt();
            }
        }

        // Find the first row r and first column c where the even number of 1s property is violated
        int row = -1, col = -1;
        for (int i = 0; i < matrix.length; i++) {
            int rowSum = 0, colSum = 0;
            for (int j = 0; j < matrix[i].length; j++) {
                rowSum += matrix[i][j];
                colSum += matrix[j][i];
            }
            if (rowSum % 2 != 0) {
                row = i;
            }
            if (colSum % 2 != 0) {
                col = i;
            }
        }

        // Display the result
        System.out.println(""The flipped cell is at ("" + row + "", "" + col + "")"");
    }
}",2,"import java.util.Scanner;

public class FlippedCellFinder {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[][] matrix = new int[6][6];

        System.out.println(""Enter a 6-by-6 matrix row by row:"");
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 6; j++) {
                matrix[i][j] = input.nextInt();
            }
        }

        int row = -1;
        int col = -1;

        for (int i = 0; i < 6; i++) {
            int rowCount = 0;
            int colCount = 0;

            for (int j = 0; j < 6; j++) {
                rowCount += matrix[i][j];
                colCount += matrix[j][i];
            }

            if (rowCount % 2 != 0) {
                row = i;
            }
            if (colCount % 2 != 0) {
                col = i;
            }
        }

        System.out.println(""The flipped cell is at ("" + row + "", "" + col + "")"");
    }
}",0.7933461292386437
0_Exercise08_19.java," /**
 * **8.19 (Pattern recognition: four consecutive equal numbers) Write the following
 * method that tests whether a two-dimensional array has four consecutive numbers
 * of the same value, either horizontally, vertically, or diagonally.
 * public static boolean isConsecutiveFour(int[][] values)
 * <p>
 * Programming
 * Write a test program that prompts the user to enter the number of rows and columns of a two-dimensional array and then the values in the array and displays
 * true if the array contains four consecutive numbers with the same value. Otherwise, display false. Here are some examples of the true cases:
 * <br>
 * 0 1 0 3 1 6 1    *    0 1 0 3 1 6 1    *   0 1 0 3 1 6 1    *   0 1 0 3 1 6 1
 * 0 1 6 8 6 0 1    *    0 1 6 8 6 0 1    *   0 1 6 8 6 0 1    *   0 1 6 8 6 0 1
 * 9 6 2 1 8 2 9    *    5 6 2 1 8 2 9    *   5 5 2 1 8 2 9    *   5 6 2 1 6 2 9
 * 6 9 6 1 1 9 1    *    6 5 6 1 1 9 1    *   6 5 6 1 1 9 1    *   6 5 6 6 1 9 1
 * 1 3 9 1 4 0 7    *    1 3 6 1 4 0 7    *   1 5 6 1 4 0 7    *   1 3 6 1 4 0 7
 * 3 3 3 9 4 0 7    *    3 3 3 3 4 0 7    *   3 5 3 3 4 0 7    *   3 6 3 3 4 0 7
 * <p>
 *
 * @author Harry D.
 */","package ch_08;

import java.util.*;


public class Exercise08_19 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter the number of rows and columns of a two-dimensional array: "");
        int numRows = in.nextInt();
        int numColumns = in.nextInt();
        int[][] values = new int[numRows][numColumns];
        System.out.println(""Enter the values: "");
        for (int i = 0; i < values.length; i++) {
            for (int j = 0; j < values[i].length; j++) {
                values[i][j] = in.nextInt();
            }
        }

        System.out.println(""Are there four consecutive numbers?"");
        System.out.println(isConsecutiveFour(values));
        in.close();
    }

    public static boolean isConsecutiveFour(int[][] values) {

        int count = 0;
        int lastVal = 0;
        /* Check rows */
        for (int r = 0; r < values.length; r++) {
            count = 0;
            for (int c = 0; c < values[r].length; c++) {
                int val = values[r][c];
                if (val == lastVal) {
                    count++;
                } else {
                    count = 1;
                }
                if (count == 4) {
                    return true;
                }

            }
        }
        lastVal = 0;
        /* Check Columns */
        for (int c = 0; c < values[0].length; c++) {
            count = 0;
            for (int r = 0; r < values.length; r++) {
                int val = values[r][c];
                if (val == lastVal) {
                    count++;
                } else {
                    count = 1;
                }
                if (count == 4) {
                    return true;
                }

            }
        }

        /* Check Diagonals */
        for (int r = 0; r < values.length; r++) {
            for (int c = 0; c < values[r].length; c++) {
                int val = values[r][c];
                count = 1;
                /* Check down and right diagonal */
                for (int d = 1; (r + d) < values.length && (c + d) < values[r].length; d++) {
                    if (values[r + d][c + d] == val) {
                        count++;
                    } else {
                        count = 1;
                        break;
                    }
                    if (count == 4) return true;

                }

                /* Check up and right diagonal */
                for (int d = 1; (r - d) >= 0 && (c + d) < values[r].length; d++) {
                    if (values[r - d][c + d] == val) {
                        count++;
                    } else {
                        count = 1;
                        break;
                    }
                    if (count == 4) return true;
                }

                /* Check down and left diagonal */
                for (int d = 1; (r + d) < values.length && (c - d) >= 0; d++) {
                    if (values[r + d][c - d] == val) {
                        count++;
                    } else {
                        count = 1;
                        break;
                    }
                    if (count == 4) return true;

                }

                /* Check up and left diagonal */
                for (int d = 1; (r - d) >= 0 && (c - d) >= 0; d++) {
                    if (values[r - d][c - d] == val) {
                        count++;
                    } else {
                        count = 1;
                        break;
                    }
                    if (count == 4) return true;

                }
            }

        }
        return false;
    }
}","public static boolean isConsecutiveFour(int[][] values) {
    int numRows = values.length;
    int numCols = values[0].length;

    // Check rows
    for (int i = 0; i < numRows; i++) {
        for (int j = 0; j < numCols - 3; j++) {
            if (values[i][j] == values[i][j+1] && 
                values[i][j+1] == values[i][j+2] && 
                values[i][j+2] == values[i][j+3]) {
                return true;
            }
        }
    }

    // Check columns
    for (int j = 0; j < numCols; j++) {
        for (int i = 0; i < numRows - 3; i++) {
            if (values[i][j] == values[i+1][j] && 
                values[i+1][j] == values[i+2][j] && 
                values[i+2][j] == values[i+3][j]) {
                return true;
            }
        }
    }

    // Check diagonals
    for (int i = 0; i < numRows - 3; i++) {
        for (int j = 0; j < numCols - 3; j++) {
            if (values[i][j] == values[i+1][j+1] &&
                values[i+1][j+1] == values[i+2][j+2] &&
                values[i+2][j+2] == values[i+3][j+3]) {
                return true;
            }
            if (values[i][j+3] == values[i+1][j+2] &&
                values[i+1][j+2] == values[i+2][j+1] &&
                values[i+2][j+1] == values[i+3][j]) {
                return true;
            }
        }
    }

    // If no consecutive four found
    return false;
}",2,"import java.util.Scanner;

public class ConsecutiveNumbers {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.println(""Enter the number of rows: "");
        int rows = scanner.nextInt();
        
        System.out.println(""Enter the number of columns: "");
        int columns = scanner.nextInt();
        
        int[][] array = new int[rows][columns];
        
        System.out.println(""Enter the values in the array: "");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                array[i][j] = scanner.nextInt();
            }
        }
        
        boolean containsConsecutiveFour = isConsecutiveFour(array);
        
        System.out.println(""The array contains four consecutive numbers with the same value: "" + containsConsecutiveFour);
    }

    public static boolean isConsecutiveFour(int[][] values) {
        int rows = values.length;
        int columns = values[0].length;

        // Check horizontally
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns - 3; j++) {
                if (values[i][j] == values[i][j + 1]
                    && values[i][j] == values[i][j + 2]
                    && values[i][j] == values[i][j + 3]) {
                    return true;
                }
            }
        }

        // Check vertically
        for (int j = 0; j < columns; j++) {
            for (int i = 0; i < rows - 3; i++) {
                if (values[i][j] == values[i + 1][j]
                    && values[i][j] == values[i + 2][j]
                    && values[i][j] == values[i + 3][j]) {
                    return true;
                }
            }
        }

        // Check diagonally (top-left to bottom-right)
        for (int i = 0; i < rows - 3; i++) {
            for (int j = 0; j < columns - 3; j++) {
                if (values[i][j] == values[i + 1][j + 1]
                    && values[i][j] == values[i + 2][j + 2]
                    && values[i][j] == values[i + 3][j + 3]) {
                    return true;
                }
            }
        }

        // Check diagonally (bottom-left to top-right)
        for (int i = 3; i < rows; i++) {
            for (int j = 0; j < columns - 3; j++) {
                if (values[i][j] == values[i - 1][j + 1]
                    && values[i][j] == values[i - 2][j + 2]
                    && values[i][j] == values[i - 3][j + 3]) {
                    return true;
                }
            }
        }

        return false;
    }
}",0.6265474552957359
0_Exercise08_03.java," /**
 * *8.3 (Sort students on grades) Rewrite Listing 8.2, GradeExam.java, to
 * display the students in increasing order of the number of correct answers.
 *
 */","package ch_08;



public class Exercise08_03 {

	public static void main(String[] args) {
		// Students' answers to the questions
		char[][] answers = { { 'A', 'B', 'A', 'C', 'C', 'D', 'E', 'E', 'A', 'D' },
				{ 'D', 'B', 'A', 'B', 'C', 'A', 'E', 'E', 'A', 'D' },
				{ 'E', 'D', 'D', 'A', 'C', 'B', 'E', 'E', 'A', 'D' },
				{ 'C', 'B', 'A', 'E', 'D', 'C', 'E', 'E', 'A', 'D' },
				{ 'A', 'B', 'D', 'C', 'C', 'D', 'E', 'E', 'A', 'D' },
				{ 'B', 'B', 'E', 'C', 'C', 'D', 'E', 'E', 'A', 'D' },
				{ 'B', 'B', 'A', 'C', 'C', 'D', 'E', 'E', 'A', 'D' },
				{ 'E', 'B', 'E', 'C', 'C', 'D', 'E', 'E', 'A', 'D' } };
		// Answer Key
		char[] keys = { 'D', 'B', 'D', 'C', 'C', 'D', 'A', 'E', 'A', 'D' };

		// stuScore = integer [totalScore][Student number zero to 7]
		int[][] stuScores = new int[answers.length][2];

		for (int i = 0; i < answers.length; i++) {
			int ptsCount = 0;

			for (int j = 0; j < answers[i].length; j++) {
				if (answers[i][j] == keys[j]) {
					ptsCount++;
				}

				stuScores[i][0] = ptsCount;
				stuScores[i][1] = i; //Track index of student
			}
		}

		// Selection Sort to sort student scores in ascending order
		for (int i = 0; i < stuScores.length - 1; i++) {
		
			for (int j = i + 1; j < stuScores.length; j++) {
				if (stuScores[j][0] < stuScores[i][0]) {
					int[] temp = stuScores[i];
					stuScores[i] = stuScores[j];
					stuScores[j] = temp;
				}
			}

		}

		for (int a = 0; a < stuScores.length; a++) {
			System.out.println(""Student "" + stuScores[a][1] + "": "" + stuScores[a][0]);
		}

	}

}","import java.util.*;

class Student {
    String name;
    int numCorrectAnswers;

    public Student(String name, int numCorrectAnswers) {
        this.name = name;
        this.numCorrectAnswers = numCorrectAnswers;
    }

    public int getNumCorrectAnswers() {
        return numCorrectAnswers;
    }

    @Override
    public String toString() {
        return name + "" - "" + numCorrectAnswers + "" correct answers"";
    }
}

public class SortStudents {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(""Alice"", 8));
        students.add(new Student(""Bob"", 6));
        students.add(new Student(""Charlie"", 9));
        students.add(new Student(""Dave"", 7));

        Collections.sort(students, new Comparator<Student>() {
            @Override
            public int compare(Student s1, Student s2) {
                return Integer.compare(s1.getNumCorrectAnswers(), s2.getNumCorrectAnswers());
            }
        });

        for (Student student : students) {
            System.out.println(student);
        }
    }
}",2,"public class SortStudentsOnGrades {

    public static void main(String[] args) {
        char[][] answers = {
            {'A', 'B', 'A', 'C', 'C', 'D', 'E', 'E', 'A', 'D'},
            {'D', 'B', 'A', 'B', 'C', 'A', 'E', 'E', 'A', 'D'},
            {'E', 'D', 'D', 'A', 'C', 'B', 'E', 'E', 'A', 'D'},
            {'C', 'B', 'A', 'E', 'D', 'C', 'E', 'E', 'A', 'D'},
            {'A', 'B', 'D', 'C', 'C', 'D', 'E', 'E', 'A', 'D'},
            {'B', 'B', 'E', 'C', 'C', 'D', 'E', 'E', 'A', 'D'},
            {'B', 'B', 'A', 'C', 'C', 'D', 'E', 'E', 'A', 'D'},
            {'E', 'B', 'E', 'C', 'C', 'D', 'E', 'E', 'A', 'D'}
        };

        char[] keys = {'D', 'B', 'D', 'C', 'C', 'D', 'A', 'E', 'A', 'D'};

        int[] correctCounts = new int[answers.length];

        for (int i = 0; i < answers.length; i++) {
            int correctCount = 0;
            for (int j = 0; j < answers[i].length; j++) {
                if (answers[i][j] == keys[j]) {
                    correctCount++;
                }
            }
            correctCounts[i] = correctCount;
        }

        sortStudents(answers, correctCounts);

        for (int i = 0; i < answers.length; i++) {
            System.out.println(""Student "" + (i + 1) + "" - Correct Answers: "" + correctCounts[i]);
        }
    }

    public static void sortStudents(char[][] answers, int[] correctCounts) {
        for (int i = 0; i < correctCounts.length - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < correctCounts.length; j++) {
                if (correctCounts[j] < correctCounts[minIndex]) {
                    minIndex = j;
                }
            }

            int tempCount = correctCounts[minIndex];
            correctCounts[minIndex] = correctCounts[i];
            correctCounts[i] = tempCount;

            char[] tempAnswers = answers[minIndex];
            answers[minIndex] = answers[i];
            answers[i] = tempAnswers;
        }
    }
}",0.3355048859934853
0_Exercise08_15.java," /**
 * *8.15 (Geometry: same line?) Programming Exercise 6.39 gives a method for testing
 * whether three points are on the same line.
 * Write the following method to test whether all the points in the array points are
 * on the same line.
 * public static boolean sameLine(double[][] points)
 * Write a program that prompts the user to enter five points and displays whether
 * they are on the same line. Here are sample runs:
 * Enter five points: 3.4 2 6.5 9.5 2.3 2.3 5.5 5 -5 4
 * The five points are not on the same line
 * <p>
 * From Ex 6.39 via Ex 3.32, if
 * (x1 - x0)*(y2 - y0) - (x2 - x0)*(y1 - y0) == 0
 */","package ch_08;

import java.util.*;




public class Exercise08_15 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter five points: "");
        double[][] points = new double[5][5];

        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < 2; j++) {
                points[i][j] = in.nextDouble();
            }
        }

        if (sameLine(points)) {
            System.out.println(""The points are on the same line."");
        } else {
            System.out.println(""The points are not on the same line."");
        }


    }

    static boolean sameLine(double[][] points) {
        for (int i = 0; i < points.length - 2; i++) {
            double det = findDeterminate(points, 0);
            if (det != 0) {
                return false;
            }
        }
        return true;

    }

    static double findDeterminate(double[][] pts, int index) {
        return (pts[index + 1][0] - pts[index][0]) * (pts[index + 2][1] - pts[index][1]) - (pts[index + 2][0] - pts[index][0]) * (pts[index + 1][1] - pts[index][1]);

    }


}","import java.util.Scanner;

public class SameLineTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Read in five points from the user
        double[][] points = new double[5][2];
        System.out.print(""Enter five points: "");
        for (int i = 0; i < 5; i++) {
            points[i][0] = input.nextDouble();
            points[i][1] = input.nextDouble();
        }

        // Check whether the points are on the same line
        if (sameLine(points)) {
            System.out.println(""The five points are on the same line"");
        } else {
            System.out.println(""The five points are not on the same line"");
        }
    }

    public static boolean sameLine(double[][] points) {
    // Make sure we have at least three points
    if (points.length < 3) {
        return true;
    }

    // Calculate the slope between the first two points
    double slope = (points[1][1] - points[0][1]) / (points[1][0] - points[0][0]);

    // Check that all other points have the same slope
    for (int i = 2; i < points.length; i++) {
        double currentSlope = (points[i][1] - points[0][1]) / (points[i][0] - points[0][0]);
        if (currentSlope != slope) {
            return false;
        }
    }

    return true;
    }
}
",2,"import java.util.Scanner;

public class CheckSameLine {
    
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        double[][] points = new double[5][2];
        
        System.out.print(""Enter five points: "");
        for (int i = 0; i < 5; i++) {
            points[i][0] = input.nextDouble();
            points[i][1] = input.nextDouble();
        }
        
        if (arePointsOnSameLine(points)) {
            System.out.println(""The five points are on the same line"");
        } else {
            System.out.println(""The five points are not on the same line"");
        }
        
        input.close();
    }
    
    public static boolean arePointsOnSameLine(double[][] points) {
        if (points.length < 3) {
            return true;
        }
        
        double x0 = points[0][0];
        double y0 = points[0][1];
        
        for (int i = 1; i < points.length - 1; i++) {
            double x1 = points[i][0];
            double y1 = points[i][1];
            double x2 = points[i + 1][0];
            double y2 = points[i + 1][1];
            
            if ((x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0) != 0) {
                return false;
            }
        }
        
        return true;
    }
}",0.7665538907684872
0_Exercise08_14.java," /**
 * **8.14 (Explore matrix) Write a program that prompts the user to enter the length of a
 * square matrix, randomly fills in 0s and 1s into the matrix, prints the matrix, and
 * finds the rows, columns, and diagonals with all 0s or 1s. Here is a sample run of
 * the program:
 * <p>
 * Enter the size for the matrix: 4
 * 0111
 * 0000
 * 0100
 * 1111
 * All 0s on row 1
 * All 1s on row 3
 * No same numbers on a column
 * No same numbers on the major diagonal
 * No same numbers on the sub-diagonal
 */","package ch_08;

import java.util.*;


public class Exercise08_14 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter the size for the the matrix: "");
        int size = in.nextInt();
        int[][] matrix = new int[size][size];

        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                matrix[i][j] = (int) (0.5 + Math.random());
            }
        }
        for (int[] array : matrix) {
            System.out.println(Arrays.toString(array));
        }

        //Check rows
        int[] row = checkRows(matrix);
        //Check columns
        int[] column = checkColumns(matrix);


        if (row != null) {
            System.out.println(""All "" + row[0] + "" on "" + ""row "" + row[1]);
        } else {
            System.out.println(""No same numbers on a row"");
        }

        if (column != null) {
            System.out.println(""All "" + column[0] + "" on "" + ""column "" + column[1]);
        } else {
            System.out.println(""No same numbers on a column"");
        }


    }

    static int[] checkColumns(int[][] matrix) {
        for (int checkNum = 0; checkNum <= 1; checkNum++) {
            for (int i = 0; i < matrix.length; i++) {
                if (checkColumn(matrix, i, checkNum)) {
                    return new int[]{checkNum, i};
                }
            }
        }
        return null;
    }

    static boolean checkColumn(int[][] matrix, int column, int num) {
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[i][column] != num) {
                return false;
            }
        }
        return true;
    }

    static int[] checkRows(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            int rowCheck = matrix[i][0];
            COLUMN:
            for (int j = 0; j < matrix[i].length; j++) {
                if (matrix[i][j] != rowCheck) {
                    break COLUMN;
                } else if (j == matrix[i].length - 1) {
                    return new int[]{rowCheck, i};
                }
            }
        }
        return null;
    }
}","import java.util.*;

public class MatrixExplorer {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the size for the matrix: "");
        int n = input.nextInt();

        // Create a new n x n matrix and fill it with 0s and 1s
        int[][] matrix = new int[n][n];
        Random random = new Random();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = random.nextInt(2);
            }
        }

        // Print the matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j]);
            }
            System.out.println();
        }

        // Check rows for all 0s or 1s
        for (int i = 0; i < n; i++) {
            boolean allZeros = true;
            boolean allOnes = true;
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 1) {
                    allZeros = false;
                } else {
                    allOnes = false;
                }
            }
            if (allZeros) {
                System.out.println(""All 0s on row "" + (i + 1));
            } else if (allOnes) {
                System.out.println(""All 1s on row "" + (i + 1));
            }
        }

        // Check columns for all 0s or 1s
        for (int j = 0; j < n; j++) {
            boolean allZeros = true;
            boolean allOnes = true;
            for (int i = 0; i < n; i++) {
                if (matrix[i][j] == 1) {
                    allZeros = false;
                } else {
                    allOnes = false;
                }
            }
            if (allZeros) {
                System.out.println(""All 0s on column "" + (j + 1));
            } else if (allOnes) {
                System.out.println(""All 1s on column "" + (j + 1));
            }
        }

        // Check major diagonal for same numbers
        boolean allZeros = true;
        boolean allOnes = true;
        for (int i = 0; i < n; i++) {
            if (matrix[i][i] == 1) {
                allZeros = false;
            } else {
                allOnes = false;
            }
        }
        if (allZeros) {
            System.out.println(""All 0s on the major diagonal"");
        } else if (allOnes) {
            System.out.println(""All 1s on the major diagonal"");
        }

        // Check sub-diagonal for same numbers
        allZeros = true;
        allOnes = true;
        for (int i = 0; i < n; i++) {
            if (matrix[i][n - i - 1] == 1) {
                allZeros = false;
            } else {
                allOnes = false;
            }
        }
        if (allZeros) {
            System.out.println(""All 0s on the sub-diagonal"");
        } else if (allOnes) {
            System.out.println(""All 1s on the sub",2,"import java.util.Scanner;

public class MatrixExplorer {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the size for the matrix: "");
        int size = input.nextInt();

        int[][] matrix = new int[size][size];

        // Filling the matrix with random 0s and 1s
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                matrix[i][j] = (int) (Math.random() * 2);
            }
        }

        // Printing the matrix
        System.out.println(""Generated Matrix:"");
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                System.out.print(matrix[i][j]);
            }
            System.out.println();
        }

        // Checking rows for all 0s or 1s
        for (int i = 0; i < size; i++) {
            boolean allZeros = true;
            boolean allOnes = true;
            for (int j = 0; j < size; j++) {
                if (matrix[i][j] != 0) {
                    allZeros = false;
                }
                if (matrix[i][j] != 1) {
                    allOnes = false;
                }
            }
            if (allZeros) {
                System.out.println(""All 0s on row "" + (i + 1));
            }
            if (allOnes) {
                System.out.println(""All 1s on row "" + (i + 1));
            }
        }

        // Checking columns for same numbers
        for (int j = 0; j < size; j++) {
            boolean sameNumbers = true;
            int num = matrix[0][j];
            for (int i = 1; i < size; i++) {
                if (matrix[i][j] != num) {
                    sameNumbers = false;
                    break;
                }
            }
            if (sameNumbers) {
                System.out.println(""All same numbers on column "" + (j + 1));
            }
        }

        // Checking major diagonal for same numbers
        boolean sameMajorDiagonal = true;
        int majorDiagonalNum = matrix[0][0];
        for (int i = 1; i < size; i++) {
            if (matrix[i][i] != majorDiagonalNum) {
                sameMajorDiagonal = false;
                break;
            }
        }
        if (sameMajorDiagonal) {
            System.out.println(""All same numbers on the major diagonal"");
        }

        // Checking sub-diagonal for same numbers
        boolean sameSubDiagonal = true;
        int subDiagonalNum = matrix[size - 1][0];
        for (int i = size - 2, j = 1; i >= 0 && j < size; i--, j++) {
            if (matrix[i][j] != subDiagonalNum) {
                sameSubDiagonal = false;
                break;
            }
        }
        if (sameSubDiagonal) {
            System.out.println(""All same numbers on the sub-diagonal"");
        }

        input.close();
    }
}",0.7682020802377415
0_Exercise08_02.java," /**
 * 8.2 (Sum the major diagonal in a matrix) Write a method that
 * sums all the numbers in the major diagonal in an n � n matrix
 * of double values using the following header:
 * Write a test program that reads a 4-by-4 matrix and
 * displays the sum of all its elements on the major diagonal.
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_02 {
    public static double sumMajorDiagonal(double[][] m) {

        double sum = 0;
        int row = 0;

        for (int column = 0; column < m.length; column++) {

            sum += m[row++][column];
        }
        return sum;

    }

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double[][] fourByfour = new double[4][4];

        System.out.println(""Enter a 4 by 4 matrix row by row: "");

        for (int row = 0; row < fourByfour.length; row++) {
            for (int column = 0; column < fourByfour[row].length; column++) {

                fourByfour[row][column] = input.nextDouble();
            }
        }
        input.close();
        System.out.println(""The sum of the elements in the major diagonal is""
                + "": "" + sumMajorDiagonal(fourByfour));
    }

}
","import java.util.Random;
import java.util.Scanner;

public class MatrixAnalyzer {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter the size for the matrix: "");
        int n = scanner.nextInt();

        int[][] matrix = new int[n][n];

        Random random = new Random();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = random.nextInt(2);
            }
        }

        System.out.println(""The matrix is:"");
        printMatrix(matrix);

        boolean allZerosOrOnes;

        // check rows
        for (int i = 0; i < n; i++) {
            allZerosOrOnes = true;
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] != matrix[i][0]) {
                    allZerosOrOnes = false;
                    break;
                }
            }
            if (allZerosOrOnes) {
                System.out.printf(""All %ds on row %d\n"", matrix[i][0], i + 1);
            }
        }

        // check columns
        for (int j = 0; j < n; j++) {
            allZerosOrOnes = true;
            for (int i = 1; i < n; i++) {
                if (matrix[i][j] != matrix[0][j]) {
                    allZerosOrOnes = false;
                    break;
                }
            }
            if (allZerosOrOnes) {
                System.out.printf(""All %ds on column %d\n"", matrix[0][j], j + 1);
            }
        }

        // check major diagonal
        allZerosOrOnes = true;
        for (int i = 1; i < n; i++) {
            if (matrix[i][i] != matrix[0][0]) {
                allZerosOrOnes = false;
                break;
            }
        }
        if (allZerosOrOnes) {
            System.out.printf(""All %ds on the major diagonal\n"", matrix[0][0]);
        }

        // check sub-diagonal
        allZerosOrOnes = true;
        for (int i = 1; i < n; i++) {
            if (matrix[i][n - i - 1] != matrix[0][n - 1]) {
                allZerosOrOnes = false;
                break;
            }
        }
        if (allZerosOrOnes) {
            System.out.printf(""All %ds on the sub-diagonal\n"", matrix[0][n - 1]);
        }
    }

    public static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            for (int cell : row) {
                System.out.print(cell);
            }
            System.out.println();
        }
    }
}",2,"import java.util.Scanner;

public class DiagonalSum {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        double[][] matrix = new double[4][4];

        System.out.println(""Enter a 4x4 matrix of double values:"");
        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 4; j++) {
                System.out.print(""Enter value for row "" + (i + 1) + "" and column "" + (j + 1) + "": "");
                matrix[i][j] = input.nextDouble();
            }
        }

        double sum = calculateDiagonalSum(matrix);
        System.out.println(""The sum of the numbers in the major diagonal is: "" + sum);
    }

    public static double calculateDiagonalSum(double[][] matrix) {
        double sum = 0.0;
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                if (i == j) {
                    sum += matrix[i][j];
                }
            }
        }
        return sum;
    }
}",0.4490118577075099
0_Exercise08_18.java," /**
 * *8.18 (Shuffle rows) Write a method that shuffles the rows in a two-dimensional int
 * array using the following header:
 * public static void shuffle(int[][] m)
 * Write a test program that shuffles the following matrix:
 * int[][] m = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};
 */","package ch_08;

import java.util.*;


public class Exercise08_18 {
    public static void main(String[] args) {
        int[][] m = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};
        for (int i = 0; i < 10; i++) {
            shuffle(m);
        }
        for (int[] i : m) {
            System.out.print(Arrays.toString(i));
            System.out.print("" "");
        }
    }

    public static void shuffle(int[][] m) {

        for (int i = 0, x = 0; i < m.length; i++) {
            for (int j = 0; j < m[i].length; j++) {
                int temp = m[i][j];

                int r1 = randIdx(m.length - 1);
                int r2 = randIdx(m[i].length - 1);
                if (r1 == i || r2 == j) {
                    continue;
                }
                //Swamp
                m[i][j] = m[r1][r2];
                m[r1][r2] = temp;

            }

        }
    }

    static int randIdx(int upperBound) {
        return (int) (Math.random() * upperBound);
    }
}","public static void shuffle(int[][] m) {
    Random rand = new Random();
    for (int i = m.length - 1; i > 0; i--) {
        int j = rand.nextInt(i + 1);
        int[] temp = m[i];
        m[i] = m[j];
        m[j] = temp;
    }
} public static void main(String[] args) {
    int[][] m = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};
    System.out.println(""Original matrix:"");
    printMatrix(m);
    shuffle(m);
    System.out.println(""Shuffled matrix:"");
    printMatrix(m);
}

public static void printMatrix(int[][] m) {
    for (int i = 0; i < m.length; i++) {
        for (int j = 0; j < m[i].length; j++) {
            System.out.print(m[i][j] + "" "");
        }
        System.out.println();
    }
}",2,"// This program shuffles rows in a 2D array

public class ArrayShuffler {

    public static void main(String[] args) {
        int[][] matrix = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};

        System.out.println(""Original Matrix:"");
        printMatrix(matrix);

        shuffle(matrix);

        System.out.println(""\nShuffled Matrix:"");
        printMatrix(matrix);
    }

    public static void shuffle(int[][] matrix) {
        int numRows = matrix.length;

        for (int i = 0; i < numRows; i++) {
            int randIndex = (int) (Math.random() * numRows);

            int[] temp = matrix[i];
            matrix[i] = matrix[randIndex];
            matrix[randIndex] = temp;
        }
    }

    public static void printMatrix(int[][] matrix) {
        for (int[] row : matrix) {
            for (int num : row) {
                System.out.print(num + "" "");
            }
            System.out.println();
        }
    }
}",0.6010286554004408
0_Exercise08_22.java," /**
 * *8.22 (Even number of 1s) Write a program that generates a 6-by-6 two-dimensional
 * matrix filled with 0s and 1s, displays the matrix, and checks if every row and
 * every column have an even number of 1s.
 *
 * @author Harry D.
 */","package ch_08;

import java.util.*;


public class Exercise08_22 {
    public static void main(String[] args) {
        int[][] a = new int[6][6];
        fillZeroAndOnes(a);
        //Rows check
        for (int j = 0; j < a.length; j++) {
            int numOnes = 0;
            for (int i : a[j]) {
                if (i == 1) numOnes++;
            }
            System.out.print(""Row # "" + (j + 1) + "" "");
            if (numOnes % 2 == 0 && numOnes != 0) {
                System.out.print("" has an even number of ones. "");
            }
            System.out.println(Arrays.toString(a[j]));
        }
        int [] colNums = new int[6];
        //Columns check
        for (int y = 0; y < 6; y++) {
            int numOnes = 0;
            for (int x = 0; x < 6; x++) {
                colNums[x] = a[x][y];
                if (a[x][y] == 1) numOnes++;
            }
            System.out.print(""Column # "" + (y + 1) + "" "");
            if (numOnes % 2 == 0 && numOnes != 0) {
                System.out.print(""has an even number of ones. "");
            }
            System.out.println(Arrays.toString(colNums));
        }
    }

    static void fillZeroAndOnes(int[][] arr) {
        for (int i = 0; i < arr.length; i += getRandom()) {
            for (int j = 0; j < arr[i].length; j += getRandom()) {
                arr[i][j] = 1;
            }
        }
    }

    static int getRandom() {
        return (int) (0.5 + Math.random() * 3);
    }
}","import java.util.Arrays;
import java.util.Random;

public class MatrixChecker {
    
    public static void main(String[] args) {
        // Generate the matrix
        int[][] matrix = generateMatrix(6);
        
        // Print the matrix
        printMatrix(matrix);
        
        // Check if every row and column has an even number of 1s
        if (checkMatrix(matrix)) {
            System.out.println(""Every row and column has an even number of 1s."");
        } else {
            System.out.println(""Not every row and column has an even number of 1s."");
        }
    }
    
    public static int[][] generateMatrix(int size) {
        Random random = new Random();
        int[][] matrix = new int[size][size];
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                matrix[i][j] = random.nextInt(2);
            }
        }
        return matrix;
    }
    
    public static void printMatrix(int[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                System.out.print(matrix[i][j] + "" "");
            }
            System.out.println();
        }
    }
    
    public static boolean checkMatrix(int[][] matrix) {
        int numRows = matrix.length;
        int numCols = matrix[0].length;
        int[] rowCount = new int[numRows];
        int[] colCount = new int[numCols];
        
        // Count the number of 1s in each row and column
        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j < numCols; j++) {
                if (matrix[i][j] == 1) {
                    rowCount[i]++;
                    colCount[j]++;
                }
            }
        }
        
        // Check if every row and column has an even number of 1s
        for (int i = 0; i < numRows; i++) {
            if (rowCount[i] % 2 != 0) {
                return false;
            }
        }
        for (int j = 0; j < numCols; j++) {
            if (colCount[j] % 2 != 0) {
                return false;
            }
        }
        
        return true;
    }
}",2,"import java.util.Random;

public class EvenOnesChecker {
    public static void main(String[] args) {
        int[][] matrix = new int[6][6];
        Random random = new Random();

        // Filling the matrix with 0s and 1s
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                matrix[i][j] = random.nextInt(2); // Randomly choosing 0 or 1
            }
        }

        // Displaying the matrix
        System.out.println(""Generated Matrix:"");
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j] + "" "");
            }
            System.out.println();
        }

        // Checking if every row and column has an even number of 1s
        boolean allRowsEvenOnes = true;
        boolean allColsEvenOnes = true;

        for (int i = 0; i < matrix.length; i++) {
            int rowOnesCount = 0;
            int colOnesCount = 0;

            for (int j = 0; j < matrix[i].length; j++) {
                rowOnesCount += matrix[i][j];
                colOnesCount += matrix[j][i];
            }

            if (rowOnesCount % 2 != 0) {
                allRowsEvenOnes = false;
                break;
            }

            if (colOnesCount % 2 != 0) {
                allColsEvenOnes = false;
                break;
            }
        }

        // Displaying the result
        if (allRowsEvenOnes && allColsEvenOnes) {
            System.out.println(""Every row and column has an even number of 1s."");
        } else {
            System.out.println(""Not every row and column has an even number of 1s."");
        }
    }
}",0.5275261324041812
0_Exercise08_34.java," /**
 * *8.34 (Geometry: rightmost lowest point) In computational geometry, often you need
 * to find the rightmost lowest point in a set of points. Write the following method
 * that returns the rightmost lowest point in a set of points.
 * public static double[] getRightmostLowestPoint(double[][] points)
 * <p>
 * <p>
 * Write a test program that prompts the user to enter the coordinates of six points
 * and displays the rightmost lowest point. Here is a sample run:
 * Enter 6 points: 1.5 2.5 -3 4.5 5.6 -7 6.5 -7 8 1 10 2.5
 * The rightmost lowest point is (6.5, -7.0)
 */","package ch_08;

import java.util.Arrays;
import java.util.Scanner;


public class Exercise08_34 {

    public static void main(String[] args) {
        double[][] pts = new double[6][2];

        Scanner in = new Scanner(System.in);
        System.out.print(""Enter 6 points: "");
        for (int p = 0; p < 6; p++) {
            for (int n = 0; n < 2; n++) {
                pts[p][n] = in.nextDouble();
            }
        }
        System.out.print(""The rightmost point is "" + Arrays.toString(getRightmostLowestPoint(pts)));

    }

    public static double[] getRightmostLowestPoint(double[][] points) {
        double[] lowestRight = points[0];
        double[][] multiLowRights = new double[3][2];

        for (int i = 1; i < points.length; i++) {
            if (lowestRight[1] > points[i][1]) {
                lowestRight = points[i];
            } else if (lowestRight[1] == points[i][1]) {
                for (int z = 0; z < multiLowRights.length; z++) {
                    if (multiLowRights[z][0] == 0.0 && multiLowRights[z][1] == 0.0) {
                        multiLowRights[z] = points[i];
                        multiLowRights[z + 1] = lowestRight;
                        break;
                    }
                }
            }
        }
        if (multiLowRights[0][0] != 0.0 && multiLowRights[0][1] != 0.0 && multiLowRights[1][0] != 0.0 && multiLowRights[1][1] != 0.0) {
            for (int i = 0; i < multiLowRights.length - 1; i++) {
                if (i == 0) {
                    if (multiLowRights[i][0] > multiLowRights[i + 1][0]) {
                        lowestRight = multiLowRights[i];
                    } else {
                        lowestRight = multiLowRights[i + 1];
                    }
                } else {
                    if (multiLowRights[i][0] > lowestRight[0]) {
                        lowestRight = multiLowRights[i];
                    }
                }
            }
        }
        return lowestRight;

    }
}
","public static double[] getRightmostLowestPoint(double[][] points) {
    double[] result = points[0]; // initialize result to the first point
    for (int i = 1; i < points.length; i++) {
        double[] currentPoint = points[i];
        if (currentPoint[1] < result[1] || (currentPoint[1] == result[1] && currentPoint[0] > result[0])) {
            result = currentPoint;
        }
    }
    return result;
}
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        double[][] points = new double[6][2];

        // Prompt the user to enter six points
        System.out.print(""Enter 6 points: "");
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 2; j++) {
                points[i][j] = input.nextDouble();
            }
        }

        // Find the rightmost lowest point
        double[] rightmostLowestPoint = getRightmostLowestPoint(points);

        // Display the result
        System.out.printf(""The rightmost lowest point is (%.1f, %.1f)"", rightmostLowestPoint[0], rightmostLowestPoint[1]);
    }
}",2,"import java.util.Scanner;

public class RightmostLowestPointFinder {

    public static double[] getRightmostLowestPoint(double[][] points) {
        double[] rightmostLowestPoint = points[0];

        for (int i = 1; i < points.length; i++) {
            if (points[i][1] < rightmostLowestPoint[1] ||
                    (points[i][1] == rightmostLowestPoint[1] && points[i][0] > rightmostLowestPoint[0])) {
                rightmostLowestPoint = points[i];
            }
        }

        return rightmostLowestPoint;
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        double[][] userPoints = new double[6][2];

        System.out.print(""Enter 6 points: "");
        for (int i = 0; i < 6; i++) {
            userPoints[i][0] = input.nextDouble();
            userPoints[i][1] = input.nextDouble();
        }

        double[] result = getRightmostLowestPoint(userPoints);
        System.out.println(""The rightmost lowest point is ("" + result[0] + "", "" + result[1] + "")"");
    }
}",0.6713819368879217
0_Exercise08_29.java," /**
 * 8.29 (Identical arrays) The two-dimensional arrays m1 and m2 are identical if they
 * have the same contents. Write a method that returns true if m1 and m2 are identical, using the following header:
 * public static boolean equals(int[][] m1, int[][] m2)
 * <p>
 * <p>
 * Write a test program that prompts the user to enter two 3 * 3 arrays of integers
 * and displays whether the two are identical. Here are the sample runs.
 * Enter list1: 51 5 22 6 1 4 24 54 6
 * Enter list2: 51 22 25 6 1 4 24 54 6
 * The two arrays are not identical
 * Enter list1: 51 25 22 6 1 4 24 54 6
 * Enter list2: 51 22 25 6 1 4 24 54 6
 * The two arrays are identical
 */","package ch_08;

import java.util.*;


public class Exercise08_29 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int[][] one = new int[3][3];
        System.out.print(""Enter list1: "");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                one[i][j] = in.nextInt();
            }
        }
        int[][] two = new int[3][3];
        System.out.print(""\nEnter list2:  "");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                two[i][j] = in.nextInt();
            }
        }
        if (equals(one, two)) {
            System.out.println(""The arrays are identical."");
        } else {
            System.out.println(""The arrays are not identical."");
        }
    }

    public static boolean equals(int[][] m1, int[][] m2) {

        for (int i = 0; i < m1.length; i++) {
            for (int j = 0; j < m1[i].length; j++) {
                if (m1[i][j] != m2[i][j]) {
                    return false;
                }
            }
        }
        return true;
    }

}","public static boolean equals(int[][] m1, int[][] m2) {
    if (m1.length != m2.length || m1[0].length != m2[0].length) {
        return false;
    }
    
    for (int i = 0; i < m1.length; i++) {
        for (int j = 0; j < m1[0].length; j++) {
            if (m1[i][j] != m2[i][j]) {
                return false;
            }
        }
    }
    
    return true;
}
 import java.util.Scanner;

public class Test {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        int[][] m1 = new int[3][3];
        int[][] m2 = new int[3][3];
        
        System.out.print(""Enter list1: "");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                m1[i][j] = input.nextInt();
            }
        }
        
        System.out.print(""Enter list2: "");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                m2[i][j] = input.nextInt();
            }
        }
        
        if (equals(m1, m2)) {
            System.out.println(""The two arrays are identical"");
        } else {
            System.out.println(""The two arrays are not identical"");
        }
    }
}",3,"import java.util.Scanner;

public class IdenticalArrays {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.println(""Enter list1 (3x3 matrix) separated by spaces: "");
        int[][] list1 = new int[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                list1[i][j] = input.nextInt();
            }
        }

        System.out.println(""Enter list2 (3x3 matrix) separated by spaces: "");
        int[][] list2 = new int[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                list2[i][j] = input.nextInt();
            }
        }

        if (equals(list1, list2)) {
            System.out.println(""The two arrays are identical"");
        } else {
            System.out.println(""The two arrays are not identical"");
        }
    }

    public static boolean equals(int[][] m1, int[][] m2) {
        if (m1.length != m2.length || m1[0].length != m2[0].length) {
            return false;
        }

        for (int i = 0; i < m1.length; i++) {
            for (int j = 0; j < m1[0].length; j++) {
                if (m1[i][j] != m2[i][j]) {
                    return false;
                }
            }
        }

        return true;
    }
}",0.5754865860073646
0_Exercise08_05.java," /**
 * 8.5 (Algebra: add two matrices)
 * Write a method to add two matrices.
 * The header of the method is as follows:
 * <p>
 * public static double[][] addMatrix(double[][] a, double[][] b)
 * <p>
 * In order to be added, the two matrices must have the same dimensions
 * and the same or compatible types of elements. Let c be the resulting
 * matrix. Each element cij is aij + bij. For example,
 * for two 3 � 3 matrices a and b, c is
 * <p>
 * Write a test program that prompts the user to
 * enter two 3 � 3 matrices and displays their sum.
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_05 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.println(""Enter matrix one now: "");

        double[][] matrix1 = new double[3][3];

        for (int i = 0; i < matrix1.length; i++) {

            for (int j = 0; j < matrix1[i].length; j++) {

                matrix1[i][j] = input.nextDouble();
            }
        }

        System.out.println(""Enter matrix two now: "");

        double[][] matrix2 = new double[3][3];

        for (int i = 0; i < matrix2.length; i++) {

            for (int j = 0; j < matrix2[i].length; j++) {

                matrix2[i][j] = input.nextDouble();
            }
        }
        double[][] newMatrix = addMatrix(matrix1, matrix2);

        System.out.println(""The addition of the matrices is: "");

        for (int i = 0; i < matrix1.length; i++) {


            for (int j = 0; j < matrix1[i].length; j++) {

                System.out.print(matrix1[i][j] + "" "");
                if (i == 1 && j == 2) {
                    System.out.print("" +   "");
                } else if (i != 1 && j == 2)
                    System.out.print(""     "");
            }

            for (int j = 0; j < matrix2[i].length; j++) {

                System.out.print(matrix2[i][j] + "" "");
                if (i == 1 && j == 2) {
                    System.out.print("" =   "");
                } else if (i != 1 && j == 2)
                    System.out.print(""     "");
            }

            for (int j = 0; j < newMatrix[i].length; j++) {

                System.out.print(newMatrix[i][j] + "" "");
                if (i != 1 && j == 2)
                    System.out.print(""    "");
            }
            System.out.println();

        }

    }

    public static double[][] addMatrix(double[][] a, double[][] b) {

        double[][] sum = new double[3][3];

        for (int i = 0; i < a.length; i++) {

            for (int j = 0; j < a[i].length; j++) {

                sum[i][j] = a[i][j] + b[i][j];
            }
        }

        return sum;

    }

}
","import java.util.Scanner;

public class AddMatrices {
    
    public static double[][] addMatrix(double[][] a, double[][] b) {
        if(a.length != b.length || a[0].length != b[0].length) {
            throw new IllegalArgumentException(""Matrices must have same dimensions"");
        }
        
        int rows = a.length;
        int cols = a[0].length;
        
        double[][] result = new double[rows][cols];
        
        for(int i=0; i<rows; i++) {
            for(int j=0; j<cols; j++) {
                result[i][j] = a[i][j] + b[i][j];
            }
        }
        
        return result;
    }
    
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        double[][] a = new double[3][3];
        double[][] b = new double[3][3];
        
        System.out.print(""Enter matrix1: "");
        for(int i=0; i<a.length; i++) {
            for(int j=0; j<a[0].length; j++) {
                a[i][j] = input.nextDouble();
            }
        }
        
        System.out.print(""Enter matrix2: "");
        for(int i=0; i<b.length; i++) {
            for(int j=0; j<b[0].length; j++) {
                b[i][j] = input.nextDouble();
            }
        }
        
        double[][] result = addMatrix(a, b);
        
        System.out.println(""The addition of the matrices is: "");
        for(int i=0; i<result.length; i++) {
            for(int j=0; j<result[0].length; j++) {
                System.out.print(result[i][j] + "" "");
            }
            System.out.println();
        }
        
    }
}",3,"import java.util.Scanner;

public class MatrixAddition {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.println(""Enter matrix A (3x3):"");
        double[][] matrixA = enterMatrix(input);

        System.out.println(""Enter matrix B (3x3):"");
        double[][] matrixB = enterMatrix(input);

        double[][] sumMatrix = addMatrix(matrixA, matrixB);

        System.out.println(""The sum of the matrices is:"");
        displayMatrix(sumMatrix);
    }

    public static double[][] enterMatrix(Scanner input) {
        double[][] matrix = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print(""Enter element at position ("" + (i + 1) + "","" + (j + 1) + ""): "");
                matrix[i][j] = input.nextDouble();
            }
        }
        return matrix;
    }

    public static double[][] addMatrix(double[][] a, double[][] b) {
        double[][] result = new double[3][3];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                result[i][j] = a[i][j] + b[i][j];
            }
        }
        return result;
    }

    public static void displayMatrix(double[][] matrix) {
        for (double[] row : matrix) {
            for (double element : row) {
                System.out.print(element + "" "");
            }
            System.out.println();
        }
    }
}",0.5072463768115942
0_Exercise08_13.java," /**
 * *8.13 (Locate the largest element) Write the following method that returns the location
 * of the largest element in a two-dimensional array.
 * public static int[] locateLargest(double[][] a)
 * The return value is a one-dimensional array that contains two elements. These
 * two elements indicate the row and column indices of the largest element in the
 * two-dimensional array.
 * <p>
 * Write a test program that prompts the user to enter a two-dimensional array and displays
 * the location of the largest element in the array.
 */","package ch_08;

import java.util.*;


public class Exercise08_13 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        double[][] arrTwoDim = new double[2][5];
        System.out.println(""To input a two dimensional array, input: 5 floating point numbers now: "");

        for (int i = 0; i < 5; i++) {
            arrTwoDim[0][i] = in.nextDouble();
        }

        System.out.println(""Input more 5 floating point numbers now: "");

        for (int i = 0; i < 5; i++) {
            arrTwoDim[1][i] = in.nextDouble();
        }

        System.out.println(""The largest is located at "" + Arrays.toString(locateLargest(arrTwoDim)));


    }

    public static int[] locateLargest(double[][] a) {
        int[] largeIdx = new int[2];
        double largest = Double.MIN_VALUE;

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                if (a[i][j] > largest) {
                    largest = a[i][j];
                    largeIdx[0] = i;
                    largeIdx[1] = j;
                }
            }
        }
        return largeIdx;
    }
}
","public static int[] locateLargest(double[][] a) {
    int[] result = {0, 0};
    double max = a[0][0];
    for (int i = 0; i < a.length; i++) {
        for (int j = 0; j < a[i].length; j++) {
            if (a[i][j] > max) {
                max = a[i][j];
                result[0] = i;
                result[1] = j;
            }
        }
    }
    return result;
}",3,"import java.util.Scanner;

public class LargestElementFinder {

    public static int[] locateLargest(double[][] a) {
        int[] location = new int[2];
        double max = a[0][0];
        location[0] = 0;
        location[1] = 0;

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                if (a[i][j] > max) {
                    max = a[i][j];
                    location[0] = i;
                    location[1] = j;
                }
            }
        }

        return location;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter the number of rows: "");
        int rows = scanner.nextInt();

        System.out.print(""Enter the number of columns: "");
        int cols = scanner.nextInt();

        double[][] array = new double[rows][cols];

        System.out.println(""Enter the elements of the array:"");

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                System.out.printf(""Enter element [%d][%d]: "", i, j);
                array[i][j] = scanner.nextDouble();
            }
        }

        int[] location = locateLargest(array);
        System.out.printf(""The location of the largest element is at [%d][%d]\n"", location[0], location[1]);
    }
}",0.3885542168674699
0_Exercise08_33.java," /**
 * *8.33 (Geometry: polygon subareas) A convex 4-vertex polygon is divided into four
 * triangles, as shown in Figure 8.9.
 * <p>
 * Write a program that prompts the user to enter the coordinates of four vertices and
 * displays the areas of the four triangles in increasing order.
 * <p>
 * Here is a sample run:
 * Enter x1, y1, x2, y2, x3, y3, x4, y4:
 * -2.5 2 4 4 3 -2 -2 -3.5
 * The areas are 6.17 7.96 8.08 10.42
 */ /**
     * @param points -> points of the triangle
     * @return the triangles area
     */","package ch_08;

import java.util.Arrays;
import java.util.Scanner;



public class Exercise08_33 {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        double[][] pts = new double[4][2];
        System.out.println(""Enter x1, y1, x2, y2, x3, y3, x4, y4: "");
        for (int pt = 0; pt < 4; pt++) {
            for (int xy = 0; xy < 2; xy++) {
                pts[pt][xy] = in.nextDouble();
            }
        }
        double[] areas = new double[4];

        double[] intersectionPoint = solveForIntersectionPoint(pts);
        System.out.println(""Intersection Point: "" + Arrays.toString(intersectionPoint));

        double[][] t1 = new double[3][3];
        t1[0] = pts[0];
        t1[1] = pts[1];
        t1[2] = intersectionPoint;
        areas[0] = getTriangleArea(t1);

        double[][] t2 = new double[3][3];
        t2[0] = pts[1];
        t2[1] = pts[2];
        t2[2] = intersectionPoint;
        areas[1] = getTriangleArea(t2);

        double[][] t3 = new double[3][3];
        t3[0] = pts[2];
        t3[1] = pts[3];
        t3[2] = intersectionPoint;
        areas[2] = getTriangleArea(t3);

        double[][] t4 = new double[3][3];
        t4[0] = pts[0];
        t4[1] = pts[3];
        t4[2] = intersectionPoint;
        areas[3] = getTriangleArea(t4);

        Arrays.sort(areas);
        System.out.println(""The areas are: "");
        for (double val : areas) {
            System.out.printf(""%.2f"" + "" "", val);
        }

        in.close();

    }


    
    static double getTriangleArea(double[][] points) {
        if (onSameLine(points)) {
            return 0;
        }
        double s1 = findSide(points[0][0], points[0][1], points[1][0], points[1][1]);
        double s2 = findSide(points[0][0], points[0][1], points[2][0], points[2][1]);
        double s3 = findSide(points[2][0], points[2][1], points[1][0], points[1][1]);

        double s = (s1 + s2 + s3) / 2;

        return Math.sqrt((s * (s - s1) * (s - s2) * (s - s3)));
    }

    static double[] solveForIntersectionPoint(double[][] pts) {
        // Line one is point 1 to point 3
        // Line one is point 1 to point 3
        double x1 = pts[0][0];
        double y1 = pts[0][1];
        double x2 = pts[2][0];
        double y2 = pts[2][1];
        // Line two is point 2 to point 4
        double x3 = pts[1][0];
        double y3 = pts[1][1];
        double x4 = pts[3][0];
        double y4 = pts[3][1];
        /* ------ Cramer's Rule for 2 x 2 Linear Equations ------ */
        double a = y1 - y2;
        double b = -(x1 - x2);
        double c = y3 - y4;
        double d = -(x3 - x4);
        double e = (y1 - y2) * x1 - (x1 - x2) * y1;
        double f = (y3 - y4) * x3 - (x3 - x4) * y3;
        double D = a * d - b * c;
        double Dx = e * d - b * f;
        double Dy = a * f - e * c;
        double x = Dx / D;
        double y = Dy / D;

        return new double[]{x, y};
    }

    public static double findSide(double x1, double y1, double x2, double y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    private static boolean onSameLine(double[][] pts) {
        double determinant =
                (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[2][0] - pts[0][0]) * (pts[1][1] - pts[0][1]);

        return determinant == 0;

    }
}
","import java.util.Scanner;

public class PolygonAreaCalculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Read in the coordinates of the four vertices
        double[][] vertices = new double[4][2];
        System.out.print(""Enter x1, y1, x2, y2, x3, y3, x4, y4: "");
        for (int i = 0; i < 4; i++) {
            vertices[i][0] = input.nextDouble();
            vertices[i][1] = input.nextDouble();
        }

        // Calculate the areas of the four triangles
        double[] areas = new double[4];
        areas[0] = getTriangleArea(vertices[0], vertices[1], vertices[2]);
        areas[1] = getTriangleArea(vertices[0], vertices[1], vertices[3]);
        areas[2] = getTriangleArea(vertices[1], vertices[2], vertices[3]);
        areas[3] = getTriangleArea(vertices[2], vertices[3], vertices[0]);

        // Sort the areas in increasing order
        java.util.Arrays.sort(areas);

        // Print the areas
        System.out.print(""The areas are "");
        for (double area : areas) {
            System.out.printf(""%.2f "", area);
        }
        System.out.println();
    }

    public static double getTriangleArea(double[] p1, double[] p2, double[] p3) {
        // Calculate the area of the triangle using the cross product
        double a = distance(p1, p2);
        double b = distance(p2, p3);
        double c = distance(p3, p1);
        double s = (a + b + c) / 2;
        double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
        return area;
    }

    public static double distance(double[] p1, double[] p2) {
        double dx = p2[0] - p1[0];
        double dy = p2[1] - p1[1];
        double distance = Math.sqrt(dx * dx + dy * dy);
        return distance;
    }
}",3,"import java.util.Scanner;

public class PolygonAreas {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter x1, y1, x2, y2, x3, y3, x4, y4: "");
        double x1 = input.nextDouble();
        double y1 = input.nextDouble();
        double x2 = input.nextDouble();
        double y2 = input.nextDouble();
        double x3 = input.nextDouble();
        double y3 = input.nextDouble();
        double x4 = input.nextDouble();
        double y4 = input.nextDouble();

        double area1 = calculateTriangleArea(x1, y1, x2, y2, x3, y3);
        double area2 = calculateTriangleArea(x1, y1, x3, y3, x4, y4);
        double area3 = calculateTriangleArea(x1, y1, x2, y2, x4, y4);
        double area4 = calculateTriangleArea(x2, y2, x3, y3, x4, y4);

        double[] areas = { area1, area2, area3, area4 };
        sortAreas(areas);

        System.out.print(""The areas are "");
        for (double area : areas) {
            System.out.printf(""%.2f "", area);
        }
    }

    public static double calculateTriangleArea(double x1, double y1, double x2, double y2, double x3, double y3) {
        return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);
    }

    public static void sortAreas(double[] areas) {
        int n = areas.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (areas[j] > areas[j + 1]) {
                    double temp = areas[j];
                    areas[j] = areas[j + 1];
                    areas[j + 1] = temp;
                }
            }
        }
    }
}",0.5683327507864383
0_Exercise08_25.java," /**
 * *8.25 (Markov matrix) An n * n matrix is called a positive Markov matrix if each
 * element is positive and the sum of the elements in each column is 1. Write the
 * following method to check whether a matrix is a Markov matrix.
 * public static boolean isMarkovMatrix(double[][] m)
 * <p>
 * Write a test program that prompts the user to enter a 3 * 3 matrix of double
 * values and tests whether it is a Markov matrix. Here are sample runs:
 * Enter a 3-by-3 matrix row by row:
 * 0.15 0.875 0.375
 * 0.55 0.005 0.225
 * 0.30 0.12 0.4
 * It is a Markov matrix
 * Enter a 3-by-3 matrix row by row:
 * 0.95 -0.875 0.375
 * 0.65 0.005 0.225
 * 0.30 0.22 -0.4
 * It is not a Markov matrix
 *
 * @author Harry D.
 */","package ch_08;

import java.util.*;


public class Exercise08_25 {
    static String markovMatrix = ""It is a Markov matrix"";
    static String notMarkovMatrix = ""It is not a Markov matrix"";

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        double[][] test = new double[3][3];

        System.out.println(""Enter a 3-by-3 matrix row by row: "");

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                test[i][j] = in.nextDouble();
            }
        }
        if (isMarkovMatrix(test)) {
            System.out.println(markovMatrix);
        } else {
            System.out.println(notMarkovMatrix);
        }
        in.close();


    }

    public static boolean isMarkovMatrix(double[][] m) {
        for (int i = 0; i < 3; i++) {
            double sum = 0;
            for (int j = 0; j < 3; j++) {
                if (m[j][i] < 0) {
                    return false;
                }
                sum += m[j][i];
            }
            if (sum != 1) {
                return false;
            }
        }
        return true;

    }
}","public static boolean isMarkovMatrix(double[][] m) {
    int n = m.length;
    for (int j = 0; j < n; j++) {
        double columnSum = 0;
        for (int i = 0; i < n; i++) {
            if (m[i][j] < 0) // check if the element is negative
                return false;
            columnSum += m[i][j];
        }
        if (Math.abs(columnSum - 1.0) > 0.0001) // check if the column sum is 1
            return false;
    }
    return true;
}",3,"import java.util.Scanner;

public class MarkovMatrixChecker {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double[][] matrix = new double[3][3];

        System.out.println(""Enter a 3-by-3 matrix row by row:"");
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                matrix[i][j] = scanner.nextDouble();
            }
        }

        if (isMarkovMatrix(matrix)) {
            System.out.println(""It is a Markov matrix"");
        } else {
            System.out.println(""It is not a Markov matrix"");
        }
    }

    public static boolean isMarkovMatrix(double[][] m) {
        // Check if each element is positive
        for (double[] row : m) {
            for (double num : row) {
                if (num <= 0) {
                    return false;
                }
            }
        }

        // Check if the sum of elements in each column is 1
        for (int i = 0; i < m.length; i++) {
            double sum = 0;
            for (int j = 0; j < m[i].length; j++) {
                sum += m[j][i];
            }
            if (Math.abs(sum - 1.0) > 0.0001) {
                return false;
            }
        }

        return true;
    }
}",0.40404040404040403
0_Exercise08_09.java," /**
 * ***8.9 (Game: play a tic-tac-toe game) In a game of tic-tac-toe, two players
 * take turns marking an available cell in a 3 * 3 grid with their respective
 * tokens (either X or O). When one player has placed three tokens in a
 * horizontal, vertical, or diagonal row on the grid, the game is over and that
 * player has won. A draw (no winner) occurs when all the cells on the grid have
 * been filled with tokens and neither player has achieved a win. Create a
 * program for playing tic-tac-toe. The program prompts two players to enter an
 * X token and O token alternately. Whenever a token is entered, the program
 * redisplays the board on the console and determines the status of the game
 * (win, draw, or continue). Here is a sample run:
 * <p>
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * Enter a row (0, 1, or 2) for player X: 1
 * Enter a column (0, 1, or 2) for player X: 1
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * |   | X |   |
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * Enter a row (0, 1, or 2) for player O: 1
 * Enter a column (0, 1, or 2) for player O: 2
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * |   | X | O |
 * ——————-——————
 * |   |   |   |
 * ——————-——————
 * <p>
 * Enter a row (0, 1, or 2) for player X:
 * . . .
 * ——————-——————
 * | X |   |   |
 * ——————-——————
 * | O | X | O |
 * ——————-——————
 * |   |   | X |
 * ——————-——————
 * X player won
 */","package ch_08;

import java.util.*;


public class Exercise08_09 {
    private static final String USER_X_ID = ""X"";
    private static final String USER_O_ID = ""O"";
    static final String IN_PROMPT_ROW = ""Enter a row (0, 1, or 2) for player"";
    static final String IN_PROMPT_COLUMN = ""Enter a column (0, 1, or 2) for player"";
    static String[][] boxes;
    static String nextMove;
    static String currentMove;
    static boolean blank;
    static final String verticalLine = ""——————-——————\r\n"";
    static String status;
    static String winner;
    static int totalMoves = 9;

    static {
        boxes = new String[][]{{"""", """", """"},
                {"""", """", """"},
                {"""", """", """"}}; //Tic tac toe board empty
        nextMove = USER_X_ID;
        status = ""continue"";
        blank = true;

    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int row = 0, col = 0;
        System.out.print(""Welcome to Tic Tac Toe!\n"");
        while (status.equals(""continue"")) {
            if (blank) {
                printBlankBoard();
                blank = false;
            } else {
                printGameBoard();
            }
            System.out.print(IN_PROMPT_ROW + "" "" + nextMove + "":"");
            row = in.nextInt();
            System.out.print(IN_PROMPT_COLUMN + "" "" + nextMove + "":"");
            col = in.nextInt();
            if ((col == 0 || col == 1 || col == 2) && (row == 0 || row == 1 || row == 2)) {
                addMove(row, col);
            } else {
                System.out.println(""You entered an invalid character player "" + nextMove + "" enter a 0, 1, or 2 next time..."");
            }
        }
        if (status.equals(""win"")) {
            //WIN
            printGameBoard();
            System.out.print(""\nPlayer "" + winner + "" won!"");
        } else {
            //DRAW
            System.out.println(""The match is a draw!!"");
        }

    }

    //Add players move to the boxes array and test win condition
    static void addMove(int markRow, int markCol) {
        if (boxes[markRow][markCol].equals("""")) {
            boxes[markRow][markCol] = nextMove;
            totalMoves--;
        } else {
            System.out.println(""Nice try, you can only enter your mark in an empty box..."");
        }

        if (checkWinner()) {
            status = ""win"";
        } else if (totalMoves < 1) {
            status = ""draw"";
        }
    }

    private static void printGameBoard() {

        for (int i = 0; i < 3; i++) {
            System.out.print(verticalLine);
            for (int j = 0; j < 3; j++) {
                if (boxes[i][j].equals("""")) {
                    System.out.print(""|   "");
                } else {
                    System.out.print(""| "");
                    System.out.print(boxes[i][j]);
                    System.out.print("" "");
                }
            }
            System.out.print(""|\r\n""); // Last piece of bottom right box
        }
        System.out.println(verticalLine);//Bottom line t-t-t board

        nextMove = nextMove.equals(USER_X_ID) ? USER_O_ID : USER_X_ID;
    }

    //Runs first iteration of main while loop
    static void printBlankBoard() {
        for (int i = 0; i < 3; i++) {
            System.out.print(verticalLine);
            for (int j = 0; j < 3; j++) {
                System.out.print(""|   "");
            }
            System.out.print(""|\r\n"");
        }
        System.out.println(verticalLine);//Bottom line t-t-t board
    }

    //Iterate boxes array's and determine which player, if any, is the winner
    static boolean checkWinner() {
        boolean won = false;
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (!(boxes[i][j].equals(""""))) {
                    if (boxes[i][j].equals(""X"")) {
                        if (boxes[0][0].equals(""X"") && boxes[0][1].equals(""X"") && boxes[0][2].equals(""X"") ||
                                boxes[1][0].equals(""X"") && boxes[1][1].equals(""X"") && boxes[1][2].equals(""X"") ||
                                boxes[2][0].equals(""X"") && boxes[2][1].equals(""X"") && boxes[2][2].equals(""X"") ||
                                boxes[0][0].equals(""X"") && boxes[1][0].equals(""X"") && boxes[2][0].equals(""X"") ||
                                boxes[0][1].equals(""X"") && boxes[1][1].equals(""X"") && boxes[2][1].equals(""X"") ||
                                boxes[0][2].equals(""X"") && boxes[1][2].equals(""X"") && boxes[2][2].equals(""X"") ||
                                boxes[0][0].equals(""X"") && boxes[1][1].equals(""X"") && boxes[2][2].equals(""X"") ||
                                boxes[0][2].equals(""X"") && boxes[1][1].equals(""X"") && boxes[2][0].equals(""X"")) {
                            winner = ""X"";
                            won = true;
                        }

                    } else {
                        if (boxes[0][0].equals(""O"") && boxes[0][1].equals(""O"") && boxes[0][2].equals(""O"") ||
                                boxes[1][0].equals(""O"") && boxes[1][1].equals(""O"") && boxes[1][2].equals(""O"") ||
                                boxes[2][0].equals(""O"") && boxes[2][1].equals(""O"") && boxes[2][2].equals(""O"") ||
                                boxes[0][0].equals(""O"") && boxes[1][0].equals(""O"") && boxes[2][0].equals(""O"") ||
                                boxes[0][1].equals(""O"") && boxes[1][1].equals(""O"") && boxes[2][1].equals(""O"") ||
                                boxes[0][2].equals(""O"") && boxes[1][2].equals(""O"") && boxes[2][2].equals(""O"") ||
                                boxes[0][0].equals(""O"") && boxes[1][1].equals(""O"") && boxes[2][2].equals(""O"") ||
                                boxes[0][2].equals(""O"") && boxes[1][1].equals(""O"") && boxes[2][0].equals(""O"")) {
                            winner = ""O"";
                            won = true;
                        }


                    }


                }

            }
        }

        return won;

    }

} ","import java.util.Scanner;

public class TicTacToe {
    public static void main(String[] args) {
        char[][] board = new char[3][3];
        initializeBoard(board);
        displayBoard(board);

        char currentPlayer = 'X';
        boolean gameEnded = false;
        int row, col;

        while (!gameEnded) {
            System.out.printf(""Enter a row (0, 1, or 2) for player %s: "", currentPlayer);
            row = getPlayerInput();
            System.out.printf(""Enter a column (0, 1, or 2) for player %s: "", currentPlayer);
            col = getPlayerInput();

            if (board[row][col] == '\u0000') { // check if cell is available
                board[row][col] = currentPlayer;
                displayBoard(board);

                if (hasPlayerWon(board, currentPlayer)) {
                    System.out.printf(""%s player won\n"", currentPlayer);
                    gameEnded = true;
                } else if (isBoardFull(board)) {
                    System.out.println(""The game is a draw"");
                    gameEnded = true;
                } else {
                    currentPlayer = (currentPlayer == 'X') ? 'O' : 'X'; // switch player
                }
            } else {
                System.out.println(""This cell is already occupied. Please try again."");
            }
        }
    }

    private static void initializeBoard(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                board[i][j] = '\u0000'; // empty cell
            }
        }
    }

    private static void displayBoard(char[][] board) {
        System.out.println(""-------------"");
        for (int i = 0; i < board.length; i++) {
            System.out.print(""| "");
            for (int j = 0; j < board[i].length; j++) {
                System.out.print(board[i][j] + "" | "");
            }
            System.out.println();
            System.out.println(""-------------"");
        }
    }

    private static int getPlayerInput() {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        while (n < 0 || n > 2) {
            System.out.println(""Invalid input. Please enter a number between 0 and 2."");
            n = input.nextInt();
        }
        return n;
    }

    private static boolean hasPlayerWon(char[][] board, char player) {
        // check rows
        for (int i = 0; i < board.length; i++) {
            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {
                return true;
            }
        }
        // check columns
        for (int j = 0; j < board[0].length; j++) {
            if (board[0][j] == player && board[1][j] == player && board[2][j] == player) {
                return true;
            }
        }
        // check diagonals
        if (board[0][0",3,"import java.util.Scanner;

public class TicTacToeGame {

    public static void main(String[] args) {
        char[][] board = new char[3][3]; // Initialize the game board
        Scanner input = new Scanner(System.in); // Create Scanner object for input
        
        initializeBoard(board); // Initialize the board with empty spaces
        printBoard(board); // Display the initial empty board
        
        char currentPlayer = 'X'; // Player X starts the game
        boolean gameWon = false; // Track if the game is won
        boolean boardFull = false; // Track if the board is full (draw)
        
        while (!gameWon && !boardFull) {
            System.out.print(""Enter a row (0, 1, or 2) for player "" + currentPlayer + "": "");
            int row = input.nextInt(); // Get row input from player
            System.out.print(""Enter a column (0, 1, or 2) for player "" + currentPlayer + "": "");
            int col = input.nextInt(); // Get column input from player
            
            if (isValidMove(board, row, col)) { // Check if the move is valid
                board[row][col] = currentPlayer; // Update the board with the player's move
                printBoard(board); // Display the updated board
                
                if (checkWinner(board, currentPlayer)) { // Check if the current player has won
                    System.out.println(currentPlayer + "" player won!"");
                    gameWon = true;
                } else if (isBoardFull(board)) { // Check if the board is full (draw)
                    System.out.println(""It's a draw!"");
                    boardFull = true;
                } else {
                    currentPlayer = (currentPlayer == 'X') ? 'O' : 'X'; // Switch player turns
                }
            } else {
                System.out.println(""Invalid move. Try again.""); // Prompt for a valid move
            }
        }
        
        input.close(); // Close the Scanner object
    }
    
    // Method to initialize the board with empty spaces
    public static void initializeBoard(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                board[i][j] = ' '; // Set each cell to empty space
            }
        }
    }
    
    // Method to print the current state of the board
    public static void printBoard(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                System.out.print(""—"");
                System.out.print(board[i][j]);
                System.out.print("" "");
            }
            System.out.println(""\n——————-——————"");
        }
    }
    
    // Method to check if a move is valid
    public static boolean isValidMove(char[][] board, int row, int col) {
        return row >= 0 && row < 3 && col >= 0 && col < 3 && board[row][col] == ' ';
    }
    
    // Method to check if a player has won
    public static boolean checkWinner(char[][] board, char currentPlayer) {
        // Check rows, columns, and diagonals for a winning combination
        return (board[0][0] == currentPlayer && board[0][1] == currentPlayer && board[0][2] == currentPlayer) ||
               (board[1][0] == currentPlayer && board[1][1] == currentPlayer && board[1][2] == currentPlayer) ||
               (board[2][0] == currentPlayer && board[2][1] == currentPlayer && board[2][2] == currentPlayer) ||
               (board[0][0] == currentPlayer && board[1][0] == currentPlayer && board[2][0] == currentPlayer) ||
               (board[0][1] == currentPlayer && board[1][1] == currentPlayer && board[2][1] == currentPlayer) ||
               (board[0][2] == currentPlayer && board[1][2] == currentPlayer && board[2][2] == currentPlayer) ||
               (board[0][0] == currentPlayer && board[1][1] == currentPlayer && board[2][2] == currentPlayer) ||
               (board[0][2] == currentPlayer && board[1][1] == currentPlayer && board[2][0] == currentPlayer);
    }
    
    // Method to check if the board is full (draw)
    public static boolean isBoardFull(char[][] board) {
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if (board[i][j] == ' ') {
                    return false; // If any cell is empty, the board is not full
                }
            }
        }
        return true; // If no empty cells are found, the board is full
    }
}",0.5661411925976696
0_Exercise08_32.java," /**
 * *8.32 (Geometry: area of a triangle) Write a method that returns the area of a triangle
 * using the following header:
 * public static double getTriangleArea(double[][] points)
 * The points are stored in a 3-by-2 two-dimensional array points with points[0]
 * [0] and points[0][1] for (x1, y1). The triangle area can be computed using the
 * formula in Programming Exercise 2.19. The method returns 0 if the three points
 * are on the same line. Write a program that prompts the user to enter three points of
 * a triangle and displays the triangle's area.
 * <p>
 * Here is a sample run of the program:
 * Enter x1, y1, x2, y2, x3, y3: 2.5 2 5 -1.0 4.0 2.0
 * The area of the triangle is 2.25
 * Enter x1, y1, x2, y2, x3, y3: 2 2 4.5 4.5 6 6
 * The three points are on the same line
 */","package ch_08;

import java.util.Scanner;


public class Exercise08_32 {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        double[][] points = new double[3][2];
        System.out.print(""Enter x1, y1, x2, y2, x3, y3: "");

        for (int i = 0; i < points.length; i++) {
            for (int j = 0; j < points[i].length; j++) {
                points[i][j] = in.nextDouble();

            }
        }

        double result = getTriangleArea(points);
        if (result == 0) {
            System.out.println(""The three points are on the same line"");
        } else {
            System.out.printf(""The area of the triangle is %.2f"",result);
        }
    }

    public static double getTriangleArea(double[][] points) {
        if (onSameLine(points)) {
            return 0;
        }
        double s1 = findSide(points[0][0],points[0][1],points[1][0],points[1][1]);
        double s2 = findSide(points[1][0],points[1][1],points[2][0],points[2][1]);
        double s3 = findSide(points[0][0],points[0][1],points[2][0],points[2][1]);

        double s = (s1 + s2 + s3) / 2;

        return Math.sqrt((s * (s - s1) * (s - s2) * (s - s3)));
    }

    public static double findSide(double x1, double y1, double x2, double y2) {
        return Math.pow(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2), 0.5);
    }

    private static boolean onSameLine(double[][] pts) {
        double determinant =
                (pts[1][0] - pts[0][0]) * (pts[2][1] - pts[0][1]) - (pts[2][0] - pts[0][0]) * (pts[1][1] - pts[0][1]);

        return determinant == 0;

    }
}
","public static double getTriangleArea(double[][] points) {
    double x1 = points[0][0];
    double y1 = points[0][1];
    double x2 = points[1][0];
    double y2 = points[1][1];
    double x3 = points[2][0];
    double y3 = points[2][1];
    
    double area = Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);
    
    return area;
}",3,"import java.util.Scanner;

public class TriangleAreaCalculator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.print(""Enter x1, y1, x2, y2, x3, y3: "");
        double[][] points = new double[3][2];
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 2; j++) {
                points[i][j] = scanner.nextDouble();
            }
        }

        double area = getTriangleArea(points);
        if (area > 0) {
            System.out.println(""The area of the triangle is "" + area);
        } else {
            System.out.println(""The three points are on the same line"");
        }
    }

    public static double getTriangleArea(double[][] points) {
        double x1 = points[0][0];
        double y1 = points[0][1];
        double x2 = points[1][0];
        double y2 = points[1][1];
        double x3 = points[2][0];
        double y3 = points[2][1];

        double area = Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0);

        return area;
    }
}",0.5360134003350083
0_Exercise08_04.java," /**
 * 8.4 (Compute the weekly hours for each employee)
 * Suppose the weekly hours for all employees are stored
 * in a two-dimensional array. Each row records an employee's
 * seven-day work hours with seven columns. For example, the
 * following array stores the work hours for eight employees.
 * Write a program that displays employees and their total
 * hours in decreasing order of the total hours.
 */","package ch_08;


public class Exercise08_04 {
    public static void main(String[] args) {

        int[][] employeeHours = {
                {2, 4, 3, 4, 5, 8, 8},  //emp0
                {7, 3, 4, 3, 3, 4, 4},  //emp1
                {3, 3, 4, 3, 3, 2, 2},  //emp2
                {9, 3, 4, 7, 3, 4, 1},  //emp3
                {3, 5, 4, 3, 6, 3, 8},  //emp4
                {3, 4, 4, 6, 3, 4, 4},  //emp5
                {3, 7, 4, 8, 3, 8, 4},  //emp6
                {6, 3, 5, 9, 2, 7, 9}}; //emp7


        int[][] sumHours = new int[8][2];

        for (int row = 0; row < employeeHours.length; row++) {
            for (int column = 0; column < employeeHours[row].length; column++) {

                sumHours[row][0] += employeeHours[row][column];
            }
            sumHours[row][1] = row; //Save original index for sort function
        }

//		Arrays.sort(sumHours); //built in sort
        //Selection Sort
        for (int i = 0; i < sumHours.length - 1; i++) {
            for (int j = i + 1; j < sumHours.length; j++) {
                if (sumHours[i][0] < sumHours[j][0]) {
                    int[] tmp = sumHours[i];
                    sumHours[i] = sumHours[j];
                    sumHours[j] = tmp;
                }

            }
        }
        printArray(sumHours);

    }

    public static void printArray(int[][] array) {

//		for(int i = array.length - 1; i >= 0; i--) { //Print in reverse
        for (int i = 0; i < array.length; i++) {
            System.out.print(""Employee number: "" + array[i][1] + ""'s total hours for the week were "");
            System.out.print(array[i][0] + ""\n"");
//		}
        }


    }

}
","public class ComputeWeeklyHours {
   public static void main(String[] args) {
      int[][] weeklyHours = {
         {2, 4, 3, 4, 5, 8, 8},
         {7, 3, 4, 3, 3, 4, 4},
         {3, 3, 4, 3, 3, 2, 2},
         {9, 3, 4, 7, 3, 4, 1},
         {3, 5, 4, 3, 6, 3, 8},
         {3, 4, 4, 6, 3, 4, 4},
         {3, 7, 4, 8, 3, 8, 4},
         {6, 3, 5, 9, 2, 7, 9}
      };
      
      int[] totalHours = new int[weeklyHours.length];
      
      // Compute the total hours for each employee
      for (int i = 0; i < weeklyHours.length; i++) {
         int sum = 0;
         for (int j = 0; j < weeklyHours[i].length; j++) {
            sum += weeklyHours[i][j];
         }
         totalHours[i] = sum;
      }
      
      // Create a list of tuples containing employee number and total hours
      List<Tuple<Integer, Integer>> employeeHours = new ArrayList<>();
      for (int i = 0; i < totalHours.length; i++) {
         employeeHours.add(new Tuple<>(i, totalHours[i]));
      }
      
      // Sort the list in decreasing order of total hours
      employeeHours.sort((a, b) -> b.getSecond() - a.getSecond());
      
      // Display the sorted list
      for (Tuple<Integer, Integer> employee : employeeHours) {
         System.out.printf(""Employee %d: %d hours\n"", employee.getFirst(), employee.getSecond());
      }
   }
}

class Tuple<A, B> {
   private A first;
   private B second;
   
   public Tuple(A first, B second) {
      this.first = first;
      this.second = second;
   }
   
   public A getFirst() {
      return first;
   }
   
   public B getSecond() {
      return second;
   }
}",3,"public class WeeklyHours {

    public static void main(String[] args) {
        int[][] weeklyHours = {
            {2, 4, 3, 4, 5, 8, 8},
            {7, 3, 4, 3, 3, 4, 4},
            {3, 3, 4, 3, 3, 2, 2},
            {9, 3, 4, 7, 3, 4, 1},
            {3, 5, 4, 3, 6, 3, 8},
            {3, 4, 4, 6, 3, 4, 4},
            {3, 7, 4, 8, 3, 8, 4},
            {6, 3, 5, 9, 2, 7, 9}
        };

        int[] totalHours = calculateTotalHours(weeklyHours);
        sortEmployees(weeklyHours, totalHours);

        displayResult(weeklyHours, totalHours);
    }

    public static int[] calculateTotalHours(int[][] hours) {
        int[] totalHours = new int[hours.length];
        for (int i = 0; i < hours.length; i++) {
            int sum = 0;
            for (int j = 0; j < hours[i].length; j++) {
                sum += hours[i][j];
            }
            totalHours[i] = sum;
        }
        return totalHours;
    }

    public static void sortEmployees(int[][] hours, int[] totalHours) {
        for (int i = 0; i < totalHours.length - 1; i++) {
            int maxIndex = i;
            for (int j = i + 1; j < totalHours.length; j++) {
                if (totalHours[j] > totalHours[maxIndex]) {
                    maxIndex = j;
                }
            }
            if (maxIndex != i) {
                int tempTotal = totalHours[maxIndex];
                totalHours[maxIndex] = totalHours[i];
                totalHours[i] = tempTotal;

                int[] tempHours = hours[maxIndex];
                hours[maxIndex] = hours[i];
                hours[i] = tempHours;
            }
        }
    }

    public static void displayResult(int[][] hours, int[] totalHours) {
        System.out.println(""Employees and their total hours in decreasing order:"");

        for (int i = 0; i < totalHours.length; i++) {
            int employeeNumber = i + 1;
            int total = totalHours[i];
            System.out.println(""Employee "" + employeeNumber + "": "" + total + "" hours"");
        }
    }
}",0.5953878406708596
0_Exercise09_03.java," /**
 * *9.3 (Use the Date class) Write a program that creates a Date object, sets its elapsed
 * time to 10000, 100000, 1000000, 10000000, 100000000, 1000000000,
 * 10000000000, and 100000000000, and displays the date and time using the
 * toString() method, respectively.
 */","package ch_09;


import java.util.Date;


public class Exercise09_03 {
    private static final long startElapsedTime = 10000;
    private static final long endElapsedTime = 100000000000L;

    public static void main(String[] args) {
        Date date = new Date();
        for (long elapsedTime = startElapsedTime; elapsedTime < endElapsedTime; elapsedTime *= 10) {
            date.setTime(elapsedTime);
            System.out.println(date.toString());
        }

    }
}
","import java.util.Date;

public class Main {
  public static void main(String[] args) {
    long[] elapsedTimes = { 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000L, 100000000000L };
    for (long elapsed : elapsedTimes) {
      Date date = new Date(elapsed);
      System.out.println(date.toString());
    }
  }
}",3,"import java.util.Date;

public class DateExample {
    public static void main(String[] args) {
        long[] elapsedTimes = {10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000L, 100000000000L};
        
        for (int i = 0; i < elapsedTimes.length; i++) {
            Date date = new Date(elapsedTimes[i]);
            String dateTime = date.toString();
            System.out.println(""Elapsed time "" + elapsedTimes[i] + "" gives us: "" + dateTime);
        }
    }
}",0.782016348773842
0_Exercise09_12.java," /**
 * **9.12 (Geometry: intersecting point) Suppose two line segments intersect.
 * The two endpoints for the first line segment are (x1, y1) and (x2, y2) and for the second line
 * segment are (x3, y3) and (x4, y4).
 * <p>
 * Write a program that prompts the user to enter
 * these four endpoints and displays the intersecting point.
 * As discussed in Programming Exercise 3.25, the intersecting point can be found by solving a linear equation.
 * Use the LinearEquation class in Programming Exercise 9.11 to solve this
 * equation. See Programming Exercise 3.25 for sample runs.
 * Test pts -> 2 2 5 -1.0 4.0 2.0 -1.0 -2.0
 */","package ch_09;

import ch_09.exercise09_11.LinearEquation;

import java.util.Scanner;


public class Exercise09_12 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter four endpoints for two lines: x1, y1, x2, y2, x3, y3, x4, y4: "");

        double[] nums = new double[8];
        for (int i = 0; i < 8; i++) {
            nums[i] = in.nextDouble();
        }
        double a = nums[1] - nums[3];
        double b = -(nums[0] - nums[2]);
        double c = nums[5] - nums[7];
        double d = -(nums[4] - nums[6]);
        double e = (nums[1] - nums[3]) * nums[0] - (nums[0] - nums[2]) * nums[1];
        double f = (nums[5] - nums[7]) * nums[4] - (nums[4] - nums[6]) * nums[5];

        LinearEquation linearEquation = new LinearEquation(a, b, c, d, e, f);

        if (linearEquation.isSolvable()) {
            System.out.printf(""The intersecting point is at (%.2f, %.2f)"", linearEquation.getX(),
                    linearEquation.getY());

        } else {
            System.out.println(""The equation does not have a solution with the points provided."");


        }
    }
}","import java.util.Scanner;

public class IntersectingPoint {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter the endpoints of the line segments
        System.out.print(""Enter x1, y1, x2, y2, x3, y3, x4, y4: "");
        double x1 = input.nextDouble();
        double y1 = input.nextDouble();
        double x2 = input.nextDouble();
        double y2 = input.nextDouble();
        double x3 = input.nextDouble();
        double y3 = input.nextDouble();
        double x4 = input.nextDouble();
        double y4 = input.nextDouble();

        // Create a LinearEquation object
        LinearEquation eq = new LinearEquation(y1 - y2, x2 - x1, y3 - y4, x4 - x3, (y1 - y2) * x1 - (x1 - x2) * y1, (y3 - y4) * x3 - (x3 - x4) * y3);

        // Check if the lines are parallel
        if (eq.isSolvable()) {
            // Display the intersecting point
            System.out.println(""The intersecting point is ("" + eq.getX() + "", "" + eq.getY() + "")"");
        } else {
            System.out.println(""The two lines are parallel"");
        }
    }
}",3,"import java.util.Scanner;

public class IntersectingPointCalculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.println(""Enter the endpoints of the first line segment (x1, y1) and (x2, y2):"");
        double x1 = input.nextDouble();
        double y1 = input.nextDouble();
        double x2 = input.nextDouble();
        double y2 = input.nextDouble();

        System.out.println(""Enter the endpoints of the second line segment (x3, y3) and (x4, y4):"");
        double x3 = input.nextDouble();
        double y3 = input.nextDouble();
        double x4 = input.nextDouble();
        double y4 = input.nextDouble();

        // Calculate the slopes and intercepts of the lines
        double slope1 = (y2 - y1) / (x2 - x1);
        double slope2 = (y4 - y3) / (x4 - x3);
        double intercept1 = y1 - slope1 * x1;
        double intercept2 = y3 - slope2 * x3;

        // Check if the lines are parallel
        if (slope1 == slope2) {
            System.out.println(""The lines are parallel. They do not intersect."");
        } else {
            // Calculate the intersecting point
            double intersectX = (intercept2 - intercept1) / (slope1 - slope2);
            double intersectY = slope1 * intersectX + intercept1;

            System.out.println(""The intersecting point is at ("" + intersectX + "", "" + intersectY + "")"");
        }

        input.close();
    }
}",0.672108843537415
0_Exercise09_04.java," /**
 * *9.4 (Use the Random class) Write a program that creates a Random object with seed
 * 1000 and displays the first 50 random integers between 0 and 100 using the
 * nextInt(100) method.
 */","package ch_09;

import java.util.Random;


public class Exercise09_04 {
    private static final int seed = 1000;
    private static final int n = 100;

    public static void main(String[] args) {
        Random random = new Random(seed);
        for (int i = 0; i < 50; i++) {
            if (i % 10 == 0) System.out.println();

            System.out.print(random.nextInt(n) + "" "");
        }
    }
}
","import java.util.Random;

public class RandomDemo {
    public static void main(String[] args) {
        Random random = new Random(1000); // create a Random object with seed 1000
        for (int i = 0; i < 50; i++) {
            System.out.print(random.nextInt(100) + "" ""); // generate and display a random integer between 0 and 100
        }
    }
}",4,"import java.util.Random;

public class RandomNumberGenerator {
    public static void main(String[] args) {
        Random rand = new Random(1000);
        
        System.out.println(""Generating 50 random numbers between 0 and 100:"");
        for (int i = 0; i < 50; i++) {
            int randomNumber = rand.nextInt(100);
            System.out.println(""Random number "" + (i + 1) + "": "" + randomNumber);
        }
    }
}",0.6933333333333334
0_Exercise09_05.java," /**
 * *9.5 (Use the GregorianCalendar class) Java API has the GregorianCalendar class
 * in the java.util package, which you can use to obtain the year, month, and day of a
 * date. The no-arg constructor constructs an instance for the current date,
 * and the methods get(GregorianCalendar.YEAR), get(GregorianCalendar.MONTH),
 * and get(GregorianCalendar.DAY_OF_MONTH) return the year, month, and day.
 * Write a program to perform two tasks:
 * ■ Display the current year, month, and day.
 * ■ The GregorianCalendar class has the setTimeInMillis(long), which
 * can be used to set a specified elapsed time since January 1, 1970. Set the value
 * to 1234567898765L and display the year, month, and day.
 */","package ch_09;

import java.util.GregorianCalendar;


public class Exercise09_05 {

    public static void main(String[] args) {
        GregorianCalendar gregorianCalendar = new GregorianCalendar();
        int year = gregorianCalendar.get(GregorianCalendar.YEAR);
        int month = gregorianCalendar.get(GregorianCalendar.MONTH);
        int day = gregorianCalendar.get(GregorianCalendar.DAY_OF_MONTH);

        System.out.println(""Display the current year, month, and day: "");
        System.out.println(""Year: "" + year + "", Month: "" + month + "", Day of month: "" + day);

        System.out.println(""Setting GregorianCalendar.setTimeInMillis(long) to 1234567898765L"");

        gregorianCalendar.setTimeInMillis(1234567898765L);
        year = gregorianCalendar.get(GregorianCalendar.YEAR);
        month = gregorianCalendar.get(GregorianCalendar.MONTH);
        day = gregorianCalendar.get(GregorianCalendar.DAY_OF_MONTH);

        System.out.println(""Year: "" + year + "", Month: "" + month + "", Day of month: "" + day);

    }
}
","import java.util.GregorianCalendar;

public class GregorianCalendarDemo {

    public static void main(String[] args) {
        
        // Display the current year, month, and day
        GregorianCalendar current = new GregorianCalendar();
        System.out.println(""Current Year: "" + current.get(GregorianCalendar.YEAR));
        System.out.println(""Current Month: "" + current.get(GregorianCalendar.MONTH));
        System.out.println(""Current Day: "" + current.get(GregorianCalendar.DAY_OF_MONTH));
        
        // Set the elapsed time to 1234567898765L and display the year, month, and day
        GregorianCalendar specific = new GregorianCalendar();
        specific.setTimeInMillis(1234567898765L);
        System.out.println(""Specific Year: "" + specific.get(GregorianCalendar.YEAR));
        System.out.println(""Specific Month: "" + specific.get(GregorianCalendar.MONTH));
        System.out.println(""Specific Day: "" + specific.get(GregorianCalendar.DAY_OF_MONTH));
    }

}",4,"import java.util.*;

public class DateDisplay {
    public static void main(String[] args) {
        // Creating a GregorianCalendar object to work with dates
        GregorianCalendar currentDate = new GregorianCalendar();

        // Fetching current year, month, and day
        int currentYear = currentDate.get(Calendar.YEAR);
        int currentMonth = currentDate.get(Calendar.MONTH) + 1; // Months are indexed from 0
        int currentDay = currentDate.get(Calendar.DAY_OF_MONTH);

        // Displaying current date
        System.out.println(""Today's Date:"");
        System.out.println(""Year: "" + currentYear);
        System.out.println(""Month: "" + currentMonth);
        System.out.println(""Day: "" + currentDay);

        // Now, let's set a specific time and display the date
        long specifiedTime = 1234567898765L;
        currentDate.setTimeInMillis(specifiedTime);

        // Fetching year, month, and day for the specified time
        int specifiedYear = currentDate.get(Calendar.YEAR);
        int specifiedMonth = currentDate.get(Calendar.MONTH) + 1;
        int specifiedDay = currentDate.get(Calendar.DAY_OF_MONTH);

        // Displaying the date for the specified time
        System.out.println(""\nDate for 1234567898765 milliseconds after January 1, 1970:"");
        System.out.println(""Year: "" + specifiedYear);
        System.out.println(""Month: "" + specifiedMonth);
        System.out.println(""Day: "" + specifiedDay);
    }
}",0.543040293040293
0_Exercise09_11.java," /**
 * Write a test program that prompts the user to enter a, b, c, d, e, and f and
 * displays the result. If ad minus bc is 0, report that ""The equation has
 * no solution.""
 */","package ch_09.exercise09_11;

import java.util.Scanner;


public class Exercise09_11 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double a, b, c, d, e, f;

        System.out.println(""Enter values for a, b, c, d, e, and f now:"");

        a = input.nextDouble();
        b = input.nextDouble();
        c = input.nextDouble();
        d = input.nextDouble();
        e = input.nextDouble();
        f = input.nextDouble();

        LinearEquation tester = new LinearEquation(a, b, c, d, e, f);

        if (tester.isSolvable()) {


            System.out.println(""x is "" + tester.getX());
            System.out.println(""y is "" + tester.getY());


        } else {
            System.out.println(""The equation has no solution"");
        }
        input.close();
    }
}
","import java.util.Scanner;

public class LinearEquationSolver {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter values for a, b, c, d, e, and f
        System.out.print(""Enter a, b, c, d, e, f: "");
        double a = input.nextDouble();
        double b = input.nextDouble();
        double c = input.nextDouble();
        double d = input.nextDouble();
        double e = input.nextDouble();
        double f = input.nextDouble();

        // Compute the solution of the linear equation
        double denominator = a * d - b * c;
        double x = (e * d - b * f) / denominator;
        double y = (a * f - e * c) / denominator;

        // Display the result
        if (denominator == 0) {
            System.out.println(""The equation has no solution."");
        } else {
            System.out.printf(""x is %.2f and y is %.2f%n"", x, y);
        }
    }
}",4,"import java.util.Scanner;

public class EquationSolver {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.println(""Please enter the values for a, b, c, d, e, and f:"");

        System.out.print(""Enter a: "");
        double a = input.nextDouble();

        System.out.print(""Enter b: "");
        double b = input.nextDouble();

        System.out.print(""Enter c: "");
        double c = input.nextDouble();

        System.out.print(""Enter d: "");
        double d = input.nextDouble();

        System.out.print(""Enter e: "");
        double e = input.nextDouble();

        System.out.print(""Enter f: "");
        double f = input.nextDouble();

        double determinant = a * d - b * c;

        if (determinant == 0) {
            System.out.println(""The equation has no solution."");
        } else {
            double x = (e * d - b * f) / determinant;
            double y = (a * f - e * c) / determinant;

            System.out.println(""x is "" + x + "" and y is "" + y);
        }

        input.close();
    }
}",0.6914893617021277
0_LinearEquation.java," /**
 * Exercise 9.11 (Algebra: 2 � 2 linear equations) Design a class
 * named LinearEquation for a 2 � 2 system of linear equations:
 * <p>
 * <p>
 * The class contains:
 * <p>
 * Private data fields a, b, c, d, e, and f.
 * <p>
 * A constructor with the arguments for a, b, c, d, e, and f.
 * <p>
 * Six getter methods for a, b, c, d, e, and f.
 * <p>
 * A method named isSolvable() that returns true if ad minus bc is not 0.
 * <p>
 * <p>
 * Methods getCenterX() and getCenterY() that return the solution for the equation.
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 */","package ch_09.exercise09_11;


//|_____________________________UML Diagram_____________________________________|
/*																				|
 * 					   		   Linear Equation							   	    |
 * _____________________________________________________________________________|
 * 																				|
 *      -a:double																|
 *      -b:double    									           				|
 * 	    -c:double		  														|
 * 	    -d:double		                                            			|
 * 		-e:double																|
 * 		-f:double																|
 * _____________________________________________________________________________|
 *		LinearEquation(double:a,double:b,double:c,double:d,double:e,double:f)	|
 *		getA(): void															|
 *		getB(): void															|
 *		getC(): void															|
 *		getD(): void															|
 *		getE(): void															|
 *		getF(): void															|
 *		isSolvable(): boolean													|
 * 		getCenterX(): double															|
 * 		getCenterY(): double															|
 * 																				|
 *______________________________________________________________________________*/



public class LinearEquation {

    private double a;
    private double b;
    private double c;
    private double d;
    private double e;
    private double f;


    public LinearEquation(double a, double b, double c, double d, double e, double f) {

        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;

    }

    public double getA() {
        return a;
    }

    public double getB() {
        return b;
    }

    public double getC() {
        return c;
    }

    public double getD() {
        return d;
    }

    public double getE() {

        return e;
    }

    public double getF() {
        return f;
    }

    public boolean isSolvable() {

        return a * d - b * c != 0;
    }

    public double getX() {


        double x = (this.getE() * this.getD() - this.getB() * this.getF()) /
                (this.getA() * this.getD() - this.getB() * this.getC());

        return x;
    }

    public double getY() {
        double y = (this.getA() * this.getF() - this.getE() * this.getC()) /
                (this.getA() * this.getD() - this.getB() * this.getC());
        return y;
    }
}
","-----------------------------------------
| LinearEquation                          |
-----------------------------------------
| -a: double                              |
| -b: double                              |
| -c: double                              |
| -d: double                              |
| -e: double                              |
| -f: double                              |
-----------------------------------------
| +LinearEquation(a: double, b: double,  |
|    c: double, d: double, e: double, f: |
|    double)                              |
| +getA(): double                         |
| +getB(): double                         |
| +getC(): double                         |
| +getD(): double                         |
| +getE(): double                         |
| +getF(): double                         |
| +isSolvable(): boolean                  |
| +getCenterX(): double                   |
| +getCenterY(): double                   |
-----------------------------------------
 public class LinearEquation {
    private double a, b, c, d, e, f;

    public LinearEquation(double a, double b, double c, double d, double e, double f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;
    }

    public double getA() {
        return a;
    }

    public double getB() {
        return b;
    }

    public double getC() {
        return c;
    }

    public double getD() {
        return d;
    }

    public double getE() {
        return e;
    }

    public double getF() {
        return f;
    }

    public boolean isSolvable() {
        return (a * d - b * c) != 0;
    }

    public double getCenterX() {
        return (e * d - b * f) / (a * d - b * c);
    }

    public double getCenterY() {
        return (a * f - e * c) / (a * d - b * c);
    }
}",4,"public class LinearEquation {
    private double a, b, c, d, e, f;

    public LinearEquation(double a, double b, double c, double d, double e, double f) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.e = e;
        this.f = f;
    }

    public double getA() {
        return a;
    }

    public double getB() {
        return b;
    }

    public double getC() {
        return c;
    }

    public double getD() {
        return d;
    }

    public double getE() {
        return e;
    }

    public double getF() {
        return f;
    }

    public boolean isSolvable() {
        return (a * d - b * c) != 0;
    }

    public double getCenterX() {
        return (e * d - b * f) / (a * d - b * c);
    }

    public double getCenterY() {
        return (a * f - e * c) / (a * d - b * c);
    }
}",0.7058217413704276
0_Exercise09_10.java," /**
 * *9.10 (Algebra: quadratic equations) Design a class named QuadraticEquation for
 * a quadratic equation ax2 + bx + x = 0. The class contains:
 * ■ Private data fields a, b, and c that represent three coefficients.
 * ■ A constructor for the arguments for a, b, and c.
 * ■ Three getter methods for a, b, and c.
 * ■ A method named getDiscriminant() that returns the discriminant, which is
 * b2 - 4ac.
 * ■ The methods named getRoot1() and getRoot2() for returning two roots of
 * the equation
 * r1 = -b + Sqrt(b^2 - 4ac) / 2a
 * r2 = -b - Sqrt(b2 - 4ac) / 2a
 * These methods are useful only if the discriminant is non-negative.
 * Let these methods return 0 if the discriminant is negative.
 * <p>
 * Draw the UML diagram for the class and then implement the class {@link ch_09.exercise09_10.QuadraticEquation UML
 * Diagram}.
 * <p>
 * Write a test program that prompts the user to enter values for a, b, and c and displays the result
 * based on the discriminant. If the discriminant is positive, display the two roots. If
 * the discriminant is 0, display the one root. Otherwise, display “The equation has
 * no roots.” See Programming Exercise 3.1 for sample runs.
 */","package ch_09.exercise09_10;

import java.util.Scanner;


public class Exercise09_10 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter values for a, b, and c: "");

        double a = in.nextDouble();
        double b = in.nextDouble();
        double c = in.nextDouble();
        QuadraticEquation quadraticEquation = new QuadraticEquation(a, b, c);

        double discriminant = quadraticEquation.getDiscriminant();
        System.out.printf(""The discriminant value is %.2f"", discriminant);

        if (discriminant > 0) {//-1.234 2.111 1.987
            System.out.print("" and the two root values are: "");
            System.out.printf(""%.5f"", quadraticEquation.getRoot1());
            System.out.print(""  "");
            System.out.printf(""%.5f"", quadraticEquation.getRoot2());
        } else if (discriminant == 0) {
            System.out.print("" and the one root value is: "");
            System.out.println(quadraticEquation.getRoot1() + ""(Root 1)"");
        } else {
            System.out.println("" The equation has no roots."");
        }


    }
}
","import java.util.Scanner;

public class QuadraticEquation {
    private double a;
    private double b;
    private double c;
    
    public QuadraticEquation(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
    
    public double getA() {
        return a;
    }
    
    public double getB() {
        return b;
    }
    
    public double getC() {
        return c;
    }
    
    public double getDiscriminant() {
        return b * b - 4 * a * c;
    }
    
    public double getRoot1() {
        if (getDiscriminant() < 0) {
            return 0;
        }
        return (-b + Math.sqrt(getDiscriminant())) / (2 * a);
    }
    
    public double getRoot2() {
        if (getDiscriminant() < 0) {
            return 0;
        }
        return (-b - Math.sqrt(getDiscriminant())) / (2 * a);
    }
    
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter a, b, c: "");
        double a = input.nextDouble();
        double b = input.nextDouble();
        double c = input.nextDouble();
        
        QuadraticEquation equation = new QuadraticEquation(a, b, c);
        
        double discriminant = equation.getDiscriminant();
        
        if (discriminant > 0) {
            double root1 = equation.getRoot1();
            double root2 = equation.getRoot2();
            System.out.println(""The roots are "" + root1 + "" and "" + root2);
        } else if (discriminant == 0) {
            double root = -b / (2 * a);
            System.out.println(""The root is "" + root);
        } else {
            System.out.println(""The equation has no roots."");
        }
    }
}
",4,"import java.util.Scanner;

public class QuadEquation {
    private double a;
    private double b;
    private double c;

    public QuadEquation(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public double getA() {
        return this.a;
    }

    public double getB() {
        return this.b;
    }

    public double getC() {
        return this.c;
    }

    public double getDiscriminant() {
        return (this.b * this.b) - (4 * this.a * this.c);
    }

    public double getRoot1() {
        double discriminant = getDiscriminant();
        if (discriminant < 0) {
            return 0;
        } else {
            return (-this.b + Math.sqrt(discriminant)) / (2 * this.a);
        }
    }

    public double getRoot2() {
        double discriminant = getDiscriminant();
        if (discriminant < 0) {
            return 0;
        } else {
            return (-this.b - Math.sqrt(discriminant)) / (2 * this.a);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.println(""Enter values for a, b, and c:"");
        double a = scanner.nextDouble();
        double b = scanner.nextDouble();
        double c = scanner.nextDouble();
        
        QuadEquation equation = new QuadEquation(a, b, c);
        double discriminant = equation.getDiscriminant();
        
        if (discriminant > 0) {
            System.out.println(""Root 1: "" + equation.getRoot1());
            System.out.println(""Root 2: "" + equation.getRoot2());
        } else if (discriminant == 0) {
            System.out.println(""Single Root: "" + equation.getRoot1());
        } else {
            System.out.println(""The equation has no roots."");
        }
        
        scanner.close();
    }
}",0.8442389758179232
0_QuadraticEquation.java," /**
 * *9.10 (Algebra: quadratic equations) Design a class named QuadraticEquation for
 * a quadratic equation ax2 + bx + x = 0. The class contains:
 * ■ Private data fields a, b, and c that represent three coefficients.
 * ■ A constructor for the arguments for a, b, and c.
 * ■ Three getter methods for a, b, and c.
 * ■ A method named getDiscriminant() that returns the discriminant, which is
 * b2 - 4ac.
 * ■ The methods named getRoot1() and getRoot2() for returning two roots of
 * the equation
 * r1 = -b + Sqrt(b^2 - 4ac) / 2a
 * r2 = -b - Sqrt(b2 - 4ac) / 2a
 * These methods are useful only if the discriminant is non-negative. Let these methods return 0 if the discriminant
 * is negative.
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 */","package ch_09.exercise09_10;


//|_______________________UML Diagram________________________|
/*                                                                                                                            |
 *                                              QuadraticEquation                                         |
 * __________________________________________________________|
 *                                                                                                                         |
 *                                - a:double                               |
 *                                             - b:double                               |
 *                                             - c:double                               |
 * __________________________________________________________|
 *                QuadraticEquation(a:double,b:double,c:double)             |
 *                getRoot1(): double                                                                     |
 *             getRoot2(): double                                                                     |
 *                getDiscriminant(): double                                                         |
 *                 getA(): double                                                                                 |
 *                 getB(): double                                                                                 |
 *                 getC(): double  ss                                                                         |
 *                                                                                                                          |
 *___________________________________________________________*/



public class QuadraticEquation {
    /*  ■ Private data fields a, b, and c that represent three coefficients.*/
    private double a;
    private double b;
    private double c;

    /* ■ A constructor for the arguments for a, b, and c. */
    public QuadraticEquation(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    /* ■ The methods named getRoot1() and getRoot2() for returning two roots of the equation */
    protected double getRoot1() {
        if (getDiscriminant() < 0) {
            return 0;
        }
        return (-b + Math.sqrt(Math.pow(b, 2) - (4 * a * c)) / (2 * a));
    }

    protected double getRoot2() {
        if (getDiscriminant() < 0) {
            return 0;
        }
        return (-b - Math.sqrt(Math.pow(b, 2) - (4 * a * c)) / (2 * a));
    }

    /* ■ A method named getDiscriminant() that returns the discriminant, which is b2 - 4ac.*/
    protected double getDiscriminant() {
        return (b * 2) - (4 * a * c);
    }


    /* ■ Three getter methods for a, b, and c. */
    public double getA() {
        return a;
    }

    public double getB() {
        return b;
    }

    public double getC() {
        return c;
    }


}
","import java.util.Scanner;

public class QuadraticEquation {
    private double a;
    private double b;
    private double c;

    public QuadraticEquation(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public double getA() {
        return a;
    }

    public double getB() {
        return b;
    }

    public double getC() {
        return c;
    }

    public double getDiscriminant() {
        return b * b - 4 * a * c;
    }

    public double getRoot1() {
        double discriminant = getDiscriminant();
        if (discriminant < 0) {
            return 0;
        } else {
            return (-b + Math.sqrt(discriminant)) / (2 * a);
        }
    }

    public double getRoot2() {
        double discriminant = getDiscriminant();
        if (discriminant < 0) {
            return 0;
        } else {
            return (-b - Math.sqrt(discriminant)) / (2 * a);
        }
    }
}

public class TestQuadraticEquation {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the values of a, b, and c: "");
        double a = input.nextDouble();
        double b = input.nextDouble();
        double c = input.nextDouble();

        QuadraticEquation equation = new QuadraticEquation(a, b, c);

        double discriminant = equation.getDiscriminant();
        if (discriminant > 0) {
            double root1 = equation.getRoot1();
            double root2 = equation.getRoot2();
            System.out.println(""The equation has two roots "" + root1 + "" and "" + root2);
        } else if (discriminant == 0) {
            double root = equation.getRoot1();
            System.out.println(""The equation has one root "" + root);
        } else {
            System.out.println(""The equation has no roots"");
        }
    }
}",4,"public class QuadraticEquation {
    private double a;
    private double b;
    private double c;

    public QuadraticEquation(double a, double b, double c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }

    public double getA() {
        return this.a;
    }

    public double getB() {
        return this.b;
    }

    public double getC() {
        return this.c;
    }

    public double getDiscriminant() {
        return (this.b * this.b) - (4 * this.a * this.c);
    }

    public double getRoot1() {
        double discriminant = getDiscriminant();
        if (discriminant < 0) {
            return 0;
        } else {
            return (-this.b + Math.sqrt(discriminant)) / (2 * this.a);
        }
    }

    public double getRoot2() {
        double discriminant = getDiscriminant();
        if (discriminant < 0) {
            return 0;
        } else {
            return (-this.b - Math.sqrt(discriminant)) / (2 * this.a);
        }
    }

    public static void main(String[] args) {
        // Example usage
        QuadraticEquation equation = new QuadraticEquation(1, -3, 2);
        double discriminant = equation.getDiscriminant();
        double root1 = equation.getRoot1();
        double root2 = equation.getRoot2();

        System.out.println(""Discriminant: "" + discriminant);
        System.out.println(""Root 1: "" + root1);
        System.out.println(""Root 2: "" + root2);
    }
}",0.8046320508031378
0_Account.java," /**
 * Exercise 9.7 (The Account class) Design a class named Account that contains:
 * <p>
 * A private int data field named id for the account (default 0).
 * <p>
 * A private double data field named balance for the account (default 0).
 * <p>
 * A private double data field named annualInterestRate that stores the current interest rate
 * <p>
 * (default 0). Assume all accounts have the same interest rate.
 * <p>
 * A private Date data field named dateCreated that stores the date when the account was created.
 * <p>
 * A no-arg constructor that creates a default account.
 * <p>
 * A constructor that creates an account with the specified id and initial balance.
 * <p>
 * The accessor and mutator methods for id, balance, and annualInterestRate.
 * <p>
 * The accessor method for dateCreated.
 * <p>
 * A method named getMonthlyInterestRate() that returns the monthly interest rate.
 * <p>
 * A method named getMonthlyInterest() that returns the monthly interest.
 * <p>
 * A method named withdraw that withdraws a specified amount from the account.
 * <p>
 * A method named deposit that deposits a specified amount to the account.
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 * (Hint: The method getMonthlyInterest() is to return monthly interest, not the interest rate.
 * Monthly interest is balance * monthlyInterestRate. monthlyInterestRate is annualInterestRate / 12.
 * Note that annualInterestRate is a percentage, e.g., like 4.5%. You need to divide it by 100.)
 * <p>
 * Write a test program that creates an Account object with an account ID of 1122, a balance of
 * $20,000, and an annual interest rate of 4.5%. Use the withdraw method to withdraw $2,500, use
 * the deposit method to deposit $3,000, and print the balance, the monthly interest, and the
 * date when this account was created.
 */","package ch_09.exercise09_07;

import java.util.Date;


//__________________________UML DIAGRAM_____________________________*
/*                                                                                                                                        |
 *                                                           Account                                                                |
 *-------------------------------------------------------------------|
 *         -id : int                                                                                                                |
 *                                                                                                                                         |
 *  -balance : double                                                                                                |
 *                                                                                                                                         |
 *         -annualInterestRate : double                                                                        |
 *                                                                                                                                         |
 *         -dateCreated : Date                                                                                                |
 *-------------------------------------------------------------------|
 *          +Account()                                                                                                                |
 *                                                                                                                                          |
 *          +Account(ID:int,balance: double)                                                                |
 *                                                                                                                                         |
 *         +getID() : int                                                                                                        |
 *                                                                                                                                          |
 *         +setID() : void                                                                                                        |
 *                                                                                                                                         |
 *         +getBalance() : double                                                                                        |
 *                                                                                                                                         |
 *         +setBalance(balance:double) : void                                                                |
 *                                                                                                                                         |
 *         +getAnnualInterestRate() : double                                                                |
 *                                                                                                                                         |
 *         +setAnnualInterestRate(double: newInterestRate) : void                         |
 *                                                                                                                                         |
 *         +getDateCreated() : Date                                                                                |
 *                                                                                                                                         |
 *         +getMonthlyInterestRate(interestRatePerYear: double)                    |
 *                                                                                                                                         |
 * +getMonthlyInterest(InterestRatePerMonth:double,balance:double)   |
 *                                                                                                                                         |
 *         +withdraw(amount: double, balance: double)                                                |
 *                                                                                                                                         |
 *         +deposit(amount: double, balance: double)                                                |
 *___________________________________________________________________|  */



public class Account {

    private int id;

    private double balance;

    private double annualInterestRate;

    private Date dateCreated;

    public Account() {
        id = 0;
        balance = 0;
        annualInterestRate = 0;

    }

    public Account(int newId, double newBalance) {

        this.id = newId;
        this.balance = newBalance;
        dateCreated = new Date();
        annualInterestRate = 0;
    }

    public int getID() {

        return id;
    }

    public void setID(int newID) {

        this.id = newID;
    }

    public double getBalance() {

        return balance;
    }

    public void setBalance(double newBalance) {

        this.balance = newBalance;
    }

    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    public void setAnnualInterestRate(double newInterestRate) {

        this.annualInterestRate = newInterestRate;
    }

    public Date getDateCreated() {

        Date startDate = dateCreated;

        return startDate;
    }

    public double getMonthlyInterestRate() {

        double InterestRatePerMonth = (annualInterestRate / 12);

        return InterestRatePerMonth;
    }

    public double getMonthlyInterest() {

        double monthlyInterest = balance * (this.getMonthlyInterestRate() / 100);

        return monthlyInterest;
    }

    public void withdraw(double amount) {

        balance -= amount;
    }

    public void deposit(double amountDeposit) {

        balance += amountDeposit;

    }

    @Override
    public String toString() {

        return ""\nAccount ID: "" + getID() + ""\nBalance: "" + getBalance() +
                ""\nDate created "" + getDateCreated();
    }

}
","----------------------------------------
|               Account                  |
+----------------------------------------+
| - id: int                              |
| - balance: double                      |
| - annualInterestRate: double           |
| - dateCreated: Date                    |
|----------------------------------------|
| + Account()                            |
| + Account(id: int, balance: double)    |
| + getId(): int                         |
| + setId(id: int): void                 |
| + getBalance(): double                 |
| + setBalance(balance: double): void    |
| + getAnnualInterestRate(): double      |
| + setAnnualInterestRate(rate: double): void|
| + getDateCreated(): Date               |
| + getMonthlyInterestRate(): double     |
| + getMonthlyInterest(): double         |
| + withdraw(amount: double): void       |
| + deposit(amount: double): void        |
+----------------------------------------+ import java.util.Date;

public class Account {
    private int id;
    private double balance;
    private double annualInterestRate;
    private Date dateCreated;

    public Account() {
        this(0, 0);
    }

    public Account(int id, double balance) {
        this.id = id;
        this.balance = balance;
        this.annualInterestRate = 0;
        this.dateCreated = new Date();
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    public void setAnnualInterestRate(double rate) {
        this.annualInterestRate = rate;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public double getMonthlyInterestRate() {
        return annualInterestRate / 12;
    }

    public double getMonthlyInterest() {
        return balance * getMonthlyInterestRate() / 100;
    }

    public void withdraw(double amount) {
        balance -= amount;
    }

    public void deposit(double amount) {
        balance += amount;
    }

    public static void main(String[] args) {
        Account account = new Account(1122, 20000);
        account.setAnnualInterestRate(4.5);
        account.withdraw(2500);
        account.deposit(3000);
        System.out.println(""Balance: $"" + account.getBalance());
        System.out.println(""Monthly Interest: $"" + account.getMonthlyInterest());
        System.out.println(""Date created: "" + account.getDateCreated());
    }
}",4,"import java.util.Date;

public class Account {
    private int id;
    private double balance;
    private double annualInterestRate;
    private Date dateCreated;

    public Account() {
        id = 0;
        balance = 0;
        annualInterestRate = 0;
        dateCreated = new Date();
    }

    public Account(int id, double balance) {
        this.id = id;
        this.balance = balance;
        annualInterestRate = 0;
        dateCreated = new Date();
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public double getAnnualInterestRate() {
        return annualInterestRate;
    }

    public void setAnnualInterestRate(double annualInterestRate) {
        this.annualInterestRate = annualInterestRate;
    }

    public Date getDateCreated() {
        return dateCreated;
    }

    public double getMonthlyInterestRate() {
        return annualInterestRate / 12 / 100;
    }

    public double getMonthlyInterest() {
        return balance * getMonthlyInterestRate();
    }

    public void withdraw(double amount) {
        balance -= amount;
    }

    public void deposit(double amount) {
        balance += amount;
    }
}public class TestAccount {
    public static void main(String[] args) {
        Account myAccount = new Account(1122, 20000);
        myAccount.setAnnualInterestRate(4.5);

        myAccount.withdraw(2500);
        myAccount.deposit(3000);

        System.out.println(""Balance: $"" + myAccount.getBalance());
        System.out.println(""Monthly Interest: $"" + myAccount.getMonthlyInterest());
        System.out.println(""Date Created: "" + myAccount.getDateCreated());
    }
}",0.7631151974040021
0_RegularPolygon.java," /**
 * Exercise 9.9 (Geometry: n-sided regular polygon) In an n-sided regular polygon,
 * all sides have the same length and all angles have the same degree (i.e.,
 * the polygon is both equilateral and equiangular). Design a class named
 * RegularPolygon that contains:
 * <p>
 * A private int data field named n that defines the number of sides in the polygon with default value 3.
 * <p>
 * A private double data field named side that stores the length of the side with default value 1.
 * <p>
 * A private double data field named x that defines the x-coordinate of the polygon's center with default value 0.
 * <p>
 * A private double data field named y that defines the y-coordinate of the polygon's center with default value 0.
 * <p>
 * A no-arg constructor that creates a regular polygon with default values.
 * <p>
 * A constructor that creates a regular polygon with the specified number of sides and length of side, centered at (0, 0).
 * <p>
 * A constructor that creates a regular polygon with the specified number of sides, length of side, and x- and y-coordinates.
 * <p>
 * The accessor and mutator methods for all data fields.
 * <p>
 * The method getPerimeter() that returns the perimeter of the polygon.
 * <p>
 * The method get
 * Area() that returns the area of the polygon. The formula for computing the area of a regular polygon is
 * Area=n�s24�tan(n).
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 * <p>
 * Write a test program that creates three RegularPolygon objects,
 * created using the no-arg constructor, using RegularPolygon(6, 4),
 * and using RegularPolygon(10, 4, 5.6, 7.8). For each object,
 * display its perimeter and area.
 */","package ch_09.exercise09_09;


//|_____________________________UML Diagram_____________________________________|
/*																				|
 * 					   		    RegularPolygon								    |
 * _____________________________________________________________________________|
 * 																				|
 *     + n:int          (defines # of sides default 3)							|
 *     + side:double    (length of side default 1)            					|
 * 	   + x:double		  (x of center coordinate default 0)    				|
 * 	   + y:double		  (y of center coordinate default 0)    				|
 * _____________________________________________________________________________|
 *		RegularPolygon()									  					|
 *		RegularPolygon(sides:int,lengthSide:double) (at (0,0))					|
 *		RegularPolygon(sides:int,lengthSide:double,x:double,y:double) (x,y)		|
 *		getSide(): double														|
 * 	    setSide(side: double) :void												|
 *		getNumSides(): double													|
 * 		setNumSides(numSides:int) :void											|
 * 		setCenterX(newX:int) :void													|
 * 		getCenterX(): double															|
 * 		setTopLeftY(newY:int) :void													|
 * 		getCenterY(): double															|
 *  	getPerimeter()															|
 * 		getArea() : double														|
 * 																				|
 * 																				|
 * 																				|
 *______________________________________________________________________________*/



public class RegularPolygon {

    private int n;
    private double side;
    private double x;
    private double y;

    RegularPolygon() {

        n = 3;
        side = 1;
        x = 0;
        y = 0;

    }

    RegularPolygon(int numSides, double sideLength) {

        n = numSides;
        side = sideLength;

    }

    RegularPolygon(int numSides, double sideLength, double ex, double why) {

        n = numSides;
        side = sideLength;
        x = ex;
        y = why;

    }

    public void setNumSides(int newNum) {

        n = newNum;

    }

    public int getNumSides() {

        return n;
    }

    public void setSide(double newLength) {

        side = newLength;
    }

    public double getSide() {
        return side;
    }

    public void setX(int newX) {

        x = newX;
    }

    public double getX() {
        return x;

    }

    public void setY(double newY) {

        y = newY;
    }

    public double getY() {
        return y;
    }

    public double getPerimeter() {

        return n * side;

    }

    public double getArea() {

        return n * (Math.pow(side, 2) / 4 * Math.tan(Math.PI / n));
    }
}
","_____________________________________
|          RegularPolygon            |
|------------------------------------|
| -n: int                            |
| -side: double                      |
| -x: double                         |
| -y: double                         |
|------------------------------------|
| +RegularPolygon()                  |
| +RegularPolygon(n: int, side: double)|
| +RegularPolygon(n: int, side: double, x: double, y: double)|
| +getN(): int                       |
| +setN(n: int): void                |
| +getSide(): double                 |
| +setSide(side: double): void       |
| +getX(): double                    |
| +setX(x: double): void             |
| +getY(): double                    |
| +setY(y: double): void             |
| +getPerimeter(): double            |
| +getArea(): double                 |
|____________________________________|
 public class RegularPolygon {
    private int n;
    private double side;
    private double x;
    private double y;
    
    public RegularPolygon() {
        this.n = 3;
        this.side = 1.0;
        this.x = 0.0;
        this.y = 0.0;
    }
    
    public RegularPolygon(int n, double side) {
        this.n = n;
        this.side = side;
        this.x = 0.0;
        this.y = 0.0;
    }
    
    public RegularPolygon(int n, double side, double x, double y) {
        this.n = n;
        this.side = side;
        this.x = x;
        this.y = y;
    }
    
    public int getN() {
        return this.n;
    }
    
    public void setN(int n) {
        this.n = n;
    }
    
    public double getSide() {
        return this.side;
    }
    
    public void setSide(double side) {
        this.side = side;
    }
    
    public double getX() {
        return this.x;
    }
    
    public void setX(double x) {
        this.x = x;
    }
    
    public double getY() {
        return this.y;
    }
    
    public void setY(double y) {
        this.y = y;
    }
    
    public double getPerimeter() {
        return n * side;
    }
    
    public double getArea() {
        return (n * Math.pow(side, 2)) / (4 * Math.tan(Math.PI / n));
    }
}",4,"public class RegularPolygon {
    private int numSides;
    private double sideLength;
    private double xCoordinate;
    private double yCoordinate;

    public RegularPolygon() {
        numSides = 3;
        sideLength = 1.0;
        xCoordinate = 0.0;
        yCoordinate = 0.0;
    }

    public RegularPolygon(int sides, double length) {
        numSides = sides;
        sideLength = length;
        xCoordinate = 0.0;
        yCoordinate = 0.0;
    }

    public RegularPolygon(int sides, double length, double x, double y) {
        numSides = sides;
        sideLength = length;
        xCoordinate = x;
        yCoordinate = y;
    }

    public int getNumSides() {
        return numSides;
    }

    public void setNumSides(int sides) {
        numSides = sides;
    }

    public double getSideLength() {
        return sideLength;
    }

    public void setSideLength(double length) {
        sideLength = length;
    }

    public double getXCoordinate() {
        return xCoordinate;
    }

    public void setXCoordinate(double x) {
        xCoordinate = x;
    }

    public double getYCoordinate() {
        return yCoordinate;
    }

    public void setYCoordinate(double y) {
        yCoordinate = y;
    }

    public double getPerimeter() {
        return numSides * sideLength;
    }

    public double getArea() {
        return (numSides * Math.pow(sideLength, 2)) / (4 * Math.tan(Math.PI / numSides));
    }
}

public class RegularPolygonTest {
    public static void main(String[] args) {
        RegularPolygon polygon1 = new RegularPolygon();
        RegularPolygon polygon2 = new RegularPolygon(6, 4.0);
        RegularPolygon polygon3 = new RegularPolygon(10, 4.0, 5.6, 7.8);

        System.out.println(""Polygon 1 - Perimeter: "" + polygon1.getPerimeter() + "", Area: "" + polygon1.getArea());
        System.out.println(""Polygon 2 - Perimeter: "" + polygon2.getPerimeter() + "", Area: "" + polygon2.getArea());
        System.out.println(""Polygon 3 - Perimeter: "" + polygon3.getPerimeter() + "", Area: "" + polygon3.getArea());
    }
}",0.5029868578255675
0_Fan.java," /**
 * 9.8 (The Fan class) Design a class named Fan to represent a fan. The class contains:
 * ■ Three constants named SLOW, MEDIUM, and FAST with the values 1, 2, and 3 to
 * denote the fan speed.
 * ■ A private int data field named speed that specifies the speed of the fan (the
 * default is SLOW).
 * ■ A private boolean data field named on that specifies whether the fan is on (the
 * default is false).
 * ■ A private double data field named radius that specifies the radius of the fan
 * (the default is 5).
 * ■ A string data field named color that specifies the color of the fan (the default
 * is blue).
 * ■ The accessor and mutator methods for all four data fields.
 * ■ A no-arg constructor that creates a default fan.
 * ■ A method named toString() that returns a string description for the fan. If
 * the fan is on, the method returns the fan speed, color, and radius in one combined string.
 * If the fan is not on, the method returns the fan color and radius
 * along with the string “fan is off” in one combined string.
 * Draw the UML diagram for the class and then implement the class.
 */","package ch_09.exercise09_08;


//__________________________UML DIAGRAM_____________________________*
/*																	|
 * 							  Fan   								|
 *------------------------------------------------------------------|
 * 	-SLOW : int														|
 * 																	|
 *  -MEDIUM : int				    								|
 * 																	|
 * 	-FAST : int			                    						|
 * 																	|
 * 	-speed : int    		                                        |
 *                          										|
 * 	-on : boolean    					                            |
 *                                      							|
 * 	-radius : double   			                                    |
 *                              									|
 * 	-color : String    												|
 *------------------------------------------------------------------|
 * 	 +Fan()				    										|
 * 	 +toString: String								   				|
 *__________________________________________________________________|  */



public class Fan {
    public static final int SLOW = 1;
    public static final int MEDIUM = 2;
    public static final int FAST = 3;

    private int speed;
    private boolean on;
    private double radius;
    private String color;

    public Fan() {
        speed = SLOW;
        on = false;
        radius = 5.0;
        color = ""blue"";
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }

    public boolean isOn() {
        return on;
    }

    public void setOn(boolean on) {
        this.on = on;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        String special = """";
        if (on) {
            special += ""speed="" + speed +
                    "", radius="" + radius +
                    "", color='"" + color + ""'"";
        } else {
            special += ""fan is off"" +
                    "", radius="" + radius +
                    "", color='"" + color + ""'"";
        }
        return ""Fan{"" +
                special +
                '}';
    }
}
","--------------------------------
|            Fan               |
--------------------------------
| - SLOW: int = 1              |
| - MEDIUM: int = 2            |
| - FAST: int = 3              |
| - speed: int = SLOW          |
| - on: boolean = false        |
| - radius: double = 5.0       |
| - color: String = ""blue""     |
--------------------------------
| + getSpeed(): int            |
| + setSpeed(speed: int): void |
| + isOn(): boolean            |
| + setOn(on: boolean): void   |
| + getRadius(): double        |
| + setRadius(radius: double): void |
| + getColor(): String         |
| + setColor(color: String): void |
| + Fan()                      |
| + toString(): String         |
--------------------------------
 public class Fan {
    // Constants
    public static final int SLOW = 1;
    public static final int MEDIUM = 2;
    public static final int FAST = 3;

    // Fields
    private int speed;
    private boolean on;
    private double radius;
    private String color;

    // Constructors
    public Fan() {
        speed = SLOW;
        on = false;
        radius = 5.0;
        color = ""blue"";
    }

    // Accessor and mutator methods
    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }

    public boolean isOn() {
        return on;
    }

    public void setOn(boolean on) {
        this.on = on;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    // toString method
    public String toString() {
        if (on) {
            return ""speed="" + speed + "", color="" + color + "", radius="" + radius;
        } else {
            return ""color="" + color + "", radius="" + radius + "", fan is off"";
        }
    }
}",4,"public class Fan {
    private final int SLOW = 1;
    private final int MEDIUM = 2;
    private final int FAST = 3;

    private int speed;
    private boolean on;
    private double radius;
    private String color;

    public Fan() {
        speed = SLOW;
        on = false;
        radius = 5.0;
        color = ""blue"";
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int speed) {
        this.speed = speed;
    }

    public boolean isOn() {
        return on;
    }

    public void setOn(boolean on) {
        this.on = on;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public String toString() {
        if (on) {
            return ""Fan speed: "" + speed + "", color: "" + color + "", radius: "" + radius;
        } else {
            return ""Fan is off. Color: "" + color + "", radius: "" + radius;
        }
    }
}",0.693795326349718
0_Exercise09_08.java," /**
 * Write a test program that creates two Fan objects. Assign maximum speed, radius 10, color
 * yellow, and turn it on to the first object. Assign medium speed, radius 5, color
 * blue, and turn it off to the second object. Display the objects by invoking their
 * toString method.
 */","package ch_09.exercise09_08;


public class Exercise09_08 {
    public static void main(String[] args) {
        Fan fan1 = new Fan();
        Fan fan2 = new Fan();

        fan1.setSpeed(Fan.FAST);
        fan1.setRadius(10);
        fan1.setColor(""yellow"");
        fan1.setOn(true);

        fan2.setSpeed(Fan.FAST);
        fan2.setRadius(5);
        fan2.setColor(""blue"");
        fan2.setOn(false);
        System.out.println(""Fan 1 toString: "" + fan1.toString());
        System.out.println(""Fan 2 toString: "" + fan2.toString());
    }
}","public class FanTest {
    public static void main(String[] args) {
        Fan fan1 = new Fan();
        fan1.setSpeed(Fan.MAX_SPEED);
        fan1.setRadius(10);
        fan1.setColor(""yellow"");
        fan1.turnOn();

        Fan fan2 = new Fan();
        fan2.setSpeed(Fan.MEDIUM_SPEED);
        fan2.setRadius(5);
        fan2.setColor(""blue"");
        fan2.turnOff();

        System.out.println(""Fan 1: "" + fan1.toString());
        System.out.println(""Fan 2: "" + fan2.toString());
    }
}",4,"public class FanTest {
    public static void main(String[] args) {
        Fan fan1 = new Fan();
        fan1.setSpeed(3);
        fan1.setRadius(10);
        fan1.setColor(""yellow"");
        fan1.setOn(true);

        Fan fan2 = new Fan();
        fan2.setSpeed(2);
        fan2.setRadius(5);
        fan2.setColor(""blue"");
        fan2.setOn(false);

        System.out.println(""Fan 1 details: "");
        System.out.println(""Speed: "" + fan1.getSpeed());
        System.out.println(""Radius: "" + fan1.getRadius());
        System.out.println(""Color: "" + fan1.getColor());
        System.out.println(""Fan is on? "" + fan1.isOn());

        System.out.println(""\nFan 2 details: "");
        System.out.println(""Speed: "" + fan2.getSpeed());
        System.out.println(""Radius: "" + fan2.getRadius());
        System.out.println(""Color: "" + fan2.getColor());
        System.out.println(""Fan is on? "" + fan2.isOn());
    }
}

class Fan {
    private int speed;
    private boolean on;
    private double radius;
    private String color;

    public Fan() {
        speed = 1;
        on = false;
        radius = 5;
        color = ""white"";
    }

    public int getSpeed() {
        return speed;
    }

    public void setSpeed(int newSpeed) {
        speed = newSpeed;
    }

    public boolean isOn() {
        return on;
    }

    public void setOn(boolean status) {
        on = status;
    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double newRadius) {
        radius = newRadius;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String newColor) {
        color = newColor;
    }
}",0.4143337066069429
0_Exercise09_01.java," /**
 * Exercise 9.1 (The Rectangle class) Following the example of the
 * Circle class in Section 9.2, design a class named Rectangle
 * to represent a rectangle. The class contains:
 * <p>
 * Two double data fields named width and height that specify
 * the width and height of the rectangle. The default values
 * are 1 for both width and height.
 * <p>
 * A no-arg constructor that creates a default rectangle.
 * <p>
 * A constructor that creates a rectangle with the specified width and height.
 * <p>
 * A method named getArea() that returns the area of this rectangle.
 * <p>
 * A method named getPerimeter() that returns the perimeter.
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 * Write a test program that creates two Rectangle objects-one with width 4 and height 40 and the other with
 * width 3.5 and height 35.9. Display the width, height, area, and perimeter of each
 * rectangle in this order.
 */","package ch_09.exercise09_01;


public class Exercise09_01 {

    public static void main(String[] args) {

        Rectangle r1 = new Rectangle(4, 40);

        Rectangle r2 = new Rectangle(3.5, 35.9);

        System.out.println(""The width, height, area, and perimeter of rectangle one are ""
                + r1.width + "" , "" + r1.height + "" , "" + r1.getArea() + "" , "" + r1.getPerimeter());


        System.out.println(""The width, height, area, and perimeter of rectangle two are ""
                + r2.width + "" , "" + r2.height + "" , "" + r2.getArea() + "" , "" + r2.getPerimeter());
    }
}
","public class Rectangle {
    private double width;
    private double height;

    public Rectangle() {
        width = 1.0;
        height = 1.0;
    }

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return width * height;
    }

    public double getPerimeter() {
        return 2 * (width + height);
    }
}",5,"// Defining the Rectangle class
public class Rectangle {
    // Data fields
    private double width;
    private double height;
    
    // Default constructor
    public Rectangle() {
        this.width = 1.0; // Default width
        this.height = 1.0; // Default height
    }
    
    // Constructor with specified width and height
    public Rectangle(double width, double height) {
        this.width = width; // Set width
        this.height = height; // Set height
    }
    
    // Method to get the area of the rectangle
    public double getArea() {
        return width * height; // Calculate area
    }
    
    // Method to get the perimeter of the rectangle
    public double getPerimeter() {
        return 2 * (width + height); // Calculate perimeter
    }
}

// Test program
public class TestRectangle {
    public static void main(String[] args) {
        // Creating two Rectangle objects
        Rectangle rectangle1 = new Rectangle(4, 40);
        Rectangle rectangle2 = new Rectangle(3.5, 35.9);
        
        // Displaying details of the rectangles
        System.out.println(""Rectangle 1:"");
        System.out.println(""Width: "" + rectangle1.width);
        System.out.println(""Height: "" + rectangle1.height);
        System.out.println(""Area: "" + rectangle1.getArea());
        System.out.println(""Perimeter: "" + rectangle1.getPerimeter());
        
        System.out.println(""\nRectangle 2:"");
        System.out.println(""Width: "" + rectangle2.width);
        System.out.println(""Height: "" + rectangle2.height);
        System.out.println(""Area: "" + rectangle2.getArea());
        System.out.println(""Perimeter: "" + rectangle2.getPerimeter());
    }
}",0.43733613004719457
0_Exercise09_06.java," /**
 * 9.6 (Stopwatch) Design a class named StopWatch. The class contains:
 * ■ Private data fields startTime and endTime with getter methods.
 * ■ A no-arg constructor that initializes startTime with the current time.
 * ■ A method named start() that resets the startTime to the current time.
 * ■ A method named stop() that sets the endTime to the current time.
 * ■ A method named getElapsedTime() that returns the elapsed time for the
 * stopwatch in milliseconds.
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 * <p>
 * Write a test program that measures the execution time of sorting 100,000 numbers
 * using selection sort.
 */","package ch_09.exercise09_06;

import java.util.Random;


public class Exercise09_06 {
    public static void main(String[] args) {
        int[] testNums = new int[100000];
        Random random = new Random();

        for (int i = 0; i < 100000; i++) {
            testNums[i] = random.nextInt(10000);
        }
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        System.out.println(""Start time: "" + stopWatch.getStartTime() + "" ms"");

        selectionSort(testNums);
        stopWatch.stop();

        System.out.println(""End time: "" + stopWatch.getEndTime() + "" ms"");

        System.out.println(""Elapsed time for selection sort: "" + stopWatch.getElapsedTime() + "" ms"");


    }

    public static void selectionSort(int[] nums) {
        for (int n = 0; n < nums.length - 1; n++) {
            int min = nums[n];
            int minIdx = n;
            for (int k = n + 1; k < nums.length; k++) {
                if (nums[k] < min) {
                    min = nums[k];
                    minIdx = k;
                }
            }
            // Swap
            if (minIdx != n) {
                nums[minIdx] = nums[n];
                nums[n] = min;
            }
        }
    }
}
","public class StopWatch {
    private long startTime;
    private long endTime;

    public StopWatch() {
        startTime = System.currentTimeMillis();
    }

    public long getStartTime() {
        return startTime;
    }

    public long getEndTime() {
        return endTime;
    }

    public void start() {
        startTime = System.currentTimeMillis();
    }

    public void stop() {
        endTime = System.currentTimeMillis();
    }

    public long getElapsedTime() {
        return endTime - startTime;
    }
}",5,"import java.util.Arrays;

// Stopwatch class
class Stopwatch {
    private long startTime;
    private long endTime;

    // Constructor initializing startTime with the current time
    public Stopwatch() {
        startTime = System.currentTimeMillis();
    }

    // Getter method for startTime
    public long getStartTime() {
        return startTime;
    }

    // Getter method for endTime
    public long getEndTime() {
        return endTime;
    }

    // Method to reset startTime to current time
    public void start() {
        startTime = System.currentTimeMillis();
    }

    // Method to set endTime to current time
    public void stop() {
        endTime = System.currentTimeMillis();
    }

    // Method to calculate elapsed time in milliseconds
    public long getElapsedTime() {
        return endTime - startTime;
    }
}

// Test program for measuring execution time of selection sort on 100,000 numbers
public class SelectionSortTest {
    public static void main(String[] args) {
        int[] numbers = generateRandomArray(100000);
        Stopwatch stopwatch = new Stopwatch();

        selectionSort(numbers);

        stopwatch.stop();

        System.out.println(""Execution time for sorting 100,000 numbers using selection sort: ""
                + stopwatch.getElapsedTime() + "" milliseconds"");
    }

    // Selection sort algorithm
    public static void selectionSort(int[] arr) {
        int n = arr.length;

        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    // Method to generate an array of random integers
    public static int[] generateRandomArray(int size) {
        int[] arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = (int) (Math.random() * 100000);
        }
        return arr;
    }
}",0.4046296296296296
0_StopWatch.java," /**
 * StopWatch.class
 */ /**
     * ■ A no-arg constructor that initializes startTime with the current time.
     */ /**
     * ■ A method named start() that resets the startTime to the current time.
     */ /**
     * ■ A method named stop() that sets the endTime to the current time.
     */ /**
     * ■ A method named getElapsedTime() that returns the elapsed time for the
     * stopwatch in milliseconds.
     */","package ch_09.exercise09_06;


//_________________________UML DIAGRAM______________________________*
/*																	|
 * 						   StopWatch								|
 *------------------------------------------------------------------|
 * 	-startTime : long			                                   	|
 * 															 		|
 *  -endTime : long			    									|
 *------------------------------------------------------------------|
 * 	 +StopWatch():                          						|
 * 	 																|
 * 	  start():void	                                                |
 * 						    					    				|
 * 	  stop():void						    						|
 *  																|
 * 	+getEndTime() : long					    					|
 * 																	|
 * 	+getStartTime() : long				`   						|
 * 																	|
 * 	+getElapsedTime() : long										|
 *__________________________________________________________________|  */

public class StopWatch {

    /* ■ Private data fields startTime and endTime with getter methods. */
    private long startTime;
    private long endTime;

    public long getStartTime() {
        return startTime;
    }

    public long getEndTime() {
        return endTime;
    }

    
    public StopWatch() {
        startTime = System.currentTimeMillis();
    }

    
    void start() {
        startTime = System.currentTimeMillis();
    }

    
    void stop() {
        endTime = System.currentTimeMillis();
    }

    
    public long getElapsedTime() {
        return (endTime - startTime);
    }


}
","public class StopWatch {
    private long startTime;
    private long endTime;

    public StopWatch() {
        startTime = System.currentTimeMillis();
    }

    public void start() {
        startTime = System.currentTimeMillis();
    }

    public void stop() {
        endTime = System.currentTimeMillis();
    }

    public long getElapsedTime() {
        return endTime - startTime;
    }
}",5,"// Stopwatch class to measure elapsed time in milliseconds
public class StopWatch {
    private long startTime; // Variable to hold start time
    private long endTime;   // Variable to hold end time

    // No-arg constructor initializes startTime with the current time
    public StopWatch() {
        startTime = System.currentTimeMillis(); // Set start time
    }

    // Method to reset startTime to the current time
    public void start() {
        startTime = System.currentTimeMillis(); // Reset start time
    }

    // Method to set endTime to the current time
    public void stop() {
        endTime = System.currentTimeMillis(); // Set end time
    }

    // Method to calculate elapsed time in milliseconds
    public long getElapsedTime() {
        return endTime - startTime; // Calculate and return elapsed time
    }
}",0.6141304347826086
0_Location.java," /**
 * **9.13 (The Location class) Design a class named Location for locating a maximal
 * value and its location in a two-dimensional array.
 * <p>
 * The class contains public data
 * fields row, column, and maxValue that store the maximal value and its indices
 * in a two-dimensional array with row and column as int types and maxValue as
 * a double type.
 * Write the following method that returns the location of the largest element in a
 * two-dimensional array:
 * public static Location locateLargest(double[][] a)
 * The return value is an instance of Location.
 */","package ch_09.exercise09_13;


public class Location {

    public double maxValue = Integer.MIN_VALUE;
    public int row;
    public int column;


    public static Location locateLargest(double[][] a) {
        Location location = new Location();
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                if (a[i][j] > location.maxValue) {
                    location.maxValue = a[i][j];
                    location.row = i;
                    location.column = j;
                }

            }
        }
        return location;
    }
}
","public class Location {
    public int row;
    public int column;
    public double maxValue;

    public Location(int row, int column, double maxValue) {
        this.row = row;
        this.column = column;
        this.maxValue = maxValue;
    }

    public static Location locateLargest(double[][] a) {
        int row = 0;
        int column = 0;
        double maxValue = a[0][0];

        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[i].length; j++) {
                if (a[i][j] > maxValue) {
                    row = i;
                    column = j;
                    maxValue = a[i][j];
                }
            }
        }

        return new Location(row, column, maxValue);
    }
}",5,"public class Location {
    public int row;
    public int column;
    public double maxValue;

    public Location(int row, int column, double maxValue) {
        this.row = row;
        this.column = column;
        this.maxValue = maxValue;
    }
}

public class MaxValueLocator {
    public static Location locateLargest(double[][] array) {
        int maxRow = 0;
        int maxColumn = 0;
        double maxVal = array[0][0];

        for (int i = 0; i < array.length; i++) {
            for (int j = 0; j < array[i].length; j++) {
                if (array[i][j] > maxVal) {
                    maxVal = array[i][j];
                    maxRow = i;
                    maxColumn = j;
                }
            }
        }

        return new Location(maxRow, maxColumn, maxVal);
    }

    public static void main(String[] args) {
        double[][] exampleArray = {
            {1.2, 3.4, 5.6},
            {7.8, 9.0, 10.1},
            {11.2, 13.4, 15.6}
        };

        Location maxLocation = locateLargest(exampleArray);

        System.out.println(""The maximum value is "" + maxLocation.maxValue +
                "" at position ("" + maxLocation.row + "", "" + maxLocation.column + "")"");
    }
}",0.6983050847457627
0_Exercise09_13.java," /**
 * <p>
 * Write a test program that prompts
 * the user to enter a two-dimensional array and displays the location of the largest
 * element in the array. Here is a sample run:
 * <p>
 * * Enter the number of rows and columns in the array: 3 4
 * * Enter the array:
 * * 23.5 35 2 10
 * * 4.5 3 45 3.5
 * * 35 44 5.5 9.6
 * * The location of the largest element is 45 at (1, 2)
 */","package ch_09.exercise09_13;

import java.util.Scanner;


public class Exercise09_13 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter the number of rows and columns in the array: "");

        int numRow = in.nextInt();
        int numCol = in.nextInt();
        double[][] numbers = new double[numRow][numCol];

        System.out.println(""Enter the array: "");

        for (int r = 0; r < numbers.length; r++) {
            for (int c = 0; c < numbers[r].length; c++) {
                numbers[r][c] = in.nextDouble();
            }
        }
        Location location = Location.locateLargest(numbers);

        System.out.printf(""The location of the largest element is: %.2f at (%d, %d)"", location.maxValue, location.row,
                location.column
        );


    }
}
","import java.util.Scanner;

public class ArrayTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter the number of rows and columns in the array
        System.out.print(""Enter the number of rows and columns in the array: "");
        int rows = input.nextInt();
        int cols = input.nextInt();

        // Create a two-dimensional array
        double[][] arr = new double[rows][cols];

        // Prompt the user to enter the array
        System.out.println(""Enter the array:"");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                arr[i][j] = input.nextDouble();
            }
        }

        // Find the location of the largest element in the array
        double max = arr[0][0];
        int maxRow = 0;
        int maxCol = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (arr[i][j] > max) {
                    max = arr[i][j];
                    maxRow = i;
                    maxCol = j;
                }
            }
        }

        // Display the location of the largest element in the array
        System.out.println(""The location of the largest element is "" + max +
                "" at ("" + maxRow + "", "" + maxCol + "")"");
    }
}",5,"import java.util.Scanner;

public class LargestElementFinder {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.println(""Please enter the number of rows and columns in the array: "");
        int rows = input.nextInt();
        int columns = input.nextInt();
        
        double[][] array = new double[rows][columns];
        
        System.out.println(""Please enter the array elements: "");
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                array[i][j] = input.nextDouble();
            }
        }
        
        int maxRow = 0;
        int maxColumn = 0;
        double maxElement = array[0][0];
        
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                if (array[i][j] > maxElement) {
                    maxElement = array[i][j];
                    maxRow = i;
                    maxColumn = j;
                }
            }
        }
        
        System.out.println(""The location of the largest element is "" + maxElement + "" at ("" + maxRow + "", "" + maxColumn + "")"");
        
        input.close();
    }
}",0.7831881086622245
0_Exercise07_22.java," /**
 * 7.22 (Find the number of uppercase letters in a string)
 * Write a program that passes a string to the command
 * line and displays the number uppercase of letters in the string.
 */","package ch_07;


public class Exercise07_22 {
    public static void main(String[] args) {

        int upperCase = 0;

        String str = args[0];

        for (int i = 0; i < str.length(); i++) {

            if (Character.isUpperCase(str.charAt(i))) {
                upperCase++;

            }
        }

        System.out.println(""The number of uppercase letters is "" + upperCase);

    }

}

","public class UppercaseLetters {
    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println(""Please enter a string as a command line argument."");
            return;
        }
        
        String str = args[0];
        int count = 0;
        
        for (int i = 0; i < str.length(); i++) {
            if (Character.isUpperCase(str.charAt(i))) {
                count++;
            }
        }
        
        System.out.println(""Number of uppercase letters in the string: "" + count);
    }
}",5,"public class UppercaseCounter {

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println(""Please provide a string as an argument."");
        } else {
            String inputString = args[0];
            int uppercaseCount = countUppercaseLetters(inputString);
            System.out.println(""The number of uppercase letters in the string is: "" + uppercaseCount);
        }
    }

    public static int countUppercaseLetters(String input) {
        int count = 0;
        for (int i = 0; i < input.length(); i++) {
            char currentChar = input.charAt(i);
            if (Character.isUpperCase(currentChar)) {
                count++;
            }
        }
        return count;
    }
}",0.6117179741807348
0_Exercise07_34.java," /**
 * **7.34 (Sort characters in a string) Write a method that returns a sorted string using the
 * following header:
 * public static String sort(String s)
 * For example, sort(""acb"") returns abc.
 * Write a test program that prompts the user to enter a string and displays the sorted
 * string.
 * The below solution to Exercise 7.34 a.k.a {@code Exercise07_34.class} implements, a classic bubble sort algorithm,
 * which is covered in Chapter 23. For more info, please see Listing 23.4 on page. 866 of the book.
 *
 * @author Harry D.
 */ /**
     * Bubble sort with loop control variable.
     *
     * @param s the String to sort
     * @return sorted in alphabetic ascending order
     */ /**
     * Swap the chars to make conform to ascending alphabetic order
     *
     * @return char[] with swapped chars at idx1 and idx2
     */","package ch_07;

import java.util.*;


public class Exercise07_34 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String str = in.nextLine().trim();

        System.out.print(""Sorted result -> "");
        System.out.print(sort(str));

        in.close();
    }

    
    public static String sort(String s) {
        char[] chars = s.toCharArray();
        boolean notSorted = true;
        for (int i = 1; i < chars.length && notSorted; i++) {
            notSorted = false; //Reset control variable
            for (int j = 0; j < chars.length - i; j++) {
                if (chars[j] > chars[j + 1]) {
                    chars = swap(j, j + 1, chars);
                    notSorted = true;
                }
            }
        }
        return Arrays.toString(chars);

    }

    
    static char[] swap(int idx1, int idx2, char[] arr) {
        char temp = arr[idx1];
        arr[idx1] = arr[idx2];
        arr[idx2] = temp;

        return arr;

    }
}","import java.util.Arrays;
import java.util.Scanner;

public class SortString {
    public static String sort(String s) {
        char[] chars = s.toCharArray();
        Arrays.sort(chars);
        return new String(chars);
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String s = input.nextLine();

        String sortedString = sort(s);
        System.out.println(""Sorted string: "" + sortedString);
    }
}",5,"import java.util.Scanner;

public class SortingCharacters {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string to sort: "");
        String userInput = input.nextLine();

        String sortedString = sort(userInput);
        System.out.println(""Sorted string: "" + sortedString);
    }

    public static String sort(String s) {
        char[] chars = s.toCharArray();
        int length = chars.length;

        for (int i = 0; i < length - 1; i++) {
            for (int j = 0; j < length - i - 1; j++) {
                if (chars[j] > chars[j + 1]) {
                    swap(chars, j, j + 1);
                }
            }
        }

        return new String(chars);
    }

    public static void swap(char[] array, int index1, int index2) {
        char temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;
    }
}",0.5024793388429752
0_Exercise07_14.java,"/*7.14 (Computing gcd) Write a method that returns the gcd of an * unspecified number of integers. The method header is specified as follows: * public static int gcd(int... numbers) * Write a test program that prompts the user to enter five numbers, * invokes the method to find the gcd of these numbers, and displays the gcd. */","package ch_07;

import java.util.Scanner;


public class Exercise07_14 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[] numsToFind = new int[5];
        System.out.println(""Please enter 5 numbers now to find their GCD:"");

        for (int i = 0; i < numsToFind.length; i++) {
            numsToFind[i] = input.nextInt();
        }

        System.out.println(""The GCD of these 5 integers is "" + gcd(numsToFind));
    }

    public static int gcd(int... numbers) {
        int minNum = numbers[0];
        for (int i = 1; i < numbers.length; i++) {
            if (numbers[i] < minNum) {
                minNum = numbers[i];
            }
        }

        int gcd = 1;
        boolean checkNum;

        for (int i = 2; i < minNum; i++) {
            checkNum = true;
            for (int j = 0; j < numbers.length; j++) {
                if (numbers[j] % i != 0)
                    checkNum = false;
            }
            if (checkNum) {
                gcd = i;
            }
        }
        return gcd;
    }
}

","public static int gcd(int... numbers) {
    int result = numbers[0];
    for (int i = 1; i < numbers.length; i++) {
        result = gcd(result, numbers[i]);
    }
    return result;
}

private static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }
    return gcd(b, a % b);
}",5,"import java.util.Scanner;

public class GCDCalculator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.println(""Enter five numbers: "");
        int[] numbers = new int[5];
        for (int i = 0; i < 5; i++) {
            System.out.print(""Enter number "" + (i + 1) + "": "");
            numbers[i] = scanner.nextInt();
        }
        
        int result = gcd(numbers);
        System.out.println(""The gcd of the numbers is: "" + result);
        
        scanner.close();
    }

    public static int gcd(int... numbers) {
        if (numbers.length == 0) {
            return 0; // No numbers, gcd is 0
        }

        int result = numbers[0];
        for (int i = 1; i < numbers.length; i++) {
            result = findGCD(result, numbers[i]);
        }
        return result;
    }

    public static int findGCD(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
}",0.4321796071094481
0_Exercise07_02.java," /**
 * 7.2 (Reverse the numbers entered) Write a program that
 * reads ten integers and displays them in the reverse
 * of the order in which they were read.
 */","package ch_07;

import java.util.Scanner;


public class Exercise07_02 {

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println(""Enter ten space-separated integers: "");

        int[] arr = new int[10];

        for (int i = 0; i < 10; i++) {
            arr[i] = input.nextInt();
        }

        displayReverse(arr);
        input.close();
    }

    private static void displayReverse(int[] arrRev) {
        for (int i = arrRev.length - 1; i >= 0; i--) {
            System.out.print(arrRev[i] + "" "");

        }
    }
}
","import java.util.Scanner;

public class ReverseNumbers {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int[] numbers = new int[10];

        System.out.println(""Enter ten integers:"");

        // Read ten integers from the user
        for (int i = 0; i < 10; i++) {
            numbers[i] = input.nextInt();
        }

        // Display the ten integers in reverse order
        System.out.print(""The numbers in reverse order are: "");
        for (int i = 9; i >= 0; i--) {
            System.out.print(numbers[i] + "" "");
        }
    }
}",5,"import java.util.Scanner;

public class ReverseNumbers {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[] numbers = new int[10];

        System.out.println(""Please enter ten integers:"");

        for (int i = 0; i < 10; i++) {
            System.out.print(""Enter integer "" + (i + 1) + "": "");
            numbers[i] = input.nextInt();
        }

        System.out.println(""\nNumbers in reverse order:"");

        for (int i = 9; i >= 0; i--) {
            System.out.println(numbers[i]);
        }

        input.close();
    }
}",0.8113590263691683
0_Exercise07_03.java," /**
 * *7.3 (Count occurrence of numbers) Write a program that reads the integers between 1
 * and 100 and counts the occurrences of each. Assume the input ends with 0.
 */","package ch_07;

import java.util.Scanner;


public class Exercise07_03 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int[] nums = new int[100];
        int temp;
        int count = 0;
        System.out.print(""Enter the integers between 1 and 100: "");
        do {
            temp = input.nextInt();
            nums[count] = temp;
            count++;
        }
        while (temp != 0);

        countOccurrences(nums);
    }

    public static void countOccurrences(int[] list) {
        for (int i = 1; i <= 100; i++) {
            int count = 0;
            for (int j = 0; j < list.length - 1; j++) {
                if (list[j] == i)
                    count += 1;
            }
            if (count != 0)
                System.out.printf(""%d occurs %d %s%n"",
                        i, count, count > 1 ? ""times"" : ""time"");
        }
    }
}
","import java.util.Scanner;

public class NumberCounter {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[] counts = new int[101]; // array to hold counts of each number

        // read integers from user until 0 is entered
        int number;
        do {
            System.out.print(""Enter an integer between 1 and 100 (0 to stop): "");
            number = input.nextInt();
            if (number >= 1 && number <= 100) {
                counts[number]++; // increment count for the entered number
            }
        } while (number != 0);

        // display the counts for each number
        for (int i = 1; i <= 100; i++) {
            if (counts[i] > 0) {
                System.out.println(i + "" occurs "" + counts[i] + "" times"");
            }
        }
    }
}
",5,"import java.util.Scanner;

public class NumberOccurrenceCounter {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int[] occurrences = new int[101]; // Array to store occurrences, index 0 is not used

        System.out.println(""Please enter integers between 1 and 100 (enter 0 to exit):"");

        int number = input.nextInt();
        while (number != 0) {
            if (number >= 1 && number <= 100) {
                occurrences[number]++; // Increment occurrence for the entered number
            } else {
                System.out.println(""Number out of range (1-100). Ignoring..."");
            }
            number = input.nextInt();
        }

        System.out.println(""Occurrences of each number:"");
        for (int i = 1; i <= 100; i++) {
            if (occurrences[i] != 0) {
                System.out.println(i + "" occurs "" + occurrences[i] + "" time(s)"");
            }
        }

        input.close();
    }
}",0.7557980900409277
0_Exercise21_06.java," /**
 * 21.6 (Count the occurrences of numbers entered) Write a program that reads an
 * unspecified number of integers and finds the one that has the most occurrences.
 * The input ends when the input is 0. For example, if you entered 2 3 40 3 5 4 –3
 * 3 3 2 0, the number 3 occurred most often. If not one but several numbers have
 * the most occurrences, all of them should be reported. For example, since 9 and 3
 * appear twice in the list 9 30 3 9 3 2 4, both occurrences should be reported.
 */","package ch_21;

import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;


public class Exercise21_06 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        Map<String, Integer> treeMap = new TreeMap<>();
        System.out.println(""Enter space seperated integers, ending with a '0': "");
        while (in.hasNext()) {
            String key = in.next().trim();
            if (key.length() > 0) {
                if (key.equals(""0"")) {
                    process(treeMap);
                    return;
                } else {
                    if (!treeMap.containsKey(key)) { // Map doesn't contain the key
                        treeMap.put(key, 1); // Add the key with initial count of 1
                    } else {
                        // Map does contain the key
                        int value = treeMap.get(key);
                        value++;
                        treeMap.put(key, value);
                    }
                }
            }
        }
    }//

    private static void process(Map<String, Integer> treeMap) {
        Set<Map.Entry<String, Integer>> entries = treeMap.entrySet();
        int max = 0;
        for (Map.Entry<String, Integer> entry : entries) {
            max = Math.max(entry.getValue(), max);
        }
        System.out.println(""The most occurring number(s): "");
        for (Map.Entry<String, Integer> entry : entries) {
            if (entry.getValue() == max) {
                System.out.println("""" + entry.getKey());
            }
        }
    }
}
","import java.util.*;

public class Occurrences {
    public static void main(String[] args) {
        // Initialize an empty map to keep track of the frequency of each number
        Map<Integer, Integer> numFreq = new HashMap<>();

        // Loop to read input numbers until 0 is entered
        Scanner input = new Scanner(System.in);
        int num;
        while (true) {
            System.out.print(""Enter an integer (0 to stop): "");
            num = input.nextInt();
            if (num == 0) {
                break;
            }

            // Update the frequency count of the number in the map
            if (numFreq.containsKey(num)) {
                numFreq.put(num, numFreq.get(num) + 1);
            } else {
                numFreq.put(num, 1);
            }
        }

        // Find the number(s) with the highest frequency
        int maxFreq = 0;
        List<Integer> mostFrequentNums = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : numFreq.entrySet()) {
            if (entry.getValue() > maxFreq) {
                maxFreq = entry.getValue();
                mostFrequentNums.clear();
                mostFrequentNums.add(entry.getKey());
            } else if (entry.getValue() == maxFreq) {
                mostFrequentNums.add(entry.getKey());
            }
        }

        // Print the result(s)
        System.out.print(""The most frequent number(s) is/are: "");
        for (int num : mostFrequentNums) {
            System.out.print(num + "" "");
        }
    }
}
",1,"import java.util.ArrayList;
import java.util.Scanner;

public class CountOccurrences {

    public static void main(String[] args) {
        Scanner inputScanner = new Scanner(System.in);

        ArrayList<Integer> numbers = new ArrayList<Integer>();
        ArrayList<Integer> mostFrequentNumbers = new ArrayList<Integer>();
        int maxOccurrences = 0;

        System.out.println(""Enter a list of integers (enter 0 to end):"");

        int num;
        while (true) {
            num = inputScanner.nextInt();
            if (num == 0) {
                break;
            }
            numbers.add(num);
        }

        inputScanner.close();

        for (int i = 0; i < numbers.size(); i++) {
            int currentNumber = numbers.get(i);
            int occurrences = 0;

            for (int j = 0; j < numbers.size(); j++) {
                if (currentNumber == numbers.get(j)) {
                    occurrences++;
                }
            }

            if (occurrences > maxOccurrences) {
                maxOccurrences = occurrences;
                mostFrequentNumbers.clear();
                mostFrequentNumbers.add(currentNumber);
            } else if (occurrences == maxOccurrences && !mostFrequentNumbers.contains(currentNumber)) {
                mostFrequentNumbers.add(currentNumber);
            }
        }

        System.out.print(""The most frequently occurring number(s) is/are: "");
        for (int number : mostFrequentNumbers) {
            System.out.print(number + "" "");
        }
    }
}
",0.5866780529461998
0_Exercise21_07.java," /**
 * **21.7 (Revise Listing 21.9, CountOccurrenceOfWords.java) Rewrite Listing 21.9 to
 * display the words in ascending order of occurrence counts.
 * (Hint: Create a class named WordOccurrence that implements the Comparable
 * interface. The class contains two fields, word and count. The compareTo
 * method compares the counts. For each pair in the hash set in Listing 21.9, create
 * an instance of WordOccurrence and store it in an array list. Sort the array list
 * using the Collections.sort method.
 * <p>
 * What would be wrong if you stored the instances of WordOccurrence in a tree set?
 * --------------------------------------------------------------------------------
 * Answer: The entries would not be sorted correctly in a TreeSet because
 * a TreeSet sorts based on natural ordering or according to the defined Comparator.
 * But this question asks us that WordOccurrence should implement the Comparable interface,
 * which would not affect the sort order of a TreeSet.
 */","package ch_21;

import java.util.*;


public class Exercise21_07 {
    public static void main(String[] args) {
        // Set text in a string
        String text = ""Good morning. Have a good class. "" +
                ""Have a good visit. Have fun!"";
        // Create a HashMap to hold words as key and count as value
        Map<String, Integer> map = new HashMap<>();
        TreeSet<String> set = new TreeSet<>();
        String[] words = text.split(""[ \n\t\r.,;:!?(){]"");
        for (int i = 0; i < words.length; i++) {
            String key = words[i].toLowerCase();
            if (key.length() > 0) {
                if (!map.containsKey(key)) {
                    map.put(key, 1);
                } else {
                    int value = map.get(key);
                    value++;
                    map.put(key, value);
                }
            }
        }

        ArrayList<WordOccurrence> wordOccurrences = new ArrayList<>();
        // Get all entries into a set
        Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
        // Get key and value from each entry
        for (Map.Entry<String, Integer> entry : entrySet) {
            wordOccurrences.add(new WordOccurrence(entry.getKey(), entry.getValue()));
        }
        Collections.sort(wordOccurrences);
        for (WordOccurrence wordOccurrence : wordOccurrences) {
            System.out.println(wordOccurrence);
        }
    }
}

class WordOccurrence implements Comparable<WordOccurrence> {
    String word;
    int count;

    public WordOccurrence(String word, int count) {
        this.word = word;
        this.count = count;
    }

    @Override
    public int compareTo(WordOccurrence that) {
        return Integer.compare(this.count, that.count);
    }

    @Override
    public String toString() {
        return ""WordOccurrence{"" +
                ""word='"" + word + '\'' +
                "", count="" + count +
                '}';
    }
}

","import java.util.*;

public class CountOccurrenceOfWords {
    public static void main(String[] args) {
        // Set text in a string
        String text = ""Good morning. Have a good class. "" +
                ""Have a good visit. Have fun!"";

        // Create a TreeMap to hold words as key and count as value
        Map<String, Integer> map = new TreeMap<>();

        String[] words = text.split(""[\\s+\\p{P}]"");
        for (String word : words) {
            String key = word.toLowerCase();

            if (key.length() > 0) {
                if (!map.containsKey(key)) {
                    map.put(key, 1);
                } else {
                    int value = map.get(key);
                    value++;
                    map.put(key, value);
                }
            }
        }

        // Create an array list from the entries in the map
        List<WordOccurrence> list = new ArrayList<>();
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            list.add(new WordOccurrence(entry.getKey(), entry.getValue()));
        }

        // Sort the list
        Collections.sort(list);

        // Display the words in ascending order of occurrence counts
        for (WordOccurrence wo : list) {
            System.out.println(wo.getWord() + "" "" + wo.getCount());
        }
    }
}

class WordOccurrence implements Comparable<WordOccurrence> {
    private String word;
    private int count;

    public WordOccurrence(String word, int count) {
        this.word = word;
        this.count = count;
    }

    public String getWord() {
        return word;
    }

    public int getCount() {
        return count;
    }

    @Override
    public int compareTo(WordOccurrence o) {
        if (count > o.count) {
            return 1;
        } else if (count < o.count) {
            return -1;
        } else {
            return 0;
        }
    }
}
",1,"import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class CountWords {

    public static void main(String[] args) throws Exception {
        // Create a Scanner object to read from the text file
        File file = new File(""text.txt"");
        Scanner inputScanner = new Scanner(file);

        // Create an ArrayList to store WordOccurrence objects
        ArrayList<WordOccurrence> wordOccurrences = new ArrayList<WordOccurrence>();

        // Read words from the file and count their occurrences
        while (inputScanner.hasNext()) {
            String word = inputScanner.next().toLowerCase();
            // Remove punctuation marks (imperfection here, we don't handle all punctuation)
            word = word.replaceAll(""[.,!?()]"", """");

            // Check if the word is already in the list of wordOccurrences
            boolean found = false;
            for (WordOccurrence wordOccurrence : wordOccurrences) {
                if (wordOccurrence.getWord().equals(word)) {
                    wordOccurrence.incrementCount();
                    found = true;
                    break;
                }
            }

            // If the word is not found, add it to the list
            if (!found) {
                wordOccurrences.add(new WordOccurrence(word, 1));
            }
        }

        // Sort the wordOccurrences list in ascending order of occurrence counts
        Collections.sort(wordOccurrences);

        // Display the words and their occurrence counts
        for (WordOccurrence wordOccurrence : wordOccurrences) {
            System.out.println(wordOccurrence.getWord() + "": "" + wordOccurrence.getCount());
        }

        // Close the scanner
        inputScanner.close();
    }
}

class WordOccurrence implements Comparable<WordOccurrence> {
    private String word;
    private int count;

    public WordOccurrence(String word, int count) {
        this.word = word;
        this.count = count;
    }

    public String getWord() {
        return word;
    }

    public int getCount() {
        return count;
    }

    public void incrementCount() {
        count++;
    }

    @Override
    public int compareTo(WordOccurrence other) {
        // Compare WordOccurrence objects based on occurrence counts
        return Integer.compare(this.count, other.count);
    }
}
",0.5771812080536913
0_Exercise21_01.java," /**
 * 21.1 (Perform set operations on hash sets) Create two linked hash sets {""George"",
 * ""Jim"", ""John"", ""Blake"", ""Kevin"", ""Michael""} and {""George"", ""Katie"",
 * ""Kevin"", ""Michelle"", ""Ryan""} and find their union, difference, and intersection.
 * (You can clone the sets to preserve the original sets from being changed by
 * these set methods.)
 *
 */","package ch_21;

import java.util.*;


public class Exercise21_01 {
    public static void main(String[] args) {

        LinkedHashSet<String> names1 = new LinkedHashSet<>(); // Creates a LinkedHashSet object with a default capacity
        // of 16
        LinkedHashSet<String> names2 = new LinkedHashSet<>(); // and default load factor of 0.75

        names1.add(""George"");
        names1.add(""Jim"");
        names1.add(""John"");
        names1.add(""Blake"");
        names1.add(""Kevin"");
        names1.add(""Michael"");

        names2.add(""George"");
        names2.add(""Katie"");
        names2.add(""Kevin"");
        names2.add(""Michelle"");
        names2.add(""Ryan"");

        LinkedHashSet<String> lhs1 = new LinkedHashSet<>();
        lhs1.addAll(names1);

        LinkedHashSet<String> lhs2 = new LinkedHashSet<>();
        lhs2.addAll(names2);

        // The union is a combination of all unique values from both sets
        names1.addAll(names2);
        System.out.println(""Union is: "" + names1);

        // The intersection is only the values occur in both sets
        LinkedHashSet<String> copyNames1 = new LinkedHashSet<String>(lhs1);
        copyNames1.retainAll(names2);
        System.out.println(""Intersection is: "" + copyNames1);

        // The difference is the union excluding common values
        names1.removeAll(copyNames1);
        System.out.println(""Difference is: "" + names1);


    }

}
","import java.util.LinkedHashSet;
import java.util.Set;

public class SetOperations {
    public static void main(String[] args) {
        // Create the first linked hash set
        Set<String> set1 = new LinkedHashSet<>();
        set1.add(""George"");
        set1.add(""Jim"");
        set1.add(""John"");
        set1.add(""Blake"");
        set1.add(""Kevin"");
        set1.add(""Michael"");

        // Create the second linked hash set
        Set<String> set2 = new LinkedHashSet<>();
        set2.add(""George"");
        set2.add(""Katie"");
        set2.add(""Kevin"");
        set2.add(""Michelle"");
        set2.add(""Ryan"");

        // Find the union of the two sets
        Set<String> union = new LinkedHashSet<>(set1);
        union.addAll(set2);
        System.out.println(""Union: "" + union);

        // Find the difference of the two sets (elements in set1 but not in set2)
        Set<String> difference = new LinkedHashSet<>(set1);
        difference.removeAll(set2);
        System.out.println(""Difference: "" + difference);

        // Find the intersection of the two sets
        Set<String> intersection = new LinkedHashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println(""Intersection: "" + intersection);
    }
}
",1,"import java.util.LinkedHashSet;

public class SetOperations {

    public static void main(String[] args) {
        // Create the first linked hash set
        LinkedHashSet<String> set1 = new LinkedHashSet<>();
        set1.add(""George"");
        set1.add(""Jim"");
        set1.add(""John"");
        set1.add(""Blake"");
        set1.add(""Kevin"");
        set1.add(""Michael"");

        // Create the second linked hash set
        LinkedHashSet<String> set2 = new LinkedHashSet<>();
        set2.add(""George"");
        set2.add(""Katie"");
        set2.add(""Kevin"");
        set2.add(""Michelle"");
        set2.add(""Ryan"");

        // Clone the sets to preserve the original sets
        LinkedHashSet<String> set1Clone = new LinkedHashSet<>(set1);
        LinkedHashSet<String> set2Clone = new LinkedHashSet<>(set2);

        // Calculate and display the union of the sets
        set1Clone.addAll(set2Clone);
        System.out.println(""Union of the sets: "" + set1Clone);

        // Restore the cloned sets
        set1Clone = new LinkedHashSet<>(set1);
        set2Clone = new LinkedHashSet<>(set2);

        // Calculate and display the difference between set1 and set2
        set1Clone.removeAll(set2Clone);
        System.out.println(""Difference (set1 - set2): "" + set1Clone);

        // Restore the cloned sets
        set1Clone = new LinkedHashSet<>(set1);
        set2Clone = new LinkedHashSet<>(set2);

        // Calculate and display the intersection of the sets
        set1Clone.retainAll(set2Clone);
        System.out.println(""Intersection of the sets: "" + set1Clone);
    }
}
",0.7531172069825436
0_Exercise21_08.java," /**
 * **21.8 (Count the occurrences of words in a text file) Rewrite Listing 21.9 to read the
 * text from a text file. The text file is passed as a command-line argument. Words
 * are delimited by whitespace characters, punctuation marks (,;.:?), quotation
 * marks ('""), and parentheses. Count words in case-insensitive fashion (e.g., consider Good and good to be the same word).
 * The words must start with a letter.
 * Display the output in alphabetical order of words, with each word preceded by
 * its occurrence count.
 */","package ch_21.exercise21_08;

import java.io.File;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;


public class Exercise21_08 {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(
                    ""Usage: java Exercise21_08 ch_21/exercise21_08/test.txt"");
            System.exit(1);
        }

        String filePath = args[0];
        TreeMap<String, Integer> treeMap = new TreeMap<String, Integer>();

        try {
            File file = new File(filePath);
            if (!file.exists() || !file.isFile()) {
                System.out.println(""Error: "" + file.getCanonicalPath() + "" does not exist or is not a file."");
                System.exit(2);
            }

            Scanner input = new Scanner(file);

            while (input.hasNext()) {
                String line = input.nextLine();
                // Split input file contents by delimiters
                String[] words = line.split(""[ @!~{}\\[\\]$#^&*\n\t\r.,;?'\"")(]"");

                for (int i = 0; i < words.length; i++) {
                    // Check for uppercase letters in words and make them lowercase (case-insensitive)
                    if (words[i].trim().length() > 0 && words[i].trim().matches(""[A-Z|a-z]+"")) {
                        String key = words[i].toLowerCase();
                        if (treeMap.get(key) != null) {
                            int count = treeMap.get(key);
                            count++;
                            treeMap.put(key, count);
                        } else {
                            treeMap.put(key, 1);
                        }
                    }
                }
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        // Get an entry set for the tree map
        Set<Map.Entry<String, Integer>> entrySet = treeMap.entrySet();

        // Display words in alphabetical order
        System.out.println(""\nDisplay the output in alphabetical order of words, with each word preceded by\n"" +
                ""its occurrence count"");
        for (Map.Entry<String, Integer> entry : entrySet)
            System.out.println(entry.getValue() + ""\t"" + entry.getKey());
    }
}


","import java.io.File;
import java.io.FileNotFoundException;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class WordCounter {

    public static void main(String[] args) {
        if (args.length == 0) {
            System.out.println(""Usage: java WordCounter filename"");
            System.exit(1);
        }

        String fileName = args[0];
        File file = new File(fileName);
        if (!file.exists()) {
            System.out.println(""File not found: "" + fileName);
            System.exit(1);
        }

        Map<String, Integer> wordCounts = new HashMap<>();
        try (Scanner input = new Scanner(file)) {
            while (input.hasNext()) {
                String line = input.nextLine();
                String[] words = line.split(""[\\s\\p{Punct}&&[^']&&[^-]]+"");
                for (String word : words) {
                    if (word.matches(""[a-zA-Z]+.*"")) {
                        String lowercaseWord = word.toLowerCase();
                        wordCounts.put(lowercaseWord, wordCounts.getOrDefault(lowercaseWord, 0) + 1);
                    }
                }
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        Object[] keys = wordCounts.keySet().toArray();
        Arrays.sort(keys, Comparator.comparing(String::toLowerCase));

        for (Object key : keys) {
            System.out.printf(""%-15s%3d%n"", key, wordCounts.get(key));
        }
    }

}
",1,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

public class WordCounter {

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java WordCounter <filename>"");
            return;
        }

        String filename = args[0];
        Map<String, Integer> wordCounts = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Split the line into words using various delimiters
                String[] words = line.split(""[ ,;.:?'\"")(]"");

                for (String word : words) {
                    // Remove leading and trailing whitespace, and convert to lowercase
                    word = word.trim().toLowerCase();

                    // Check if the word starts with a letter
                    if (word.length() > 0 && Character.isLetter(word.charAt(0))) {
                        // Update the word count in the map
                        wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
                    }
                }
            }
        } catch (IOException e) {
            System.err.println(""Error reading the file: "" + e.getMessage());
            return;
        }

        // Sort the wordCounts map by keys (words)
        Map<String, Integer> sortedWordCounts = new TreeMap<>(wordCounts);

        // Display the word counts in alphabetical order
        for (Map.Entry<String, Integer> entry : sortedWordCounts.entrySet()) {
            System.out.println(entry.getKey() + "": "" + entry.getValue());
        }
    }
}
",0.5931879066207424
0_Exercise21_05.java," /**
 * **21.5 (Syntax highlighting) Write a program that converts a Java file into an HTML
 * file. In the HTML file, the keywords, comments, and literals are displayed in
 * bold navy, green, and blue, respectively. Use the command line to pass a Java file
 * and an HTML file. For example, the following command
 * java Exercise21_05 Welcome.java Welcome.html
 * converts Welcome.java into Welcome.html. Figure 21.8a shows a Java file. The
 * corresponding HTML file is shown in Figure 21.8b.
 */","package ch_21.exercise21_05;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.*;


public class Exercise21_05 {
    private static final String KEYWORD = ""keyword_style_class"";
    private static final String COMMENT = ""comment_style_class"";
    private static final String LITERAL = ""literals_style_class"";

    private static final String CSS_STYLE = ""div{display: inline-block}"" +
            "".none{font-weight: normal;color:black;}"" +
            "" .keyword_style_class {font-weight: bold;color: navy;}"" +
            "" .comment_style_class {font-weight: bold; color: green;}"" +
            "" .literals_style_class {font-weight: bold; color: blue;}"";

    private static final String[] KEY_WORDS = {""abstract"", ""assert"", ""boolean"",
            ""break"", ""byte"", ""case"", ""catch"", ""char"", ""class"", ""const"",
            ""continue"", ""default"", ""do"", ""double"", ""else"", ""enum"",
            ""extends"", ""for"", ""final"", ""finally"", ""float"", ""goto"",
            ""if"", ""implements"", ""import"", ""instanceof"", ""int"",
            ""interface"", ""long"", ""native"", ""new"", ""package"", ""private"",
            ""protected"", ""public"", ""return"", ""short"", ""static"",
            ""strictfp"", ""super"", ""switch"", ""synchronized"", ""this"",
            ""throw"", ""throws"", ""transient"", ""try"", ""void"", ""volatile"",
            ""while"", ""true"", ""false"", ""null""};

    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println(""Usage: java Exercise21_05 Welcome.java Welcome.html"");
            System.exit(1);
        }

        String inputFile = args[0];
        String outputFile = args[1];
        System.out.println(""Reading file: "" + inputFile);

        try {
            List<String> txtLines = Files.readAllLines(Paths.get(inputFile));
            System.out.println(""Reading complete.\nMapping input file to HTML file..."");

            ArrayList<String> htmlFileLines = mapTextToHtml(txtLines);

            System.out.println(""Mapping complete..."");
            System.out.println(""Writing output file: "" + outputFile);

            Files.write(Paths.get(outputFile), htmlFileLines, StandardOpenOption.CREATE);
            System.out.println(""Writing output file complete."");

        } catch (IOException e) {
            System.out.println(""Something went wrong during read/convert/write..."");
            e.printStackTrace();
        }
    }

    private static ArrayList<String> mapTextToHtml(List<String> txtFileLines) {
        ArrayList<String> htmlLines = new ArrayList<>();
        htmlLines.add(""<html lang=\""en\"">"");
        htmlLines.add(""<head>"");
        htmlLines.add(""<style>"");
        htmlLines.add(CSS_STYLE);
        htmlLines.add(""</style>"");
        htmlLines.add(""<title>"" + Exercise21_05.class.getName() + ""</title>"");
        htmlLines.add(""</head>"");
        htmlLines.add(""<body>"");

        Set<String> keywordSet = new HashSet<>(Arrays.asList(KEY_WORDS));
        // Iterate lines
        for (String txtFileLine : txtFileLines) {
            StringBuilder lineBuilder = new StringBuilder();
            lineBuilder.append(""<div>""); // Start of line
            String[] words = txtFileLine.split("" ""); // Split the line by whitespace
            // Iterate words (character groups seperated by whitespace)
            for (int idx = 0; idx < words.length; idx++) {
                if (words[idx].startsWith(""//"")) { // Beginning of a line comment rest of line must be Comment class
                    lineBuilder.append(""<div class=\"""" + COMMENT + ""\"">""); // Start of comment html tag
                    while (idx < words.length) { // Fill remaining words in line with Comment class
                        lineBuilder.append(words[idx]).append(""&nbsp;"");
                        idx++;
                    }
                    lineBuilder.append(""</div>""); // End of comment line, close tag
                    continue;
                }

                if (keywordSet.contains(words[idx])) {
                    lineBuilder.append(""<div class=\"""" + KEYWORD + ""\"">""); // Start of keyword html tag
                    lineBuilder.append(words[idx]).append(""&nbsp;"");
                    lineBuilder.append("" </div>""); // Close tag
                    continue;
                }

                if (words[idx].startsWith(""\"""")) {
                    lineBuilder.append(""<div class=\"""" + LITERAL + ""\"">""); // Start of literal html tag
                    while (!words[idx].endsWith(""\"""")) { // Iterate rest of string literal
                        lineBuilder.append(words[idx]).append(""&nbsp;"");
                        idx++;
                    }
                    lineBuilder.append(words[idx]).append(""&nbsp;"");
                    lineBuilder.append(""</div>""); // Close literal tag
                    continue;
                }
                if (words[idx].isEmpty()) {
                    lineBuilder.append(""&nbsp;"");
                } else {
                    // word is not Comment or Keyword or Literal so Map to the default style class
                    lineBuilder.append(words[idx]).append(""&nbsp;"");
                }
            }
            htmlLines.add(lineBuilder + ""</div><br>"");
        }
        htmlLines.add(""</body>"");
        htmlLines.add(""</html>"");

        return htmlLines;
    }
}
","import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class SyntaxHighlighter {
    private static final Set<String> KEYWORDS = new HashSet<>(Arrays.asList(
            ""abstract"", ""assert"", ""boolean"", ""break"", ""byte"", ""case"", ""catch"",
            ""char"", ""class"", ""const"", ""continue"", ""default"", ""do"", ""double"",
            ""else"", ""enum"", ""extends"", ""false"", ""final"", ""finally"", ""float"",
            ""for"", ""goto"", ""if"", ""implements"", ""import"", ""instanceof"", ""int"",
            ""interface"", ""long"", ""native"", ""new"", ""null"", ""package"", ""private"",
            ""protected"", ""public"", ""return"", ""short"", ""static"", ""strictfp"",
            ""super"", ""switch"", ""synchronized"", ""this"", ""throw"", ""throws"",
            ""transient"", ""true"", ""try"", ""void"", ""volatile"", ""while""
    ));

    public static void main(String[] args) throws IOException {
        if (args.length != 2) {
            System.err.println(""Usage: java SyntaxHighlighter input.java output.html"");
            System.exit(1);
        }
        String inputFilename = args[0];
        String outputFilename = args[1];

        try (BufferedReader reader = new BufferedReader(new FileReader(inputFilename));
             BufferedWriter writer = new BufferedWriter(new FileWriter(outputFilename))) {
            writer.write(""<html><body><pre>"");

            String line;
            while ((line = reader.readLine()) != null) {
                line = line.replace(""&"", ""&amp;"")
                           .replace(""<"", ""&lt;"")
                           .replace("">"", ""&gt;"");

                String[] words = line.split(""\\s+|(?=[{}(),;])|(?<=[{}(),;])"");
                for (String word : words) {
                    if (KEYWORDS.contains(word)) {
                        writer.write(""<b style=\""color:navy\"">"" + word + ""</b>"");
                    } else if (word.startsWith(""\"""") && word.endsWith(""\"""")) {
                        writer.write(""<b style=\""color:blue\"">"" + word + ""</b>"");
                    } else if (word.startsWith(""//"") || word.startsWith(""/*"")) {
                        writer.write(""<b style=\""color:green\"">"" + word + ""</b>"");
                    } else {
                        writer.write(word);
                    }
                }
                writer.newLine();
            }

            writer.write(""</pre></body></html>"");
        }
    }
}
",1,"import java.io.*;
import java.util.Scanner;

public class JavaToHtmlConverter {

    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println(""Usage: java JavaToHtmlConverter input.java output.html"");
            return;
        }

        String inputFile = args[0];
        String outputFile = args[1];

        try {
            BufferedReader reader = new BufferedReader(new FileReader(inputFile));
            PrintWriter writer = new PrintWriter(new FileWriter(outputFile));

            writer.println(""<html>"");
            writer.println(""<head>"");
            writer.println(""<title>Java to HTML Converter</title>"");
            writer.println(""</head>"");
            writer.println(""<body>"");

            String line;
            boolean inComment = false;

            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.startsWith(""/*"")) {
                    inComment = true;
                    writer.println(""<span style=\""color:green;font-weight:bold;\"">"");
                }
                if (inComment) {
                    writer.println(line);
                } else {
                    String[] tokens = line.split(""\\s+""); // Split by whitespace
                    for (String token : tokens) {
                        if (isKeyword(token)) {
                            writer.print(""<span style=\""color:navy;font-weight:bold;\"">"");
                        } else if (isLiteral(token)) {
                            writer.print(""<span style=\""color:blue;font-weight:bold;\"">"");
                        }
                        writer.print(token);
                        if (isKeyword(token) || isLiteral(token)) {
                            writer.print(""</span>"");
                        }
                        writer.print("" "");
                    }
                    writer.println();
                }
                if (line.endsWith(""*/"")) {
                    inComment = false;
                    writer.println(""</span>"");
                }
            }

            writer.println(""</body>"");
            writer.println(""</html>"");

            reader.close();
            writer.close();

            System.out.println(""Conversion complete. Check "" + outputFile + "" for the HTML output."");
        } catch (IOException e) {
            System.err.println(""An error occurred: "" + e.getMessage());
        }
    }

    private static boolean isKeyword(String token) {
        // Add Java keywords here
        String[] keywords = {""public"", ""class"", ""if"", ""else"", ""while"", ""for"", ""return""};
        for (String keyword : keywords) {
            if (token.equals(keyword)) {
                return true;
            }
        }
        return false;
    }

    private static boolean isLiteral(String token) {
        // Check if it's a number (integer or floating-point)
        return token.matches(""[0-9]+(\\.[0-9]+)?"");
    }
}
",0.43909626719056977
0_Exercise17_17.java," /**
 * *17.17 {@link ch_17.exercise17_17.BitOutputStream } Implement a class named BitOutputStream, as shown
 * in Figure 17.22, for writing bits to an output stream. The writeBit(char bit)
 * method stores the bit in a byte variable. When you create a BitOutputStream,
 * the byte is empty. After invoking writeBit('1'), the byte becomes 00000001.
 * After invoking writeBit(""0101""), the byte becomes 00010101. The first
 * three bits are not filled yet. When a byte is full, it is sent to the output stream. Now
 * the byte is reset to empty. You must close the stream by invoking the close()
 * method.
 * <p>
 * If the byte is neither empty nor full, the close() method first fills the
 * zeros to make a full 8 bits in the byte, and then outputs the byte and closes the
 * stream.
 * <p>
 * For a hint, see Programming Exercise: {@link ch_05.Exercise05_44}
 * <p>
 *
 * <p>
 * Write a test program that
 * sends the bits 010000100100001001101 to the file named Exercise17_17.dat.
 */","package ch_17.exercise17_17;


import java.io.File;
import java.io.IOException;


public class Exercise17_17 {
    public static void main(String[] args) {
        File testFile = new File(""ch_17/exercise17_17"", ""Exercise17_17.dat"");
        try {
            BitOutputStream bitOutputStream = new BitOutputStream(testFile);
            bitOutputStream.writeBit(""010000100100001001101"");
            bitOutputStream.close();
        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
    }

}","import java.io.*;

public class BitOutputStream extends FilterOutputStream {
    private int buffer; // 8-bit buffer for storing bits
    private int numBitsInBuffer; // number of bits in the buffer

    public BitOutputStream(OutputStream out) {
        super(out);
        buffer = 0;
        numBitsInBuffer = 0;
    }

    public void writeBit(char bit) throws IOException {
        if (bit != '0' && bit != '1') {
            throw new IllegalArgumentException(""Argument must be '0' or '1'"");
        }
        buffer <<= 1;
        buffer |= (bit - '0');
        numBitsInBuffer++;
        if (numBitsInBuffer == 8) {
            flush();
        }
    }

    public void writeBit(String bitString) throws IOException {
        for (int i = 0; i < bitString.length(); i++) {
            writeBit(bitString.charAt(i));
        }
    }

    public void close() throws IOException {
        if (numBitsInBuffer > 0) {
            buffer <<= (8 - numBitsInBuffer);
            out.write(buffer);
        }
        super.close();
    }

    public void flush() throws IOException {
        if (numBitsInBuffer > 0) {
            buffer <<= (8 - numBitsInBuffer);
            out.write(buffer);
            buffer = 0;
            numBitsInBuffer = 0;
        }
    }
}
public class TestBitOutputStream {
    public static void main(String[] args) throws IOException {
        BitOutputStream out = new BitOutputStream(new FileOutputStream(""Exercise17_17.dat""));
        out.writeBit(""01000010"");
        out.writeBit(""01000010"");
        out.writeBit(""01001011"");
        out.writeBit(""00001101"");
        out.close();
    }
}
",1,"import java.io.*;

public class BitOutputStream {
    private FileOutputStream output;
    private int currentByte;
    private int bitCount;

    public BitOutputStream(String fileName) throws IOException {
        output = new FileOutputStream(fileName);
        currentByte = 0;
        bitCount = 0;
    }

    public void writeBit(char bit) throws IOException {
        if (bit != '0' && bit != '1') {
            System.out.println(""Invalid bit: "" + bit);
            return;
        }

        currentByte = (currentByte << 1) | (bit - '0');
        bitCount++;

        if (bitCount == 8) {
            output.write(currentByte);
            currentByte = 0;
            bitCount = 0;
        }
    }

    public void writeBit(String bits) throws IOException {
        for (char bit : bits.toCharArray()) {
            writeBit(bit);
        }
    }

    public void close() throws IOException {
        if (bitCount > 0) {
            currentByte <<= (8 - bitCount);
            output.write(currentByte);
        }

        output.close();
    }
}

public class BitOutputStreamTest {
    public static void main(String[] args) {
        try {
            BitOutputStream outStream = new BitOutputStream(""Exercise17_17.dat"");

            String bitsToSend = ""010000100100001001101"";
            for (char bit : bitsToSend.toCharArray()) {
                outStream.writeBit(bit);
            }

            outStream.close();
            System.out.println(""Bits written to file successfully."");
        } catch (IOException e) {
            System.err.println(""Error: "" + e.getMessage());
        }
    }
}
",0.6016884113584037
0_BitOutputStream.java," /**
 * (BitOutputStream) Implement a class named BitOutputStream, as shown
 * in Figure 17.22, for writing bits to an output stream. The writeBit(char bit)
 * method stores the bit in a byte variable. When you create a BitOutputStream,
 * the byte is empty. After invoking writeBit('1'), the byte becomes 00000001.
 * After invoking writeBit(""0101""), the byte becomes 00010101. The first
 * three bits are not filled yet. When a byte is full, it is sent to the output stream. Now
 * the byte is reset to empty. You must close the stream by invoking the close()
 * method.
 * <p>
 * If the byte is neither empty nor full, the close() method first fills the
 * zeros to make a full 8 bits in the byte, and then outputs the byte and closes the
 * stream.
 * <p>
 * For a hint, see Programming Exercise 5.44.
 * <p>
 * * [BitOutputStream]
 * * ***************************************************************************************
 * * +BitOutputStream(file: File) ---- Creates a BitOutputStream to writes bits to the file.
 * * +writeBit(char bit): void ------ Writes a bit '0' or '1' to the output stream.
 * * +writeBit(String bit): void ----- Writes a string of bits to the output stream.
 * * +close(): void ----- This method must be invoked to close the stream.
 * * ***************************************************************************************
 * * FIGURE 17.22 BitOutputStream outputs a stream of bits to a file.
 */","package ch_17.exercise17_17;

import java.io.*;


public class BitOutputStream implements Closeable {
    private int value;
    private FileOutputStream fileOutputStream;
    private int posCounter = 0;
    private File file;

    public BitOutputStream(File file) throws FileNotFoundException {
        this.file = file;
        fileOutputStream = new FileOutputStream(file);
    }

    public void writeBit(char bit) {
        if (isValid(bit)) {
            posCounter++;
            value = value << 1; // Shift over bit values to left by one. For Example: (00001111 << 1) = 00011110
            if (bit == '1') { // If bit is '1' perform logic to change right-most 0 to 1
                value = value | 1; // Use bit masking to turn the last bit on.
            }
            // Check if value is full (when posCounter is 8), if so, write to file and reset aByte
            if (posCounter == 8) { // value is full (Bit at position 8 is always 0 (non-negative))
                try {
                    System.out.println(""Byte value is full, writing to FileOutputStream: "" + Integer.toBinaryString(value));
                    fileOutputStream.write(value); // Write to OutputStream
                    posCounter = 0; // Reset capacity counter to zero
                    value = 0;
                } catch (IOException ioException) {
                    System.out.println(""Error: internal fileOutputStream through exception. Please check you are using "" +
                            ""correct 'file' parameter."");
                    ioException.printStackTrace();
                }
            }

            // Print the value result formatted as a String for clarity
//            System.out.println(""bit is "" + bit + "" -> value is "" + Integer.toBinaryString(aByte));
        } else {
            throw new IllegalArgumentException(""writeBit method only excepts char parameters of '0' or '1' "");
        }
    }

    private boolean isValid(char bit) {
        return bit == '0' ||
                bit == '1' ||
                bit == '\n' ||
                bit == '\t';
    }

    public void writeBit(String bit) {
        for (int i = 0; i < bit.length(); i++) {
            writeBit(bit.charAt(i));
        }
    }

    @Override
    public void close() throws IOException {
        if (posCounter > 0) {
            int shift = 8 - posCounter;
            value = value << shift;
            fileOutputStream.write(value);
            System.out.println(""Filling rest of the byte value with zeros and writing to FileOutputStream:  "" + Integer.toBinaryString(value));
        }
        fileOutputStream.close();
    }

}
","import java.io.*;

public class BitOutputStream extends FilterOutputStream {
    private int buffer; // 8-bit buffer for storing bits
    private int numBitsInBuffer; // number of bits in the buffer

    public BitOutputStream(File file) throws FileNotFoundException {
        super(new FileOutputStream(file));
        buffer = 0;
        numBitsInBuffer = 0;
    }

    public void writeBit(char bit) throws IOException {
        if (bit != '0' && bit != '1') {
            throw new IllegalArgumentException(""Invalid bit value: "" + bit);
        }
        buffer = (buffer << 1) | (bit - '0');
        numBitsInBuffer++;
        if (numBitsInBuffer == 8) {
            flush();
        }
    }

    public void writeBit(String bit) throws IOException {
        for (int i = 0; i < bit.length(); i++) {
            writeBit(bit.charAt(i));
        }
    }

    public void close() throws IOException {
        if (numBitsInBuffer > 0 && numBitsInBuffer < 8) {
            buffer <<= (8 - numBitsInBuffer); // fill buffer with zeros
            out.write(buffer);
        }
        super.close();
    }

    public void flush() throws IOException {
        if (numBitsInBuffer > 0) {
            out.write(buffer);
            buffer = 0;
            numBitsInBuffer = 0;
        }
    }
}
",1,"import java.io.*;

public class BitOutputStream {
    private FileOutputStream outputStream;
    private int currentByte;
    private int bitCount;

    public BitOutputStream(File file) throws IOException {
        this.outputStream = new FileOutputStream(file);
        this.currentByte = 0;
        this.bitCount = 0;
    }

    public void writeBit(char bit) throws IOException {
        if (bit != '0' && bit != '1') {
            throw new IllegalArgumentException(""Invalid bit: "" + bit);
        }

        currentByte = (currentByte << 1) | (bit - '0');
        bitCount++;

        if (bitCount == 8) {
            outputStream.write(currentByte);
            currentByte = 0;
            bitCount = 0;
        }
    }

    public void writeBit(String bit) throws IOException {
        for (int i = 0; i < bit.length(); i++) {
            writeBit(bit.charAt(i));
        }
    }

    public void close() throws IOException {
        if (bitCount > 0) {
            currentByte <<= (8 - bitCount);
            outputStream.write(currentByte);
        }
        outputStream.close();
    }
}
",0.7026194144838213
0_Exercise17_10.java," /**
 * *17.10 (Split files) Suppose you want to back up a huge file (e.g., a 10-GB AVI file) to a
 * CD-R. You can achieve it by splitting the file into smaller pieces and backing up
 * these pieces separately. Write a utility program that splits a large file into smaller
 * ones using the following command:
 * <p>
 * java Exercise17_10 SourceFile numberOfPieces
 */ /**
     * Main method
     *
     * @param args [0] for sourceFile (Should be located in current package)
     * @param args [1] for numberOfOutputFiles
     */","package ch_17.exercise17_10;

import java.io.*;
import java.nio.file.Files;


public class Exercise17_10 {
    
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println(""No parameters were passed...."");
            System.out.println(""Usage: java Exercise17_10 SourceFile numberOfPieces"");
            return;
        }

        File sourceFile = new File(""ch_17/exercise17_10"", args[0]);

        int numberOfPieces = Integer.parseInt(args[1]);
        File outDirectory = new File(sourceFile.getParent(),""Result_Dir"");
        outDirectory.mkdir();

        File[] outFiles = new File[numberOfPieces];
        String outFilesBaseName = sourceFile.getName() + ""_bak_"";
        for (int i = 0; i < outFiles.length; i++) {
            outFiles[i] = new File(outDirectory,outFilesBaseName + (i + 1) + "".dat"");
        }
        try {

            byte[] bytes = Files.readAllBytes(sourceFile.toPath());
            int bytePerFile = bytes.length / numberOfPieces;
            int masterByteArrayIndex = 0;
            for (File file : outFiles) {
                BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(file));
                for (int i = 0; i < bytePerFile; i++) {
                    outputStream.write(bytes[masterByteArrayIndex]);
                    masterByteArrayIndex++;
                }
                outputStream.flush();
                outputStream.close();
            }


        } catch (Exception exception) {
            exception.printStackTrace();
        }

    }

}
","import java.io.*;

public class Exercise17_10 {
    public static void main(String[] args) throws IOException {
        // Check the number of arguments
        if (args.length != 2) {
            System.out.println(""Usage: java Exercise17_10 sourceFile numberOfPieces"");
            System.exit(1);
        }

        // Get the input file name and number of output files
        String sourceFile = args[0];
        int numberOfPieces = Integer.parseInt(args[1]);

        // Create a buffered input stream to read the source file
        BufferedInputStream input = new BufferedInputStream(new FileInputStream(sourceFile));

        // Get the size of the source file in bytes
        long fileSize = new File(sourceFile).length();

        // Calculate the size of each output file in bytes
        long pieceSize = fileSize / numberOfPieces;
        long lastPieceSize = fileSize - (numberOfPieces - 1) * pieceSize;

        // Create the output files
        for (int i = 0; i < numberOfPieces; i++) {
            String outputFileName = sourceFile + "".part"" + i;
            BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(outputFileName));

            // Write the bytes to the output file
            if (i == numberOfPieces - 1) {
                // Last piece
                byte[] lastPiece = new byte[(int) lastPieceSize];
                input.read(lastPiece);
                output.write(lastPiece);
            } else {
                byte[] piece = new byte[(int) pieceSize];
                input.read(piece);
                output.write(piece);
            }

            // Close the output stream
            output.close();
        }

        // Close the input stream
        input.close();

        System.out.println(""File split successfully into "" + numberOfPieces + "" pieces."");
    }
}",1,"import java.io.*;

public class Exercise17_10 {
    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println(""Usage: java Exercise17_10 SourceFile numberOfPieces"");
            return;
        }

        String sourceFileName = args[0];
        int numberOfPieces = Integer.parseInt(args[1]);

        File sourceFile = new File(sourceFileName);

        if (!sourceFile.exists()) {
            System.out.println(""Source file does not exist."");
            return;
        }

        if (numberOfPieces <= 0) {
            System.out.println(""Number of pieces must be greater than 0."");
            return;
        }

        long sourceFileSize = sourceFile.length();
        long pieceSize = sourceFileSize / numberOfPieces;
        long remainingBytes = sourceFileSize % numberOfPieces;

        try (BufferedInputStream inputStream = new BufferedInputStream(new FileInputStream(sourceFile))) {
            byte[] buffer = new byte[1024];
            int bytesRead;

            for (int i = 1; i <= numberOfPieces; i++) {
                String outputFileName = sourceFile.getName() + "".part"" + i;
                try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFileName))) {
                    long bytesToWrite = (i < numberOfPieces) ? pieceSize : pieceSize + remainingBytes;
                    while (bytesToWrite > 0 && (bytesRead = inputStream.read(buffer)) != -1) {
                        outputStream.write(buffer, 0, bytesRead);
                        bytesToWrite -= bytesRead;
                    }
                }
            }

            System.out.println(""File split successfully into "" + numberOfPieces + "" pieces."");
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(""Error splitting the file."");
        }
    }
}
",0.6119704102219233
0_Exercise17_19.java," /**
 * 17.19 (View hex) Write a program that prompts the user to enter a file name, reads bytes
 * from the file, and displays each byte’s hex representation. (Hint: You can first
 * convert the byte value into an 8-bit string, then convert the bit string into a two-digit hex string.)
 * <p>
 * Example test input: ch_17/exercise17_19/testFile.txt
 */","package ch_17.exercise17_19;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Scanner;


public class Exercise17_19 {
    static BufferedInputStream bufferedInputStream;
    static ArrayList<String> strBytes;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        strBytes = new ArrayList<>();
        System.out.println(""Enter a filename: "");
        String fileName = in.nextLine().trim();
        try {
            bufferedInputStream = new BufferedInputStream(new FileInputStream(fileName));
            int b;
            while ((b = bufferedInputStream.read()) != -1) {
                String val = getBits(b);
                System.out.println(""Read byte value = "" + val);
                int asInteger = Integer.parseInt(val, 2);
                strBytes.add(Integer.toHexString(asInteger).toUpperCase());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(""The byte contents of the file, converted to hex are: "");
        System.out.println(strBytes.toString());
    }

    public static String getBits(int value) {
        StringBuilder bits = new StringBuilder();
        for (int i = 0; i < 8; i++) {
            bits.insert(0, (value & 1));
            value >>= 1;
        }
        return bits.toString();
    }
}
","import java.io.FileInputStream;
import java.io.IOException;

public class Exercise17_19 {
    public static void main(String[] args) {
        // Prompt the user for a file name
        String fileName = System.console().readLine(""Enter file name: "");

        try (FileInputStream input = new FileInputStream(fileName)) {
            // Read bytes from the file and display their hex representation
            int value;
            while ((value = input.read()) != -1) {
                String hex = Integer.toHexString(value & 0xFF);
                if (hex.length() == 1) {
                    hex = ""0"" + hex;
                }
                System.out.print(hex.toUpperCase() + "" "");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
",1,"import java.io.FileInputStream;
import java.io.IOException;

public class ViewHex {

    public static void main(String[] args) {
        System.out.println(""Welcome to the Hex Viewer Program!"");
        System.out.print(""Please enter the file name: "");
        String fileName = System.console().readLine();

        try {
            FileInputStream fileInputStream = new FileInputStream(fileName);

            int byteRead;
            while ((byteRead = fileInputStream.read()) != -1) {
                String hexRepresentation = Integer.toHexString(byteRead);
                if (hexRepresentation.length() == 1) {
                    System.out.print(""0""); // Add a leading '0' if necessary to ensure two-digit hex representation
                }
                System.out.print(hexRepresentation + "" "");
            }

            fileInputStream.close();
        } catch (IOException e) {
            System.out.println(""An error occurred while reading the file: "" + e.getMessage());
        }
    }
}
",0.6541405706332637
0_Exercise17_21.java," /**
 * *17.21 (Hex editor) Write a GUI application that lets the user enter a file name in the
 * text field and press the Enter key to display its hex representation in a text area.
 * The user can also modify the hex code and save it back to the file, as shown in
 * Figure 17.23b.
 * <p>
 * Example file input: ch_17/exercise17_21/testFile.txt
 */","package ch_17.exercise17_21;

import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.io.*;


public class Exercise17_21 extends Application {
    private static String filePath = null;
    SimpleStringProperty editBoxString = new SimpleStringProperty();

    @Override
    public void start(Stage primaryStage) throws Exception {
        VBox mainBox = new VBox(5);
        HBox topBox = new HBox(5);

        TextField textField = new TextField();
        Label label = new Label(""Enter a file: "");
        topBox.getChildren().add(label);
        topBox.getChildren().add(textField);
        mainBox.getChildren().add(topBox);

        HBox.setHgrow(textField, Priority.ALWAYS);
        HBox.setMargin(textField, new Insets(5, 5, 5, 1));
        HBox.setMargin(label, new Insets(9, 1, 5, 5));

        TextArea editBox = new TextArea();
        editBox.setWrapText(true);
        editBoxString.bindBidirectional(editBox.textProperty());

        mainBox.getChildren().add(editBox);

        HBox buttonBox = new HBox(5);
        Button saveButton = new Button(""Save the change"");
        saveButton.setOnAction(e -> {
            try {
                write(editBoxString.get(), filePath);
                editBox.clear();
            } catch (IOException ioException) {
                ioException.printStackTrace();
            }
        });
        buttonBox.setAlignment(Pos.CENTER);
        buttonBox.getChildren().add(saveButton);
        saveButton.setCenterShape(true);

        mainBox.getChildren().add(buttonBox);
        VBox.setMargin(buttonBox, new Insets(5, 5, 5, 5));

        Scene scene = new Scene(mainBox, 600, 300);
        scene.setOnKeyPressed(event -> {
            if (event.getCode() == KeyCode.ENTER) {
                try {
                    filePath = textField.getText().trim();
                    String hexValuesInString = read(filePath);
                    editBoxString.set(hexValuesInString);

                } catch (IOException ioException) {
                    ioException.printStackTrace();
                }
            }
        });
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();

    }

    private void write(String hexValues, String filePath) throws IOException {
        FileOutputStream output = new FileOutputStream(filePath);
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(output));
        for (int i = 0; i < hexValues.length(); i += 2) {
            char value = (char) ((Character.digit(hexValues.charAt(i), 16) << 4) + Character.digit(hexValues.charAt(i + 1), 16));
           writer.write(value);
        }
        writer.close();
    }

    private String read(String filePath) throws IOException {
        FileInputStream input = new FileInputStream(filePath);
        BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        String asChars = """";
        int next;
        while ((next = reader.read()) != -1) {
            asChars += String.format(""%H"", next);
        }
        input.close();
        return asChars;
    }


    public static void main(String[] args) {
        Application.launch(args);
    }
}
","import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

public class HexEditor extends JFrame {

    private JTextField fileNameTextField;
    private JTextArea hexTextArea;
    private JButton openButton;
    private JButton saveButton;

    public HexEditor() {
        super(""Hex Editor"");
        initComponents();
        setSize(new Dimension(800, 600));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setVisible(true);
    }

    private void initComponents() {
        fileNameTextField = new JTextField();
        fileNameTextField.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                openFile();
            }
        });

        hexTextArea = new JTextArea();
        hexTextArea.setEditable(true);

        JScrollPane scrollPane = new JScrollPane(hexTextArea);

        openButton = new JButton(""Open"");
        openButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                openFile();
            }
        });

        saveButton = new JButton(""Save"");
        saveButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                saveFile();
            }
        });

        JPanel buttonPanel = new JPanel();
        buttonPanel.add(openButton);
        buttonPanel.add(saveButton);

        add(fileNameTextField, BorderLayout.NORTH);
        add(scrollPane, BorderLayout.CENTER);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void openFile() {
        JFileChooser fileChooser = new JFileChooser();
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            fileNameTextField.setText(file.getAbsolutePath());
            try {
                FileInputStream fis = new FileInputStream(file);
                StringBuilder sb = new StringBuilder();
                int i = 0;
                while ((i = fis.read()) != -1) {
                    sb.append(String.format(""%02X "", i));
                }
                hexTextArea.setText(sb.toString());
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private void saveFile() {
        JFileChooser fileChooser = new JFileChooser();
        int result = fileChooser.showSaveDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            try {
                FileOutputStream fos = new FileOutputStream(file);
                String hexText = hexTextArea.getText().replaceAll(""\\s"", """");
                for (int i = 0; i < hexText.length(); i += 2) {
                    String hexByte = hexText.substring(i, i + 2);
                    fos.write(Integer.parseInt(hexByte, 16));
                }
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) {
            e.printStackTrace();
        }
        new HexEditor();
    }
}
",1,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;

public class HexEditor extends JFrame {
    private JTextField fileNameTextField;
    private JTextArea hexTextArea;
    private JButton loadButton;
    private JButton saveButton;

    public HexEditor() {
        setTitle(""Hex Editor"");
        setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        // Create components
        fileNameTextField = new JTextField(30);
        hexTextArea = new JTextArea(20, 40);
        loadButton = new JButton(""Load File"");
        saveButton = new JButton(""Save File"");

        // Set layout
        setLayout(new BorderLayout());

        // Add components to the frame
        add(fileNameTextField, BorderLayout.NORTH);
        add(new JScrollPane(hexTextArea), BorderLayout.CENTER);

        // Create a panel for buttons
        JPanel buttonPanel = new JPanel();
        buttonPanel.add(loadButton);
        buttonPanel.add(saveButton);
        add(buttonPanel, BorderLayout.SOUTH);

        // Add action listeners
        loadButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                loadFile();
            }
        });

        saveButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                saveFile();
            }
        });
    }

    private void loadFile() {
        String fileName = fileNameTextField.getText();
        try {
            FileInputStream inputStream = new FileInputStream(fileName);
            StringBuilder hexString = new StringBuilder();

            int data;
            while ((data = inputStream.read()) != -1) {
                hexString.append(String.format(""%02X "", data));
            }

            hexTextArea.setText(hexString.toString());
            inputStream.close();
        } catch (IOException e) {
            JOptionPane.showMessageDialog(this, ""Error loading file: "" + e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void saveFile() {
        String fileName = fileNameTextField.getText();
        String hexData = hexTextArea.getText();

        try {
            FileOutputStream outputStream = new FileOutputStream(fileName);

            // Convert the hex string back to bytes
            String[] hexBytes = hexData.split("" "");
            for (String hexByte : hexBytes) {
                int decimalValue = Integer.parseInt(hexByte, 16);
                outputStream.write(decimalValue);
            }

            outputStream.close();
            JOptionPane.showMessageDialog(this, ""File saved successfully!"", ""Success"", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException | NumberFormatException e) {
            JOptionPane.showMessageDialog(this, ""Error saving file: "" + e.getMessage(), ""Error"", JOptionPane.ERROR_MESSAGE);
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                new HexEditor().setVisible(true);
            }
        });
    }
}
",0.5304559693699965
0_Exercise17_20.java," /**
 * **17.20 (Binary editor) Write a GUI application that lets the user enter a file name in the
 * text field and press the Enter key to display its binary representation in a text area.
 * The user can also modify the binary code and save it back to the file, as shown in
 * Figure 17.23a.
 * <p>
 * <p>
 * Example file input field: ch_17/exercise17_20/testFile.txt
 */","package ch_17.exercise17_20;

import javafx.application.Application;
import javafx.beans.property.SimpleStringProperty;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.io.*;


public class Exercise17_20 extends Application {
    private static String filePath = null;
    private SimpleStringProperty editBoxString = new SimpleStringProperty();

    public static void main(String[] args) {
        Application.launch(args);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        VBox mainBox = new VBox(5);
        HBox topBox = new HBox(5);

        TextField textField = new TextField();
        Label label = new Label(""Enter a file: "");
        topBox.getChildren().add(label);
        topBox.getChildren().add(textField);
        mainBox.getChildren().add(topBox);

        HBox.setHgrow(textField, Priority.ALWAYS);
        HBox.setMargin(textField, new Insets(5, 5, 5, 1));
        HBox.setMargin(label, new Insets(9, 1, 5, 5));

        TextArea editBox = new TextArea();
        editBox.setWrapText(true);
        editBoxString.bindBidirectional(editBox.textProperty());

        mainBox.getChildren().add(editBox);

        HBox buttonBox = new HBox(5);
        Button saveButton = new Button(""Save the change"");
        saveButton.setOnAction(e -> {
            filePath = textField.getText().trim();
            try {
                writeFile(editBoxString.get(), new File(filePath));
                editBox.clear();
            } catch (IOException ioException) {
                ioException.printStackTrace();
            }
        });
        buttonBox.setAlignment(Pos.CENTER);
        buttonBox.getChildren().add(saveButton);
        saveButton.setCenterShape(true);

        mainBox.getChildren().add(buttonBox);
        VBox.setMargin(buttonBox, new Insets(5, 5, 5, 5));

        Scene scene = new Scene(mainBox, 600, 300);
        scene.setOnKeyPressed(event -> {
            if (event.getCode() == KeyCode.ENTER) {
                try {
                    filePath = textField.getText().trim();

                    String bytes = readFile(new File(filePath));
                    editBoxString.set(bytes);

                } catch (IOException ioException) {
                    System.out.println(""FilePath: "" + filePath);
                    ioException.printStackTrace();
                }
            }
        });

        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();

    }

    private void writeFile(String text, File file) throws IOException {
        BitOutputStream bitOutputStream = new BitOutputStream(file);
        bitOutputStream.writeBit(text);

    }

    private String readFile(File file) throws IOException {
        BitInputStream bitOutputStream = new BitInputStream(file);
        return bitOutputStream.readAllBytes();
    }

    public static class BitOutputStream implements Closeable {
        private FileOutputStream output;
        private int value;
        private int count = 0;
        private int mask = 1;

        public BitOutputStream(File file) throws IOException {
            output = new FileOutputStream(file);
        }

        public void writeBit(char bit) throws IOException {
            count++;
            value = value << 1;
            if (bit == '1')
                value = value | mask;
            if (count == 8) {
                output.write(value);
                count = 0;
            }
        }

        public void writeBit(String bitString) throws IOException {
            for (int i = 0; i < bitString.length(); i++)
                writeBit(bitString.charAt(i));
        }

        @Override
        public void close() throws IOException {
            if (count > 0) {
                value = value << (8 - count);
                output.write(value);
            }
            output.close();
        }

        void t() {
        }

    }

    public static class BitInputStream implements Closeable {
        private FileInputStream input;
        private String stringValue;
        private static final int EOF = -1;

        public BitInputStream(File file) throws IOException {
            input = new FileInputStream(file);
        }

        private String readAllBytes() throws IOException {
            stringValue = """";
            int intValue;
            while ((intValue = input.read()) != EOF) {
                stringValue += readBits(intValue);
            }
            input.close();
            return stringValue;

        }

        private String readBits(int value) {
            String bits = """";
            int mask = 1;
            for (int i = 7; i >= 0; i--) {
                int temp = value >> i;
                int bit = temp & mask;
                bits = bits + bit;
            }
            return bits;
        }

        @Override
        public void close() throws IOException {
            input.close();
        }
    }
}
","import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;

public class BinaryEditor extends JFrame {

    private JTextField fileNameTextField;
    private JTextArea binaryTextArea;
    private JButton openButton;
    private JButton saveButton;

    public BinaryEditor() {
        super(""Binary Editor"");
        initComponents();
        setSize(new Dimension(800, 600));
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setVisible(true);
    }

    private void initComponents() {
        fileNameTextField = new JTextField();
        fileNameTextField.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                openFile();
            }
        });

        binaryTextArea = new JTextArea();
        binaryTextArea.setEditable(true);

        JScrollPane scrollPane = new JScrollPane(binaryTextArea);

        openButton = new JButton(""Open"");
        openButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                openFile();
            }
        });

        saveButton = new JButton(""Save"");
        saveButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                saveFile();
            }
        });

        JPanel buttonPanel = new JPanel();
        buttonPanel.add(openButton);
        buttonPanel.add(saveButton);

        add(fileNameTextField, BorderLayout.NORTH);
        add(scrollPane, BorderLayout.CENTER);
        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void openFile() {
        JFileChooser fileChooser = new JFileChooser();
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            fileNameTextField.setText(file.getAbsolutePath());
            try {
                FileInputStream fis = new FileInputStream(file);
                StringBuilder sb = new StringBuilder();
                int i = 0;
                while ((i = fis.read()) != -1) {
                    sb.append(String.format(""%8s"", Integer.toBinaryString(i)).replace(' ', '0'));
                    sb.append("" "");
                }
                binaryTextArea.setText(sb.toString());
                fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private void saveFile() {
        JFileChooser fileChooser = new JFileChooser();
        int result = fileChooser.showSaveDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            try {
                FileOutputStream fos = new FileOutputStream(file);
                String binaryText = binaryTextArea.getText().replaceAll(""\\s"", """");
                for (int i = 0; i < binaryText.length(); i += 8) {
                    String binaryByte = binaryText.substring(i, i + 8);
                    fos.write(Integer.parseInt(binaryByte, 2));
                }
                fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException e) {
            e.printStackTrace();
        }
        new BinaryEditor();
    }
}",2,"import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;

public class BinaryEditorApp extends JFrame {
    private JTextField fileNameField;
    private JTextArea binaryTextArea;
    private JButton loadButton;
    private JButton saveButton;

    public BinaryEditorApp() {
        super(""Binary Editor"");

        // Create the main frame
        setSize(400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        // Create a label and text field for file input
        JLabel fileLabel = new JLabel(""Enter File Name:"");
        fileNameField = new JTextField(20);

        // Create a button to load the file
        loadButton = new JButton(""Load File"");
        loadButton.addActionListener(new LoadButtonListener());

        // Create a text area for displaying binary representation
        binaryTextArea = new JTextArea();
        binaryTextArea.setEditable(false);

        // Create a button to save changes to the file
        saveButton = new JButton(""Save Changes"");
        saveButton.addActionListener(new SaveButtonListener());

        // Add components to the frame
        JPanel topPanel = new JPanel();
        topPanel.add(fileLabel);
        topPanel.add(fileNameField);
        topPanel.add(loadButton);

        add(topPanel, BorderLayout.NORTH);
        add(new JScrollPane(binaryTextArea), BorderLayout.CENTER);
        add(saveButton, BorderLayout.SOUTH);
    }

    private class LoadButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            String fileName = fileNameField.getText();
            File file = new File(fileName);

            if (file.exists()) {
                try {
                    byte[] fileData = Files.readAllBytes(Path.of(fileName));
                    StringBuilder binaryData = new StringBuilder();

                    for (byte b : fileData) {
                        binaryData.append(Integer.toBinaryString(b & 0xFF));
                    }

                    binaryTextArea.setText(binaryData.toString());
                } catch (IOException e) {
                    binaryTextArea.setText(""Error reading file!"");
                }
            } else {
                binaryTextArea.setText(""File not found!"");
            }
        }
    }

    private class SaveButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            String fileName = fileNameField.getText();
            String binaryData = binaryTextArea.getText();

            try {
                BufferedWriter writer = Files.newBufferedWriter(Path.of(fileName), StandardOpenOption.WRITE);
                writer.write(binaryData);
                writer.close();
                binaryTextArea.setText(""Changes saved successfully!"");
            } catch (IOException e) {
                binaryTextArea.setText(""Error saving changes!"");
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            BinaryEditorApp app = new BinaryEditorApp();
            app.setVisible(true);
        });
    }
}
",0.5572609208972845
0_Exercise17_18.java," /**
 * 17.18 (View bits) Write the following method that displays the bit representation for the
 * last byte in an integer:
 * public static String getBits(int value)
 * For a hint, see {@link ch_05.Exercise05_44} Programming Exercise 5.44.
 * <p>
 * Write a program that prompts the
 * user to enter a file name, reads bytes from the file, and displays each byte’s binary
 * representation.
 * Example input: ch_17/exercise17_17/Exercise17_17.dat
 */","package ch_17.exercise17_18;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Scanner;


public class Exercise17_18 {
    static BufferedInputStream bufferedInputStream;
    static ArrayList<String> strBytes;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        strBytes = new ArrayList<>();
        System.out.println(""Enter a filename: "");
        String fileName = in.nextLine().trim();
        try {
            bufferedInputStream = new BufferedInputStream(new FileInputStream(fileName));
            int b;
            while ((b = bufferedInputStream.read()) != -1) {
                String val = getBits(b);
                strBytes.add(val);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(""The contents of the file, converted to bytes are: "");
        System.out.println(strBytes.toString());

        in.close();
    }

    public static String getBits(int value) {
        StringBuilder bits = new StringBuilder();
        long i;
        for (i = 128; i > 0; i /= 2) {
            bits.append((value & i) != 0 ? ""1"" : ""0"");
        }
        return bits.toString();
    }
}
","import java.io.*;
import java.util.*;

public class Exercise17_18 {
    
    /**
     * Displays the bit representation of the last byte in an integer
     *
     * @param value an integer value
     * @return a string of the bit representation of the last byte
     */
    public static String getBits(int value) {
        StringBuilder bitString = new StringBuilder();
        for (int i = 7; i >= 0; i--) {
            bitString.append((value & (1 << i)) == 0 ? '0' : '1');
        }
        return bitString.toString();
    }

    public static void main(String[] args) throws IOException {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a file name: "");
        File file = new File(input.nextLine());

        if (!file.exists()) {
            System.out.println(""File "" + file.getName() + "" does not exist"");
            System.exit(1);
        }

        try (DataInputStream inputStream = new DataInputStream(new FileInputStream(file))) {
            while (inputStream.available() > 0) {
                int value = inputStream.readUnsignedByte();
                String bits = getBits(value);
                System.out.println(value + "" is "" + bits);
            }
        }
    }
}
",2,"import java.io.*;
import java.util.Scanner;

public class BitViewer {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Please enter a file name: "");
        String fileName = input.nextLine();

        try {
            FileInputStream fileInputStream = new FileInputStream(fileName);

            int lastByte;
            while ((lastByte = fileInputStream.read()) != -1) {
                String binaryRepresentation = getBits(lastByte);
                System.out.println(""Binary representation of the last byte: "" + binaryRepresentation);
            }

            fileInputStream.close();
        } catch (FileNotFoundException e) {
            System.err.println(""File not found. Please check the file path and try again."");
        } catch (IOException e) {
            System.err.println(""An error occurred while reading the file."");
        }
    }

    public static String getBits(int value) {
        StringBuilder binary = new StringBuilder(8);
        for (int i = 7; i >= 0; i--) {
            binary.append((value >> i) & 1);
        }
        return binary.toString();
    }
}
",0.44804865686771417
0_Exercise17_16.java," /**
 * 17.16 (Frequency of characters) Write a program that prompts the user to enter the
 * name of an ASCII text file and displays the frequency of the characters in the file.
 * <i>File should be located in the exercise17_16 package...</i>
 */","package ch_17.exercise17_16;


import java.io.File;
import java.io.FileInputStream;
import java.util.Scanner;


public class Exercise17_16 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter the name of an ASCII text file: "");
        String fileName = in.next();
        if (!fileName.isEmpty()) {
            File file = new File(""ch_17/exercise17_16"", File.separator + fileName);
            int totalChars = 0;
            int totalLines = 1;
            try (FileInputStream fileInputStream = new FileInputStream(file)) {
                int nextChar;
                while ((nextChar = fileInputStream.read()) != -1) {
                    char ch = (char) nextChar;
                    if (ch != ' ') {
                        totalChars++;
                    }
                    if (ch == '\n') {
                        totalLines++;
                    }

                }
            } catch (Exception e) {
                e.printStackTrace();
            }

            System.out.println(""There are "" + totalChars + "" total characters in the file."");
            System.out.println(""There are "" + totalLines + "" total lines in the file."");
            System.out.println(""So the file has an average of "" + totalChars / totalLines + "" characters per line."");

        } else {
            System.out.println(""Please enter a file name in the prompt..."");
            System.exit(1);
        }

        in.close();
    }
}
","import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Exercise17_16 {
    public static void main(String[] args) {
        // Prompt the user for the file name
        System.out.print(""Enter the file name: "");
        String fileName = new Scanner(System.in).nextLine();

        // Open the file and count the character frequencies
        Map<Character, Integer> freqMap = new HashMap<>();
        try (Scanner input = new Scanner(new File(""exercise17_16/"" + fileName))) {
            while (input.hasNextLine()) {
                String line = input.nextLine();
                for (int i = 0; i < line.length(); i++) {
                    char ch = line.charAt(i);
                    freqMap.put(ch, freqMap.getOrDefault(ch, 0) + 1);
                }
            }
        } catch (FileNotFoundException e) {
            System.err.println(""File not found: "" + fileName);
            return;
        }

        // Print the character frequencies
        for (Map.Entry<Character, Integer> entry : freqMap.entrySet()) {
            char ch = entry.getKey();
            int freq = entry.getValue();
            System.out.printf(""%c: %d\n"", ch, freq);
        }
    }
}
",2,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class CharacterFrequencyCounter {

    public static void main(String[] args) {
        System.out.println(""Welcome to the Character Frequency Counter!"");

        Scanner scanner = new Scanner(System.in);
        System.out.print(""Please enter the name of the ASCII text file (located in the exercise17_16 package): "");
        String fileName = scanner.nextLine();

        try {
            FileReader fileReader = new FileReader(""exercise17_16/"" + fileName);
            BufferedReader bufferedReader = new BufferedReader(fileReader);

            Map<Character, Integer> charFrequency = new HashMap<>();

            int c;
            while ((c = bufferedReader.read()) != -1) {
                char character = (char) c;

                if (Character.isLetterOrDigit(character)) {
                    if (charFrequency.containsKey(character)) {
                        int currentFrequency = charFrequency.get(character);
                        charFrequency.put(character, currentFrequency + 1);
                    } else {
                        charFrequency.put(character, 1);
                    }
                }
            }

            bufferedReader.close();

            System.out.println(""Character frequency in the file:"");
            for (char character : charFrequency.keySet()) {
                int frequency = charFrequency.get(character);
                System.out.println(""Character '"" + character + ""': "" + frequency + "" times"");
            }
        } catch (IOException e) {
            System.err.println(""An error occurred: "" + e.getMessage());
        }
    }
}
",0.5282707387536112
0_Exercise17_05.java," /**
 * *17.5 (Store objects and arrays in a file) Write a program that stores an array of the five
 * int values 1, 2, 3, 4, and 5, a Date object for the current time, and the double
 * value 5.5 into the file named Exercise17_05.dat.
 *
 */","package ch_17.exercise17_05;

import ch_17.exercise17_01.Exercise17_01;

import java.io.*;
import java.util.*;


public class Exercise17_05 {
    public static void main(String[] args) {
        int[] a = new int[]{1, 2, 3, 4, 5}; //Arrays are stored as Object in Java
        Date date = new Date(); // Object of Date type,implements Serializable. Default constructor creates with the
        // current data/time.
        Double value = 5.5; // Implicit cast of double to wrapper type Double which implements Serializable.
        String[] packageParts = Exercise17_01.class.getPackage().getName().split(""\\."");
        String filePath = packageParts[0] + File.separator + packageParts[1] + File.separator + ""Exercise17_05.dat"";

        File file = new File(filePath);
        try (ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(file))) {
            objectOutputStream.writeObject(a);
            objectOutputStream.writeObject(date);
            objectOutputStream.writeObject(a);
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }


    }
}","import java.io.*;
import java.util.*;

public class Exercise17_05 {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        // Create array of integers, date object, and double value
        int[] nums = {1, 2, 3, 4, 5};
        Date date = new Date();
        double value = 5.5;

        // Create output stream to write to file
        ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(""Exercise17_05.dat""));

        // Write objects to file
        output.writeObject(nums);
        output.writeObject(date);
        output.writeDouble(value);

        // Close output stream
        output.close();

        // Create input stream to read from file
        ObjectInputStream input = new ObjectInputStream(new FileInputStream(""Exercise17_05.dat""));

        // Read objects from file and print them
        int[] readNums = (int[]) input.readObject();
        Date readDate = (Date) input.readObject();
        double readValue = input.readDouble();

        System.out.println(""Array of integers: "" + Arrays.toString(readNums));
        System.out.println(""Date object: "" + readDate);
        System.out.println(""Double value: "" + readValue);

        // Close input stream
        input.close();
    }
}
",2,"import java.io.*;
import java.util.*;
import java.text.*;

public class FileDataStorer {

    public static void main(String[] args) {
        System.out.println(""Starting data storage..."");

        int[] intArray = {1, 2, 3, 4, 5};
        Date currentDate = new Date();
        double doubleValue = 5.5;

        try {
            // Create a file named Exercise17_05.dat
            FileOutputStream fileOutputStream = new FileOutputStream(""Exercise17_05.dat"");
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);

            // Write the data to the file
            objectOutputStream.writeObject(intArray);
            objectOutputStream.writeObject(currentDate);
            objectOutputStream.writeDouble(doubleValue);

            objectOutputStream.close();

            System.out.println(""Data successfully stored in Exercise17_05.dat."");
        } catch (IOException e) {
            System.err.println(""An error occurred while storing data: "" + e.getMessage());
        }
    }
}
",0.5709954522486104
0_Exercise17_02.java," /**
 * *17.2 (Create a binary data file) Write a program to create a file named
 * Exercise17_02.dat if it does not exist. Append new data to it if it already exists.
 * Write 100 integers created randomly into the file using binary I/O.
 *
 */","package ch_17.exercise17_02;

import ch_17.exercise17_01.Exercise17_01;

import java.io.*;
import java.util.*;



public class Exercise17_02 {
    public static void main(String[] args) {
        String[] packageParts = Exercise17_01.class.getPackage().getName().split(""\\."");
        String filePath = packageParts[0] + File.separator + packageParts[1] + File.separator + ""Exercise17_02.dat"";

        try (FileOutputStream fileOutputStream = new FileOutputStream(new File(filePath), true)) {

            Random random = new Random();

            for (int i = 0; i < 100; i++) {
                int num = random.nextInt(100);
                fileOutputStream.write(num);
            }


        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(""IOException occurred."");
        }

    }
}","import java.io.*;

public class Exercise17_02 {
    public static void main(String[] args) throws IOException {
        File file = new File(""Exercise17_02.dat"");

        // Create the output stream
        DataOutputStream output = null;
        if (file.exists()) {
            output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file, true)));
        } else {
            output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
        }

        // Write 100 random integers to the file
        for (int i = 0; i < 100; i++) {
            output.writeInt((int) (Math.random() * 100));
        }

        // Close the output stream
        output.close();

        System.out.println(""Data has been written to "" + file.getAbsolutePath());
    }
}
",2,"import java.io.*;
import java.util.Random;

public class BinaryDataFileCreator {
    public static void main(String[] args) {
        // Let's create a binary data file named ""Exercise17_02.dat""
        File file = new File(""Exercise17_02.dat"");

        // Check if the file already exists
        if (file.exists()) {
            System.out.println(""The file Exercise17_02.dat already exists. Appending data to it..."");
        } else {
            System.out.println(""The file Exercise17_02.dat does not exist. Creating a new file..."");
        }

        // We'll use a try-catch block for file handling
        try {
            // Create a FileOutputStream to write binary data
            FileOutputStream fos = new FileOutputStream(file, true); // We append data if the file already exists

            // Create a DataOutputStream to write integers
            DataOutputStream dos = new DataOutputStream(fos);

            // Let's generate and write 100 integers into the file
            for (int i = 0; i < 100; i++) {
                // Generate a random integer between 1 and 100
                int randomNumber = new Random().nextInt(100) + 1;

                // Write the integer to the file
                dos.writeInt(randomNumber);

                // Display a message for each integer written
                System.out.println(""Writing integer: "" + randomNumber);
            }

            // Close the DataOutputStream
            dos.close();

            System.out.println(""Data successfully written to Exercise17_02.dat."");
        } catch (IOException e) {
            System.err.println(""An error occurred while writing data: "" + e.getMessage());
        }
    }
}
",0.5106177606177607
0_Exercise17_03.java," /**
 * *17.3 (Sum all the integers in a binary data file) Suppose a binary data file named
 * Exercise17_03.dat has been created and its data are created using
 * writeInt(int) in DataOutputStream. The file contains an unspecified
 * number of integers. Write a program to find the sum of the integers
 *
 */","package ch_17.exercise17_03;

import ch_17.exercise17_01.Exercise17_01;
import com.sun.xml.internal.ws.policy.privateutil.PolicyUtils;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;


public class Exercise17_03 {
    public static void main(String[] args) {

        String[] packageParts = Exercise17_01.class.getPackage().getName().split(""\\."");
        String filePath = packageParts[0] + File.separator + packageParts[1] + File.separator + ""Exercise17_03.dat"";
        if (!(new File(filePath).exists())) {
            try (FileOutputStream fis = new FileOutputStream(filePath)) {
                DataOutputStream dos = new DataOutputStream(fis);
                runCreateTestDatFile(dos);
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println(e.getLocalizedMessage());
            }

        }
        try (FileInputStream fis = new FileInputStream(filePath)) {
            DataInputStream dis = new DataInputStream(fis);

            int sum = 0;
            int numIntegers = dis.available() / 4; // An integer is stored as 4 bytes

            System.out.print(""The sum of: "");
            for (int i = 0; i < numIntegers; i++) {
                int n = dis.readInt();
                if (i == 0) {
                    System.out.print(n + """");
                } else {
                    System.out.print("" + "" + n);
                }
                sum += n;
            }
            System.out.println("" = "" + sum);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static void runCreateTestDatFile(DataOutputStream dos) throws IOException {
        for (int i = 0; i < 10; i++) {
            int n = (int) (1 + Math.random() * 10);
            dos.writeInt(n);
        }
        dos.flush();
        dos.close();

    }
}","import java.io.*;

public class Exercise17_03 {
    public static void main(String[] args) throws IOException {
        File file = new File(""Exercise17_03.dat"");
        int sum = 0;

        if (file.exists()) {
            try (DataInputStream input = new DataInputStream(new FileInputStream(file))) {
                while (true) {
                    sum += input.readInt();
                }
            } catch (EOFException ex) {
                // End of file reached, do nothing
            }
        }

        System.out.println(""Sum of integers in "" + file.getName() + "" is "" + sum);
    }
}
",2,"import java.io.*;

public class SumIntegersInBinaryFile {
    public static void main(String[] args) {
        try {
            FileInputStream fileStream = new FileInputStream(""Exercise17_03.dat"");
            DataInputStream dataStream = new DataInputStream(fileStream);

            int sum = 0; // Initialize sum to 0

            while (true) { // Keep looping until an exception occurs
                try {
                    int num = dataStream.readInt(); // Read an integer from the file
                    sum += num; // Add the integer to the sum
                } catch (EOFException e) {
                    break; // Exit the loop when we reach the end of the file
                }
            }

            dataStream.close(); // Close the data stream
            fileStream.close(); // Close the file stream

            System.out.println(""The sum of integers in the file is: "" + sum); // Print the sum
        } catch (IOException e) {
            System.out.println(""An error occurred: "" + e.getMessage()); // Handle any IO errors
        }
    }
}
",0.5300837776085301
0_Exercise17_04.java," /**
 * *17.4 (Convert a text file into UTF) Write a program that reads lines of characters from
 * a text file and writes each line as a UTF-8 string into a binary file. Display the
 * sizes of the text file and the binary file. Use the following command to run the
 * program:
 * <p>
 * java ch_17.exercise17_04.Exercise17_04 Welcome.java Welcome.utf
 * <p>
 * <p>
 * To Run:  open ch_17 folder in Terminal,
 * cmdline: javac ch_17.exercise17_04.Exercise17_04.java
 * cmdline: java ch_17.exercise17_04.Exercise17_04 textfile.txt nameForOutFile.utf
 *
 */","package ch_17.exercise17_04;


import java.io.*;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.*;


public class Exercise17_04 {
    public static void main(String[] args) {

        if (args[0] == null) {
            return;
        } else if (args[1] == null || !args[1].endsWith("".utf"")) {
            return;
        }
        List<String> lines = new ArrayList<>();
        File fileIn;
        URL pathIn = Exercise17_04.class.getResource(args[0]);
        File fileOut = new File(args[1]);

        try {
            fileIn = new File(pathIn.toURI());
            System.out.println(""Begin reading the input file.. File size is "" + fileIn.length() + "" bytes. "");
            try (Scanner fileScan = new Scanner(fileIn);) {
                while (fileScan.hasNextLine()) {
                    String line = fileScan.nextLine();
                    System.out.println(""Read: ..."" + line.substring((line.length() / 3)));
                    lines.add(line);
                }
                System.out.println(""Done reading the input file..."");

                try (DataOutputStream out = new DataOutputStream(new FileOutputStream(fileOut))) {
                    System.out.println(""Writing the output file.. "" + fileOut.getName());
                    for (String line : lines) {
                        out.writeUTF(line);
                    }
                    System.out.println(""Done writing the output file -> "" + fileOut.getName());
                } catch (FileNotFoundException fnfe) {
                    fnfe.printStackTrace();
                    System.out.println(""Error finding the file to write to...."");
                } catch (IOException ioe) {
                    System.out.println(""Error writing output to: "" + fileOut.getName());
                    ioe.printStackTrace();
                }
                RandomAccessFile randomAccessFile = new RandomAccessFile(fileOut, ""r"");
                System.out.println(""The size of "" + fileOut.getName() + "" is "" + randomAccessFile.length() + "" bytes."");
                randomAccessFile.close();


            } catch (IOException e) {
                System.out.println(""Error reading input from: "" + fileIn.getName());
                e.printStackTrace();
            }
        } catch (URISyntaxException urie) {
            urie.printStackTrace();
        }
    }
}","package ch_17.exercise17_04;

import java.io.*;

public class Exercise17_04 {
    public static void main(String[] args) throws IOException {
        if (args.length != 2) {
            System.out.println(""Usage: java Exercise17_04 inputFile outputFile"");
            System.exit(1);
        }

        // Create input and output file objects
        File inputFile = new File(args[0]);
        File outputFile = new File(args[1]);

        if (!inputFile.exists()) {
            System.out.println(""Input file "" + inputFile.getName() + "" does not exist"");
            System.exit(2);
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(inputFile));
             DataOutputStream output = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(outputFile)))) {

            String line;
            while ((line = reader.readLine()) != null) {
                output.writeUTF(line);
            }
        }

        // Display the sizes of the text file and the binary file
        System.out.println(""Input file size: "" + inputFile.length() + "" bytes"");
        System.out.println(""Output file size: "" + outputFile.length() + "" bytes"");
    }
}
",2,"import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class Exercise17_04 {

    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println(""Please provide the input text file and the output binary file."");
            return;
        }

        String inputFile = args[0];
        String outputFile = args[1];

        try {
            FileReader fileReader = new FileReader(inputFile);
            BufferedReader bufferedReader = new BufferedReader(fileReader);

            FileWriter fileWriter = new FileWriter(outputFile);
            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

            String line;
            while ((line = bufferedReader.readLine()) != null) {
                // Read a line from the text file
                // And write it as a UTF-8 string into the binary file
                bufferedWriter.write(new String(line.getBytes(""UTF-8"")));
                bufferedWriter.newLine();
            }

            bufferedReader.close();
            bufferedWriter.close();

            // Display the sizes of the text file and the binary file
            System.out.println(""Text file size: "" + getFileSize(inputFile) + "" bytes"");
            System.out.println(""Binary file size: "" + getFileSize(outputFile) + "" bytes"");

        } catch (IOException e) {
            System.err.println(""An error occurred while processing the files: "" + e.getMessage());
        }
    }

    // Helper method to get the file size
    private static long getFileSize(String filePath) {
        java.io.File file = new java.io.File(filePath);
        return file.length();
    }
}
",0.5312627707396812
0_Exercise17_14.java," /**
 * 17.14 (Encrypt files) Encode the file by adding 5 to every byte in the file.
 * <p>
 * Write a program that prompts the user to enter an input file name and an output file name and
 * saves the encrypted version of the input file to the output file.
 */","package ch_17.exercise17_14;

import java.io.*;
import java.nio.file.Files;
import java.util.Scanner;


public class Exercise17_14 {
    public static void main(String[] args) {
        String CURRENT_DIR = ""ch_17"" + File.separator + ""exercise17_14"";

        Scanner in = new Scanner(System.in);
        System.out.print(""Please enter the input file name to be encrypted: "");
        String inFileStr = in.next();

        File inputFile = new File(CURRENT_DIR, inFileStr);

        System.out.print(""Please enter a name for the output file: "");
        String outFileStr = in.next();

        File outputFile = new File(CURRENT_DIR, outFileStr);
        try (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(outputFile))) {
            try {
                byte[] inBytes = Files.readAllBytes(inputFile.toPath());
                for (byte b : inBytes) {
                    bufferedOutputStream.write(b + 5);
                }
                bufferedOutputStream.flush();
                bufferedOutputStream.close();

            } catch (IOException ioException) {
                ioException.printStackTrace();
            }

        } catch (Exception e) {
            e.printStackTrace();
        }


        in.close();
    }
}
","import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileEncrypter {
    public static void main(String[] args) {
        // Prompt the user for input and output file names
        String inputFileName = System.console().readLine(""Enter input file name: "");
        String outputFileName = System.console().readLine(""Enter output file name: "");

        try (FileInputStream input = new FileInputStream(inputFileName);
             FileOutputStream output = new FileOutputStream(outputFileName)) {

            // Read the input file byte by byte and write the encrypted version to the output file
            int b;
            while ((b = input.read()) != -1) {
                output.write(b + 5);
            }
        } catch (IOException e) {
            System.err.println(""Error: "" + e.getMessage());
        }
    }
}
",2,"import java.io.*;

public class FileEncryption {
    public static void main(String[] args) {
        // Step 1: Get the input file name from the user
        System.out.println(""Please enter the name of the file you want to encrypt:"");
        Scanner scanner = new Scanner(System.in);
        String inputFile = scanner.nextLine();

        // Step 2: Get the output file name from the user
        System.out.println(""Now, enter the name of the output file where you want to save the encrypted data:"");
        String outputFile = scanner.nextLine();

        // Step 3: Open the input and output streams
        FileInputStream inputStream = null;
        FileOutputStream outputStream = null;

        try {
            inputStream = new FileInputStream(inputFile);
            outputStream = new FileOutputStream(outputFile);

            // Step 4: Read and encrypt each byte in the input file
            int data;
            while ((data = inputStream.read()) != -1) {
                // Encrypt the byte by adding 5 to it
                int encryptedByte = data + 5;

                // Step 5: Write the encrypted byte to the output file
                outputStream.write(encryptedByte);
            }

            System.out.println(""File encryption completed successfully!"");
        } catch (IOException e) {
            // Handle any exceptions that might occur during file operations
            System.err.println(""An error occurred: "" + e.getMessage());
        } finally {
            // Step 6: Close the input and output streams
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
                if (outputStream != null) {
                    outputStream.close();
                }
            } catch (IOException e) {
                System.err.println(""Error closing streams: "" + e.getMessage());
            }
        }
    }
}
",0.491585473870682
0_Exercise17_12.java," /**
 * 17.12 (Combine files) Write a utility program that combines the files together into a
 * new file using the following command:
 * java Exercise17_12 SourceFile1 . . . SourceFilen TargetFile
 * The command combines SourceFile1, . . . , and SourceFile^n into TargetFile.
 * <p>
 * Test Example:
 * <p>
 * cd ch_17/exercise17_12/
 * javac Exercise17_12.java
 * java Exercise17_12 TestFile.dat.1 TestFile.dat.2 TestFile.dat.3 TestFile.dat.4 ResultFile.dat
 */","package ch_17.exercise17_12;

import java.io.*;
import java.nio.file.Files;
import java.util.Arrays;


public class Exercise17_12 {
    private static final String PARENT_PATH = ""ch_17/exercise17_12"";

    public static void main(String[] args) {
        if (args.length < 3) {
            System.out.println(""Usage: java Exercise17_12 SourceFile1 . . . SourceFilen TargetFile"");
            return;
        }
        File[] sourceFiles = new File[args.length - 1]; //Array to hold source File references excluding TargetFile
        String targetFile = args[args.length - 1]; // Last value in args is the TargetFile
        File outFile = new File(PARENT_PATH, targetFile);
        for (int i = 0; i < args.length - 1; i++) {
            sourceFiles[i] = new File(PARENT_PATH, args[i]);
        }
        try {
            combineFiles(sourceFiles, outFile);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    private static void combineFiles(File[] srcFiles, File targetFile) throws Exception {
        System.out.println(""Combining src files into target file: "" + targetFile.getName());
        byte[][] bytes = new byte[srcFiles.length][];
        int arraysIdx = 0;
        for (File f : srcFiles) {
            System.out.println(""Processing: "" + f.getName());
            bytes[arraysIdx++] = Files.readAllBytes(f.toPath());
        }
        FileOutputStream outputStream = new FileOutputStream(targetFile);
        for (byte[] bytArray : bytes) {
            outputStream.write(bytArray);
        }
        outputStream.flush();
        outputStream.close();
        System.out.println(""Completed: Success"");
    }
}
","import java.io.*;

public class Exercise17_12 {
    public static void main(String[] args) {
        if (args.length < 2) {
            System.out.println(""Usage: java Exercise17_12 SourceFile1 . . . SourceFilen TargetFile"");
            System.exit(0);
        }

        try {
            FileOutputStream outputStream = new FileOutputStream(args[args.length - 1]);

            for (int i = 0; i < args.length - 1; i++) {
                FileInputStream inputStream = new FileInputStream(args[i]);
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }
                inputStream.close();
            }

            outputStream.close();
            System.out.println(""Files combined successfully into "" + args[args.length - 1]);
        } catch (IOException e) {
            System.out.println(""Error: "" + e.getMessage());
        }
    }
}
",2,"import java.io.*;

public class CombineFilesUtility {

    public static void main(String[] args) {
        if (args.length < 3) {
            System.out.println(""Usage: java CombineFilesUtility SourceFile1 SourceFile2 ... TargetFile"");
            return;
        }

        String targetFileName = args[args.length - 1]; // The last argument is the target file
        File targetFile = new File(targetFileName);

        if (targetFile.exists()) {
            System.out.println(""Target file already exists. Please choose a different name."");
            return;
        }

        try {
            FileOutputStream targetStream = new FileOutputStream(targetFile);

            for (int i = 0; i < args.length - 1; i++) {
                String sourceFileName = args[i];
                File sourceFile = new File(sourceFileName);

                if (!sourceFile.exists()) {
                    System.out.println(""Source file '"" + sourceFileName + ""' does not exist. Skipping."");
                    continue;
                }

                FileInputStream sourceStream = new FileInputStream(sourceFile);

                int byteRead;
                while ((byteRead = sourceStream.read()) != -1) {
                    targetStream.write(byteRead);
                }

                sourceStream.close();
                System.out.println(""File '"" + sourceFileName + ""' has been combined."");
            }

            targetStream.close();
            System.out.println(""All files have been successfully combined into '"" + targetFileName + ""'."");
        } catch (IOException e) {
            System.out.println(""An error occurred while combining files: "" + e.getMessage());
        }
    }
}
",0.6084480303749407
0_Exercise17_08.java," /**
 * *17.8 (Update count) Suppose you wish to track how many times a program has been
 * executed. You can store an int to count the file. Increase the count by 1 each
 * time this program is executed. Let the program be Exercise17_08 and store the
 * count in Exercise17_08.dat.
 * <p>
 *
 */","package ch_17.exercise17_08;

import ch_17.exercise17_01.Exercise17_01;

import java.io.*;
import java.util.*;


public class Exercise17_08 {
    public static void main(String[] args) throws FileNotFoundException {
        int runs = 0;
        String[] packageParts = Exercise17_01.class.getPackage().getName().split(""\\."");
        String path = packageParts[0] + File.separator + packageParts[1] + File.separator +
                ""Exercise17_08.dat"";

        File file = new File(path);
        if (!file.exists()) {
            runs = 1;
            writeFile(runs, file);
        } else {
            runs = readFile(file);
            writeFile(++runs, file);
        }
        System.out.println(""Number of runs: "" + runs);
    }

    static int readFile(File file) {
        int i = 0;
        try (DataInputStream dIs = new DataInputStream(new FileInputStream(file))) {
            i = dIs.readInt();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(""Something went wrong reading the data file...@ -> "" + file.getName());
        }
        return i;

    }

    static void writeFile(int i, File file) {
        try (DataOutputStream das = new DataOutputStream(new FileOutputStream(file))) {
            das.writeInt(i);
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(""Something went wrong writing the data file...@ -> "" + file.getName());

        }
    }
}","import java.io.*;

public class Exercise17_08 {
    public static void main(String[] args) {
        try {
            // Open the file for reading
            FileInputStream countStream = new FileInputStream(""Exercise17_08.dat"");

            // Read the count from the file
            int count = countStream.read();

            // Close the file input stream
            countStream.close();

            // Increment the count
            count++;

            // Open the file for writing
            FileOutputStream updateStream = new FileOutputStream(""Exercise17_08.dat"");

            // Write the updated count to the file
            updateStream.write(count);

            // Close the file output stream
            updateStream.close();

            System.out.println(""This program has been executed "" + count + "" times."");
        } catch (FileNotFoundException e) {
            // File doesn't exist yet, so start count at 1 and create file
            try {
                FileOutputStream createStream = new FileOutputStream(""Exercise17_08.dat"");
                createStream.write(1);
                createStream.close();
                System.out.println(""This program has been executed 1 time."");
            } catch (IOException ex) {
                System.out.println(""Error creating count file: "" + ex.getMessage());
            }
        } catch (IOException e) {
            System.out.println(""Error updating count file: "" + e.getMessage());
        }
    }
}
",2,"import java.io.*;

public class Exercise17_08 {
    public static void main(String[] args) {
        // Declare variables
        int executionCount = 0; // Initialize count to 0
        String fileName = ""Exercise17_08.dat""; // Specify the file name
        
        // Try to read the count from the file
        try {
            File file = new File(fileName);
            if (file.exists()) {
                FileInputStream fileInput = new FileInputStream(file);
                ObjectInputStream objectInput = new ObjectInputStream(fileInput);
                executionCount = (int) objectInput.readObject();
                objectInput.close();
            }
        } catch (IOException | ClassNotFoundException e) {
            System.err.println(""Error reading the count from file: "" + e.getMessage());
        }
        
        // Increase the count by 1
        executionCount++;
        
        // Display the count
        System.out.println(""This program has been executed "" + executionCount + "" times."");
        
        // Try to write the updated count to the file
        try {
            FileOutputStream fileOutput = new FileOutputStream(fileName);
            ObjectOutputStream objectOutput = new ObjectOutputStream(fileOutput);
            objectOutput.writeObject(executionCount);
            objectOutput.close();
        } catch (IOException e) {
            System.err.println(""Error writing the count to file: "" + e.getMessage());
        }
    }
}
",0.5691195236069757
0_Exercise17_01.java," /**
 * *17.1 (Create a text file) Write a program to create a file named Exercise17_01.txt if
 * it does not exist. Append new data to it if it already exists. Write 100 integers
 * created randomly into the file using text I/O. Integers are separated by a space.
 *
 */","package ch_17.exercise17_01;

import java.io.*;
import java.util.Random;


public class Exercise17_01 {
    public static void main(String[] args) {
        String[] packageParts = Exercise17_01.class.getPackage().getName().split(""\\."");
        String filePath = packageParts[0] + File.separator + packageParts[1] + File.separator +
                        ""Exercise17_01.txt"";
        File file = new File(filePath);
        PrintWriter printWriter = null;
        try {
            if (file.exists()) {
                printWriter = new PrintWriter(new FileOutputStream(new File(filePath), false));
            } else {
                printWriter = new PrintWriter(file);
            }
            System.out.println(""Starting write out random Integer to: "" + file.getAbsolutePath());
            StringBuilder sb = new StringBuilder();
            Random random = new Random();

            for (int i = 0; i < 100; i++) {
                int num = random.nextInt(100);
                sb.append(num).append("" "");
            }
            printWriter.write(sb.toString());
            printWriter.close();
            System.out.println(""Write out completed successfully."");


        } catch (FileNotFoundException e) {
            e.printStackTrace();
            System.out.println(""FileNotFoundException occurred."");
        }


    }


}
","import java.io.*;
import java.util.Random;

public class Exercise17_01 {
    public static void main(String[] args) {
        try {
            // Open the file for appending or create a new file if it doesn't exist
            FileWriter fileWriter = new FileWriter(""Exercise17_01.txt"", true);

            // Write 100 random integers to the file, separated by spaces
            Random random = new Random();
            for (int i = 0; i < 100; i++) {
                int num = random.nextInt(100);
                fileWriter.write(num + "" "");
            }

            // Close the file writer
            fileWriter.close();

            System.out.println(""Data written to file."");
        } catch (IOException e) {
            System.out.println(""Error writing to file: "" + e.getMessage());
        }
    }
}
",3,"import java.io.*;
import java.util.Random;

public class Exercise17_01 {

    public static void main(String[] args) {
        // Define the file name
        String fileName = ""Exercise17_01.txt"";

        // Create a File object
        File file = new File(fileName);

        // Check if the file exists
        if (file.exists()) {
            System.out.println(""File already exists. Appending data..."");
        } else {
            System.out.println(""File does not exist. Creating a new file..."");
        }

        try {
            // Create a FileWriter with append mode
            FileWriter fileWriter = new FileWriter(file, true);

            // Create a BufferedWriter for efficient writing
            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);

            // Create a Random object to generate random integers
            Random random = new Random();

            // Write 100 random integers to the file
            for (int i = 0; i < 100; i++) {
                int randomInt = random.nextInt(1000); // Generate a random integer between 0 and 999
                String intString = Integer.toString(randomInt); // Convert integer to String
                bufferedWriter.write(intString); // Write the integer to the file
                bufferedWriter.write("" ""); // Add a space to separate integers
            }

            // Close the BufferedWriter to save changes
            bufferedWriter.close();

            System.out.println(""Data appended successfully."");
        } catch (IOException e) {
            System.err.println(""An error occurred: "" + e.getMessage());
        }
    }
}
",0.5609264853977844
0_Exercise17_06.java," /**
 * *17.6 (Store Loan objects) The Loan class in Listing 10.2 does not implement
 * Serializable.
 * <p>
 * Rewrite the Loan class to implement Serializable. Write
 * a program that creates five Loan objects and stores them in a file named
 * Exercise17_06.dat.
 * <p>
 *
 */ /**
     * The entry point of application.
     *
     * @param args the input arguments
     */ /**
     * Exercise25_01 loan objects boolean.
     *
     * @param loans the loans
     * @param file  the file
     * @return the boolean
     */ /**
     * Write loans to file.
     *
     * @param loans the loans
     * @param file  the file
     * @throws FileNotFoundException the file not found exception
     */","package ch_17.exercise17_06;

import ch_17.exercise17_01.Exercise17_01;

import java.io.*;
import java.util.Arrays;


public class Exercise17_06 {
    
    public static void main(String[] args) {
        String[] packageParts = Exercise17_01.class.getPackage().getName().split(""\\."");
        String path = packageParts[0] + File.separator + packageParts[1] + File.separator +
                        ""Exercise17_06"" +
                        "".dat"";


        File outFile = new File(path);

        Loan[] loans = new Loan[5];
        loans[0] = new Loan(6.5, 10, 1000);
        loans[1] = new Loan(4.7, 10, 1000);
        loans[2] = new Loan(3.9, 10, 1000);
        loans[3] = new Loan(11.5, 10, 1000);
        loans[4] = new Loan(2.5, 10, 1000);
        boolean success = false;

        try {
            writeLoansToFile(outFile, loans);
            success = true;
        } catch (FileNotFoundException fileNotFoundException) {
            fileNotFoundException.printStackTrace();
            System.out.println(""File not found."");
        }
        if (success) {
            testLoanObjects(new File(path), loans);
        }

    }

    
    public static void testLoanObjects(File file, Loan... loans) {
        try (ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(file))) {
            Loan[] pLoans = (Loan[]) objectInputStream.readObject();
            System.out.println(""Reading loans... these are the loans that were read: "");
            Arrays.asList(pLoans).forEach(ploan -> System.out.println(ploan.toString()));

        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(""Exception reading file."");
        }
    }

    
    public static void writeLoansToFile(File file, Loan... loans) throws FileNotFoundException {
        try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(file))) {
            outputStream.writeObject(loans);
            System.out.println(""Wrote these loans to file: "");
            Arrays.asList(loans).forEach(loan -> System.out.println(loan.toString()));

        } catch (IOException ioException) {
            ioException.printStackTrace();
        }
    }
}","import java.io.Serializable;

public class Loan implements Serializable {

    private static final long serialVersionUID = 1L;

    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    
    public Loan(double annualInterestRate, int numberOfYears, double loanAmount) {
        this.annualInterestRate = annualInterestRate;
        this.numberOfYears = numberOfYears;
        this.loanAmount = loanAmount;
    }
    
    public double getAnnualInterestRate() {
        return annualInterestRate;
    }
    
    public void setAnnualInterestRate(double annualInterestRate) {
        this.annualInterestRate = annualInterestRate;
    }
    
    public int getNumberOfYears() {
        return numberOfYears;
    }
    
    public void setNumberOfYears(int numberOfYears) {
        this.numberOfYears = numberOfYears;
    }
    
    public double getLoanAmount() {
        return loanAmount;
    }
    
    public void setLoanAmount(double loanAmount) {
        this.loanAmount = loanAmount;
    }
    
    public double getMonthlyPayment() {
        // calculate monthly payment
    }
    
    public double getTotalPayment() {
        // calculate total payment
    }
    
    public String getLoanDate() {
        // return loan date
    }
}
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

public class Main {
    public static void main(String[] args) {
        // create Loan objects
        Loan loan1 = new Loan(0.05, 10, 10000);
        Loan loan2 = new Loan(0.07, 15, 20000);
        Loan loan3 = new Loan(0.03, 5, 5000);
        Loan loan4 = new Loan(0.06, 20, 30000);
        Loan loan5 = new Loan(0.08, 25, 40000);
        
        // store Loan objects in file
        try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(""Exercise17_06.dat""))) {
            output.writeObject(loan1);
            output.writeObject(loan2);
            output.writeObject(loan3);
            output.writeObject(loan4);
            output.writeObject(loan5);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
",3,"import java.io.*;
import java.util.ArrayList;

// Define the Loan class implementing Serializable
class Loan implements Serializable {
    private double annualInterestRate;
    private int numberOfYears;
    private double loanAmount;
    private java.util.Date loanDate;

    public Loan() {
        this(2.5, 1, 1000);
    }

    public Loan(double annualInterestRate, int numberOfYears, double loanAmount) {
        this.annualInterestRate = annualInterestRate;
        this.numberOfYears = numberOfYears;
        this.loanAmount = loanAmount;
        loanDate = new java.util.Date();
    }

    // Getters and setters for the fields (omitted for brevity)

    public double getMonthlyPayment() {
        // Calculate and return the monthly payment
        double monthlyInterestRate = annualInterestRate / 1200;
        double monthlyPayment = loanAmount * monthlyInterestRate /
                (1 - (1 / Math.pow(1 + monthlyInterestRate, numberOfYears * 12)));
        return monthlyPayment;
    }

    public double getTotalPayment() {
        // Calculate and return the total payment
        double totalPayment = getMonthlyPayment() * numberOfYears * 12;
        return totalPayment;
    }
}

public class Exercise17_06 {
    public static void main(String[] args) {
        // Create an ArrayList to store Loan objects
        ArrayList<Loan> loans = new ArrayList<>();

        // Create five Loan objects and add them to the ArrayList
        loans.add(new Loan(5.0, 3, 1500));
        loans.add(new Loan(4.5, 2, 2000));
        loans.add(new Loan(6.2, 4, 2500));
        loans.add(new Loan(3.8, 5, 1800));
        loans.add(new Loan(4.0, 3, 2200));

        // Write the ArrayList of Loan objects to the file
        writeLoansToFile(loans, ""Exercise17_06.dat"");

        System.out.println(""Loan objects have been written to Exercise17_06.dat."");
    }

    // Method to write Loan objects to a file
    public static void writeLoansToFile(ArrayList<Loan> loans, String file) {
        try {
            // Create an ObjectOutputStream to write objects to the file
            ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(file));

            // Write the ArrayList of Loan objects to the file
            output.writeObject(loans);

            // Close the ObjectOutputStream
            output.close();
        } catch (IOException e) {
            System.err.println(""Error writing to file: "" + e.getMessage());
        }
    }
}
",0.5652392947103274
0_Exercise10_26.java," /**
 * 10.26 (Calculator) Revise Listing 7.9, Calculator.java, to accept an expression as
 * a string in which the operands and operator are separated by zero or more
 * spaces. For example, 3+4 and 3 + 4 are acceptable expressions.
 */","package ch_10;


public class Exercise10_26 {
    public static void main(String[] args) {

        StringBuilder str = new StringBuilder();

        for (String arg : args) {
            str.append(arg);
        }

        String str2 = str.toString().replaceAll("" "", """");

        str2 = str2.replaceAll(""[+]"", ""%+%"");
        str2 = str2.replaceAll(""[-]"", ""%-%"");
        str2 = str2.replaceAll(""[.]"", ""%.%"");
        str2 = str2.replaceAll(""[/]"", ""%/%"");


        args = str2.split(""%"");

        int result = 0;

        switch (args[1].charAt(0)) {

            case '+':
                result = Integer.parseInt(args[0]) + Integer.parseInt(args[2]);
                break;

            case '-':
                result = Integer.parseInt(args[0]) - Integer.parseInt(args[2]);
                break;

            case '.':
                result = Integer.parseInt(args[0]) * Integer.parseInt(args[2]);
                break;

            case '/':
                result = Integer.parseInt(args[0]) / Integer.parseInt(args[2]);
                break;

        }
        System.out.println(args[0] + ' ' + args[1] + ' ' + args[2] + "" = "" + result);
    }

}","import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter an expression
        System.out.print(""Enter an expression: "");
        String expression = input.nextLine().replaceAll("" "", """");

        // Find the index of the first operator
        int index = 0;
        while (index < expression.length() && !isOperator(expression.charAt(index))) {
            index++;
        }

        // Extract the first operand
        double operand1 = Double.parseDouble(expression.substring(0, index));

        // Extract the operator
        char operator = expression.charAt(index);

        // Extract the second operand
        double operand2 = Double.parseDouble(expression.substring(index + 1));

        // Perform the calculation
        double result = 0;
        switch (operator) {
            case '+':
                result = operand1 + operand2;
                break;
            case '-':
                result = operand1 - operand2;
                break;
            case '*':
                result = operand1 * operand2;
                break;
            case '/':
                result = operand1 / operand2;
                break;
        }

        // Display the result
        System.out.println(expression + "" = "" + result);
    }

    public static boolean isOperator(char ch) {
        return ch == '+' || ch == '-' || ch == '*' || ch == '/';
    }
}
",3,"import java.util.Scanner;

public class Calculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter an expression (e.g., 3 + 4 or 3+4): "");
        String expression = input.nextLine();

        // Remove spaces from the expression
        expression = expression.replace("" "", """");

        // Initialize variables to store operands and operator
        double operand1 = 0;
        double operand2 = 0;
        char operator = ' ';

        // Find the operator in the expression
        for (int i = 0; i < expression.length(); i++) {
            char ch = expression.charAt(i);
            if (ch == '+' || ch == '-' || ch == '*' || ch == '/') {
                operator = ch;
                operand1 = Double.parseDouble(expression.substring(0, i));
                operand2 = Double.parseDouble(expression.substring(i + 1));
                break;
            }
        }

        // Perform the calculation based on the operator
        double result = 0;
        switch (operator) {
            case '+':
                result = operand1 + operand2;
                break;
            case '-':
                result = operand1 - operand2;
                break;
            case '*':
                result = operand1 * operand2;
                break;
            case '/':
                if (operand2 != 0) {
                    result = operand1 / operand2;
                } else {
                    System.out.println(""Error: Division by zero"");
                    System.exit(1);
                }
                break;
            default:
                System.out.println(""Error: Invalid operator"");
                System.exit(1);
        }

        // Display the result
        System.out.println(""Result: "" + operand1 + "" "" + operator + "" "" + operand2 + "" = "" + result);

        input.close();
    }
}
",0.6512720156555774
0_Exercise10_06.java," /**
 * *10.6 (Displaying the prime numbers) Write a program that displays all the prime
 * numbers less than 120 in decreasing order. Use the StackOfIntegers class
 * to store the prime numbers (e.g., 2, 3, 5, ...) and retrieve and display them in
 * reverse order.
 */","package ch_10;

import ch_10.exercise10_05.StackOfIntegers;


public class Exercise10_06 {
    public static void main(String[] args) {
        StackOfIntegers stackOfIntegers = new StackOfIntegers();
        StackOfIntegers reverseStack = new StackOfIntegers();
        int n = 120;
        for (int i = 2; i < n; i++) {
            if (checkPrime(i)) {
                stackOfIntegers.push(i);
            }
        }

        System.out.println(""All prime numbers less than 120, in reverse order: "");
        while (stackOfIntegers.getSize() > 1) {
            System.out.print(stackOfIntegers.pop() + "", "");
        }
        System.out.print(stackOfIntegers.pop());
    }

    static boolean checkPrime(int num) {
        boolean prime = true;
        for (int f = 2; f * f <= num; f++) {
            if (num % f == 0) {
                prime = false;
                break;
            }
        }
        return prime;

    }
}
","public class PrimeNumbers {
    public static void main(String[] args) {
        StackOfIntegers stack = new StackOfIntegers();
        for (int i = 2; i < 120; i++) {
            if (isPrime(i)) {
                stack.push(i);
            }
        }
        System.out.println(""Prime numbers less than 120 in decreasing order:"");
        while (!stack.isEmpty()) {
            System.out.print(stack.pop() + "" "");
        }
    }

    public static boolean isPrime(int number) {
        for (int i = 2; i <= Math.sqrt(number); i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return true;
    }
}
",3,"public class PrimeNumbers {
    public static void main(String[] args) {
        StackOfIntegers primeStack = new StackOfIntegers(); // Creating a stack to store prime numbers
        
        // Loop through numbers from 2 to 119
        for (int i = 2; i < 120; i++) {
            if (isPrime(i)) {
                primeStack.push(i); // If it's prime, push it onto the stack
            }
        }
        
        System.out.println(""Prime numbers less than 120 in decreasing order:"");
        
        // Pop and display prime numbers from the stack in reverse order
        while (!primeStack.isEmpty()) {
            System.out.print(primeStack.pop() + "" "");
        }
    }
    
    // Method to check if a number is prime
    public static boolean isPrime(int num) {
        if (num <= 1) {
            return false;
        }
        
        for (int i = 2; i < num; i++) {
            if (num % i == 0) {
                return false; // It's not prime if it's divisible by any number other than 1 and itself
            }
        }
        
        return true; // It's prime if it's not divisible by any number other than 1 and itself
    }
}
",0.6652512384996462
0_Exercise10_16.java," /**
 * 10.16 (Divisible by 2 or 3) Find the first ten numbers with 50 decimal digits that are
 * divisible by 2 or 3.
 */","package ch_10;

import java.math.BigDecimal;


public class Exercise10_16 {
    public static void main(String[] args) {
        BigDecimal bigDecimal = new BigDecimal(""10000000000000000000000000000000000000000000000000"");
        int count = 0;
        while (count < 10) {
            BigDecimal remainder2 = bigDecimal.remainder(BigDecimal.valueOf(2L));
            if (remainder2.intValue() == 0) {
                System.out.print(""\n"" + bigDecimal.toPlainString());
                System.out.print("" divided by 2 = "");
                BigDecimal res = bigDecimal.divide(BigDecimal.valueOf(2L));
                System.out.print(res.toPlainString());
                count++;
            }

            BigDecimal remainder3 = bigDecimal.remainder(BigDecimal.valueOf(3L));
            if (remainder3.intValue() == 0) {
                System.out.print(""\n"" + bigDecimal.toPlainString());
                System.out.print("" divided by 3 = "");
                BigDecimal res = bigDecimal.divide(BigDecimal.valueOf(3L));
                System.out.print(res.toPlainString());
                count++;
            }

            bigDecimal = bigDecimal.add(BigDecimal.ONE);
        }
    }

}
","import java.math.BigDecimal;

public class Main {
    public static void main(String[] args) {
        int count = 0;
        BigDecimal number = new BigDecimal(""10000000000000000000000000000000000000000000000000""); // 50-digit number
        
        while (count < 10) {
            if (number.remainder(new BigDecimal(""2"")).equals(BigDecimal.ZERO) ||
                    number.remainder(new BigDecimal(""3"")).equals(BigDecimal.ZERO)) {
                System.out.println(number);
                count++;
            }
            number = number.add(BigDecimal.ONE);
        }
    }
}
",3,"# Importing the necessary libraries (even though we don't really need any)
import math

# Initializing variables
count = 0
number = 1
result_numbers = []

# Looping until we find the first ten numbers
while count < 10:
    # Converting the number to a string with 50 decimal digits
    number_str = str(number)
    while len(number_str) < 50:
        number_str = '0' + number_str

    # Converting the string back to an integer
    number = int(number_str)

    # Checking if the number is divisible by 2 or 3
    if number % 2 == 0 or number % 3 == 0:
        result_numbers.append(number)
        count += 1

    # Incrementing the number
    number += 1

# Printing the result numbers
print(""The first ten numbers with 50 decimal digits divisible by 2 or 3 are:"")
for num in result_numbers:
    print(num)
",0.3461224489795918
0_Exercise10_20.java," /**
 * 10.20 (Approximate e) Programming Exercise 5.26 approximates e using the following
 * series:
 * In order to get better precision, use BigDecimal with 25 digits of precision in
 * the computation. Write a program that displays the e value for i = 100, 200, . . .,
 * and 1000.
 */","package ch_10;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;


public class Exercise10_20 {
    public static void main(String[] args) {
        BigDecimal E = BigDecimal.valueOf(1.0);
        for (int i = 100; i <= 1000; i++) {
            BigDecimal numerator = BigDecimal.valueOf(1.0);
            BigDecimal denominator = new BigDecimal(factorial(i));
            BigDecimal result = numerator.divide(denominator, 25, BigDecimal.ROUND_UP);
            E = E.add(result);
            if (i % 100 == 0)
                System.out.println(E);

        }

    }

    public static BigInteger factorial(int x) {
        BigInteger temp = new BigInteger(""1"");
        for (int i = 1; i <= x; i++)
            temp = temp.multiply(BigInteger.valueOf(i));
        return temp;
    }
}

","import java.math.BigDecimal;

public class ApproximateE {
    public static void main(String[] args) {
        for (int i = 100; i <= 1000; i += 100) {
            BigDecimal e = BigDecimal.ZERO;
            for (int j = 0; j <= i; j++) {
                e = e.add(BigDecimal.ONE.divide(factorial(j), 25, BigDecimal.ROUND_HALF_UP));
            }
            System.out.printf(""e for i=%d: %s\n"", i, e);
        }
    }
    
    public static BigDecimal factorial(int n) {
        BigDecimal result = BigDecimal.ONE;
        for (int i = 2; i <= n; i++) {
            result = result.multiply(BigDecimal.valueOf(i));
        }
        return result;
    }
}
",3,"import java.math.BigDecimal;
import java.math.MathContext;

public class ApproximateE {

    public static void main(String[] args) {
        System.out.println(""Approximating the value of e:"");

        int[] iValues = {100, 200, 300, 400, 500, 600, 700, 800, 900, 1000};
        for (int i : iValues) {
            BigDecimal eApproximation = calculateE(i);
            System.out.println(""For i = "" + i + "", e ≈ "" + eApproximation.toPlainString());
        }
    }

    public static BigDecimal calculateE(int n) {
        BigDecimal eApprox = BigDecimal.ONE; // Initializing e to 1
        BigDecimal factorial = BigDecimal.ONE; // Initializing factorial to 1

        for (int i = 1; i <= n; i++) {
            factorial = factorial.multiply(BigDecimal.valueOf(i)); // Compute factorial
            BigDecimal term = BigDecimal.ONE.divide(factorial, 25, BigDecimal.ROUND_HALF_UP); // Calculate term
            eApprox = eApprox.add(term); // Add term to e
        }

        return eApprox;
    }
}
",0.5391180654338549
0_Exercise10_21.java," /**
 * 10.21 (Divisible by 5 or 6) Find the first ten numbers greater than Long.MAX_VALUE
 * that are divisible by 5 or 6.
 */","package ch_10;

import java.math.BigDecimal;
import java.math.BigInteger;


public class Exercise10_21 {
    public static void main(String[] args) {
        BigInteger testNumber = BigInteger.valueOf(Long.MAX_VALUE);
        BigInteger FIVE = BigInteger.valueOf(5L);
        BigInteger SIX = BigInteger.valueOf(6L);

        int count = 0;
        while (count < 10) {
            testNumber = testNumber.add(BigInteger.ONE);

            BigInteger remainder = testNumber.remainder(FIVE);
            if (remainder.intValue() == 0) {
                System.out.print(""\n"" + testNumber.toString());
                System.out.print("" divided by 5 = "");
                BigInteger res = testNumber.divide(FIVE);
                System.out.print(res.toString());
                count++;
            }

            BigInteger remainder6 = testNumber.remainder(SIX);
            if (remainder6.intValue() == 0) {
                System.out.print(""\n"" + testNumber.toString());
                System.out.print("" divided by 6 = "");
                BigInteger res = testNumber.divide(SIX);
                System.out.print(res.toString());
                count++;
            }

        }
    }
}","import java.math.BigInteger;

public class DivisibleByFiveOrSix {
    public static void main(String[] args) {
        BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);
        BigInteger number = maxLong.add(BigInteger.ONE); // Start with the number after Long.MAX_VALUE

        int count = 0;
        while (count < 10) {
            if (number.remainder(BigInteger.valueOf(5)).equals(BigInteger.ZERO)
                    || number.remainder(BigInteger.valueOf(6)).equals(BigInteger.ZERO)) {
                System.out.println(number);
                count++;
            }
            number = number.add(BigInteger.ONE);
        }
    }
}",3,"public class DivisibleBy5Or6 {
    public static void main(String[] args) {
        long currentNumber = Long.MAX_VALUE + 1; // Start with the number right after Long.MAX_VALUE
        int foundNumbers = 0; // Keep track of how many numbers we've found
        
        while (foundNumbers < 10) {
            if (currentNumber % 5 == 0 || currentNumber % 6 == 0) { // Check if the number is divisible by 5 or 6
                System.out.println(""Number "" + foundNumbers + "": "" + currentNumber);
                foundNumbers++; // Increment the count of found numbers
            }
            
            currentNumber++; // Move on to the next number
        }
    }
}
",0.5193370165745856
0_Exercise10_17.java," /**
 * 10.17 (Square numbers) Find the first ten square numbers that are greater than
 * Long.MAX_VALUE. A square number is a number in the form of n2. For example, 4, 9, and 16 are square numbers.
 * Find an efficient approach to run your program fast.
 */","package ch_10;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Arrays;


public class Exercise10_17 {
    public static void main(String[] args) {
        BigInteger maxLongVal = BigInteger.valueOf(Long.MAX_VALUE);
        int count = 0;
        long rootNum = (long) Math.sqrt(maxLongVal.doubleValue());
        BigInteger root = BigInteger.valueOf(rootNum);
        BigInteger[] result = new BigInteger[10];
        while (count < 10) {
            root = root.add(BigInteger.ONE);
            BigInteger n2 = root.pow(2);
            if (n2.compareTo(maxLongVal) > 0) {
                result[count] = n2;
                count++;
            }

        }
        System.out.println(""Long.MAX_VALUE = "" + Long.MAX_VALUE);
        System.out.println(""The square numbers greater than Long.MAX_VALUE are: "");
        System.out.println(Arrays.toString(result));


    }
}
","import java.math.BigInteger;

public class SquareNumbers {
    public static void main(String[] args) {
        BigInteger max = BigInteger.valueOf(Long.MAX_VALUE);
        BigInteger low = BigInteger.valueOf(1);
        BigInteger high = max.sqrt();

        for (int i = 0; i < 10; i++) {
            BigInteger mid = (low.add(high)).shiftRight(1);
            BigInteger square = mid.multiply(mid);

            if (square.compareTo(max) > 0) {
                System.out.println(square);
                low = mid.add(BigInteger.ONE);
            } else {
                high = mid.subtract(BigInteger.ONE);
            }
        }
    }
}
",3,"import java.util.ArrayList;

public class SquareNumbersFinder {

    public static void main(String[] args) {

        long currentNumber = 1;
        int foundSquares = 0;

        ArrayList<Long> squareNumbers = new ArrayList<>();

        while (foundSquares < 10) {
            long square = currentNumber * currentNumber;

            if (square > Long.MAX_VALUE) {
                squareNumbers.add(square);
                foundSquares++;
            }

            currentNumber++; // Increment current number
        }

        System.out.println(""The first ten square numbers greater than Long.MAX_VALUE are:"");
        for (long square : squareNumbers) {
            System.out.println(square);
        }
    }
}
",0.46808510638297873
0_Exercise10_19.java," /**
 * 10.19 (Mersenne prime) A prime number is called a Mersenne prime if it can be written in the form 2^p - 1 for some
 * positive integer p. Write a program that finds
 * all Mersenne primes with p … 100 and displays the output as shown below.
 * (Hint: You have to use BigInteger to store the number, because it is too big to
 * be stored in long. Your program may take several hours to run.)
 */","package ch_10;

import java.math.BigInteger;


public class Exercise10_19 {
    static int P = 2;
    static BigInteger TWO = BigInteger.valueOf(2L);

    public static void main(String[] args) {
        System.out.print(""p     2^p - 1"");

        while (P <= 100) {
            BigInteger mersennePrime = TWO.pow(P).subtract(BigInteger.ONE);
            if (mersennePrime.isProbablePrime(1)) {
                System.out.print(""\n"" + P + ""     "" + mersennePrime.toString());
                System.out.println();
                P++;
            }
        }
    }

}

","import java.math.BigInteger;

public class MersennePrimes {
    public static void main(String[] args) {
        BigInteger two = BigInteger.valueOf(2);
        for (int p = 2; p <= 100; p++) {
            BigInteger mersenne = two.pow(p).subtract(BigInteger.ONE);
            if (isPrime(mersenne)) {
                System.out.printf(""M%d is prime%n"", p);
            }
        }
    }
    
    public static boolean isPrime(BigInteger n) {
        if (n.compareTo(BigInteger.ONE) <= 0) {
            return false;
        }
        if (n.compareTo(BigInteger.TWO) == 0) {
            return true;
        }
        if (n.mod(BigInteger.TWO).equals(BigInteger.ZERO)) {
            return false;
        }
        BigInteger sqrt = n.sqrt();
        for (BigInteger i = BigInteger.valueOf(3); i.compareTo(sqrt) <= 0; i = i.add(BigInteger.TWO)) {
            if (n.mod(i).equals(BigInteger.ZERO)) {
                return false;
            }
        }
        return true;
    }
}
",3,"import java.math.BigInteger;

public class MersennePrimeFinder {

    public static void main(String[] args) {
        System.out.println(""Mersenne Primes with p <= 100:"");
        
        for (int p = 2; p <= 100; p++) {
            BigInteger mersenneNumber = BigInteger.valueOf(2).pow(p).subtract(BigInteger.ONE);
            
            if (isPrime(mersenneNumber)) {
                System.out.println(""Mersenne Prime for p = "" + p + "": "" + mersenneNumber);
            }
        }
    }

    public static boolean isPrime(BigInteger num) {
        if (num.compareTo(BigInteger.ONE) <= 0) {
            return false;
        }

        for (BigInteger i = BigInteger.valueOf(2); i.compareTo(num.sqrt()) <= 0; i = i.add(BigInteger.ONE)) {
            if (num.mod(i).equals(BigInteger.ZERO)) {
                return false;
            }
        }

        return true;
    }
}
",0.7649074708704592
0_Exercise10_15.java," /**
 * *10.15 (Geometry: the bounding rectangle) A bounding rectangle is the minimum rectangle
 * that encloses a set of points in a two-dimensional plane, as shown in
 * Figure 10.24d. Write a method that returns a bounding rectangle for a set of
 * points in a two-dimensional plane, as follows:
 * public static MyRectangle2D getRectangle(double[][] points)
 * <p>
 * The Rectangle2D class is defined in Programming Exercise 10.13.
 * Write a test program that prompts the user to enter five points and displays the bounding
 * rectangle’s center, width, and height. Here is a sample run:
 * Enter five points: 1.0 2.5 3 4 5 6 7 8 9 10
 * The bounding rectangle's center (5.0, 6.25), width 8.0, height 7.5
 * <p>
 * About Bounding Rectangle:
 * The top of the rectangle is determined by the y-coordinate of the top-most point - point B
 * The bottom of the rectangle is determined by the y-coordinate of the lowest point - point D
 * The left side of the rectangle is determined by the x-coordinate of the leftmost point - point A
 * The right of the rectangle is determined by the x-coordinate of the rightmost point - point C
 */","package ch_10;

import ch_10.exercise10_13.MyRectangle2D;

import java.util.Scanner;


public class Exercise10_15 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter five points:"");

        double[][] pts = new double[5][2];
        for (int i = 0; i < pts.length; i++) {
            for (int j = 0; j < pts[i].length; j++) {
                pts[i][j] = in.nextDouble();
            }
        }
        MyRectangle2D rectangle2D = getRectangle(pts);
        System.out.print(""\nThe bounding rectangle's center ("" + rectangle2D.getX() + "","" + rectangle2D.getY() + "")"" +
                "","" + "" width: "" + rectangle2D.getWidth() + "","" + "" height: "" + rectangle2D.getHeight() + "")"");
    }


    public static MyRectangle2D getRectangle(double[][] points) {
        double[] lowestPoint = lowestPoint(points);
        double[] highestPoint = highestPoint(points);
        double[] leftMostPoint = leftMostPoint(points);
        double[] rightMostPoint = rightMostPoint(points);

        double height = Math.abs(highestPoint[1]) - Math.abs(lowestPoint[1]);
        double width = Math.abs(rightMostPoint[0]) - Math.abs(leftMostPoint[0]);
        MyRectangle2D resultRectangle2D = new MyRectangle2D();
        resultRectangle2D.setHeight(height);
        resultRectangle2D.setWidth(width);
        double centerX = leftMostPoint[0] + (width / 2);
        double centerY = lowestPoint[1] + (height / 2);
        resultRectangle2D.setX(centerX);
        resultRectangle2D.setY(centerY);

        return resultRectangle2D;

    }

    static double[] lowestPoint(double[][] pts) {
        double[] lowPt = pts[0];
        for (int n = 1; n < pts.length; n++) {
            lowPt = pts[n][1] < lowPt[1] ? pts[n] : lowPt;
        }
        return lowPt;
    }

    static double[] highestPoint(double[][] pts) {
        double[] hiPt = pts[0];
        for (int n = 1; n < pts.length; n++) {
            hiPt = pts[n][1] > hiPt[1] ? pts[n] : hiPt;
        }
        return hiPt;
    }

    static double[] rightMostPoint(double[][] pts) {
        double[] rghtPt = pts[0];
        for (int n = 1; n < pts.length; n++) {
            rghtPt = pts[n][0] > rghtPt[0] ? pts[n] : rghtPt;
        }
        return rghtPt;
    }

    static double[] leftMostPoint(double[][] pts) {
        double[] lftPt = pts[0];
        for (int n = 1; n < pts.length; n++) {
            lftPt = pts[n][0] < lftPt[0] ? pts[n] : lftPt;
        }
        return lftPt;
    }

}
","import java.util.Scanner;

public class BoundingRectangleTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        double[][] points = new double[5][2];

        System.out.print(""Enter five points: "");
        for (int i = 0; i < 5; i++) {
            points[i][0] = input.nextDouble();
            points[i][1] = input.nextDouble();
        }

        MyRectangle2D rectangle = MyRectangle2D.getRectangle(points);

        System.out.println(""The bounding rectangle's center ("" +
                rectangle.getX() + "", "" + rectangle.getY() + ""), width "" +
                rectangle.getWidth() + "", height "" + rectangle.getHeight());
    }
}

class MyRectangle2D {
    private double x;
    private double y;
    private double width;
    private double height;

    public MyRectangle2D(double x, double y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getWidth() {
        return width;
    }

    public double getHeight() {
        return height;
    }

    public double getArea() {
        return width * height;
    }

    public double getPerimeter() {
        return 2 * (width + height);
    }

    public boolean contains(double x, double y) {
        double xDistance = Math.abs(x - this.x);
        double yDistance = Math.abs(y - this.y);
        return xDistance <= width / 2 && yDistance <= height / 2;
    }

    public boolean contains(MyRectangle2D r) {
        double xDistance = Math.abs(r.getX() - this.x);
        double yDistance = Math.abs(r.getY() - this.y);
        return xDistance + r.getWidth() / 2 <= width / 2 &&
                yDistance + r.getHeight() / 2 <= height / 2 &&
                width / 2 >= r.getWidth() / 2 &&
                height / 2 >= r.getHeight() / 2;
    }

    public boolean overlaps(MyRectangle2D r) {
        double xDistance = Math.abs(r.getX() - this.x);
        double yDistance = Math.abs(r.getY() - this.y);
        return xDistance <= (width + r.getWidth()) / 2 &&
                yDistance <= (height + r.getHeight()) / 2;
    }

    public static MyRectangle2D getRectangle(double[][] points) {
        double xMin = points[0][0];
        double xMax = points[0][0];
        double yMin = points[0][1];
        double yMax = points[0][1];

        for (int i = 1; i < points.length; i++) {
            if (points[i][0] < xMin) {
                xMin = points[i][0];
            }
            if (points[i][0] > xMax) {
                xMax = points[i][0];
            }
            if (points[i][1] < yMin) {
                yMin = points[i][1];
            }
            if (points[i][1] > yMax) {
                yMax = points[i][1];
            }
        }

        double x = (xMin + xMax) / 2;
        double y = (yMin + yMax) / 2;
        double width = xMax - xMin;
        double height = yMax - yMin;

        return new
",3,"import java.util.Scanner;

public class MyRectangle2D {
    double x;
    double y;
    double width;
    double height;

    public MyRectangle2D(double x, double y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public static MyRectangle2D getRectangle(double[][] points) {
        double minX = points[0][0];
        double minY = points[0][1];
        double maxX = points[0][0];
        double maxY = points[0][1];

        for (int i = 1; i < points.length; i++) {
            double[] point = points[i];
            double x = point[0];
            double y = point[1];

            if (x < minX) {
                minX = x;
            }
            if (x > maxX) {
                maxX = x;
            }
            if (y < minY) {
                minY = y;
            }
            if (y > maxY) {
                maxY = y;
            }
        }

        double centerX = (minX + maxX) / 2;
        double centerY = (minY + maxY) / 2;
        double rectWidth = maxX - minX;
        double rectHeight = maxY - minY;

        return new MyRectangle2D(centerX, centerY, rectWidth, rectHeight);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        double[][] points = new double[5][2];

        System.out.println(""Enter five points (x y):"");

        for (int i = 0; i < 5; i++) {
            double x = scanner.nextDouble();
            double y = scanner.nextDouble();
            points[i][0] = x;
            points[i][1] = y;
        }

        MyRectangle2D boundingRectangle = getRectangle(points);

        System.out.println(""The bounding rectangle's center ("" + boundingRectangle.x + "", "" + boundingRectangle.y +
                ""), width "" + boundingRectangle.width + "", height "" + boundingRectangle.height);
    }
}
",0.4228222109016811
0_Exercise10_25.java," /**
 * **10.25 (New string split method) The split method in the String class returns an
 * array of strings consisting of the substrings split by the delimiters. However, the
 * delimiters are not returned. Implement the following new method that returns
 * an array of strings consisting of the substrings split by the matching delimiters,
 * including the matching delimiters.
 * <p>
 * public static String[] split(String s, String regex)
 * For example, split(""ab#12#453"", ""#"") returns ab, #, 12, #, 453 in an
 * array of String, and split(""a?b?gf#e"", ""[?#]"") returns a, b, ?, b, gf,
 * #, and e in an array of String.
 */","package ch_10;

import java.util.ArrayList;
import java.util.Arrays;


public class Exercise10_25 {

    public static void main(String[] args) {
        /* Tests */
        String s = ""ab#12#453"";
        String regex = ""#"";
        String s2 = ""a?b?gf#e"";
        String regex2 = ""[?#]"";

        System.out.println(""split(\""ab#12#453\"",\""#\""): "" + Arrays.toString(split(s, regex)));
        System.out.println(""split(\""a?b?gf#e\"",\""[?#]\""): "" + Arrays.toString(split(s2, regex2)));
    }

    public static String[] split(String s, String regex) {
        ArrayList<String> splitList = new ArrayList<>();
        if (regex == null || regex.length() < 1) {
            return new String[]{""regex must not be null and length must be greater than 0""};
        }

        ArrayList<Character> splitters = new ArrayList<>();
        for (char ch : regex.toCharArray()) {
            if (ch == '[' || ch == ']') continue;
            splitters.add(ch);
        }
        String subString = """";
        for (int i = 0; i < s.length(); i++) {
            if (splitters.contains(s.charAt(i))) {
                if (subString.length() > 0) {
                    splitList.add(subString);
                    subString = """";
                }

                splitList.add(s.charAt(i) + """");
                i++;
                while (i < s.length()) {
                    if (!splitters.contains(s.charAt(i))) {
                        subString = subString.concat(s.charAt(i) + """");
                    } else {
                        splitList.add(subString);
                        subString = """";
                        splitList.add(s.charAt(i) + """");
                        break;
                    }
                    i++;
                }
            } else {
                subString = subString.concat(s.charAt(i) + """");
            }
        }
        if (subString.length() > 0) {
            splitList.add(subString);
        }
        return splitList.toArray(new String[]{});

    }
}","public static String[] split(String s, String regex) {
    List<String> parts = new ArrayList<>();
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(s);
    int lastEnd = 0;
    while (matcher.find()) {
        String part = s.substring(lastEnd, matcher.end());
        parts.add(part);
        lastEnd = matcher.end();
    }
    if (lastEnd < s.length()) {
        String
",4,"/**
 * **10.25 (New string split method) The split method in the String class returns an
 * array of strings consisting of the substrings split by the delimiters. However, the
 * delimiters are not returned. Implement the following new method that returns
 * an array of strings consisting of the substrings split by the matching delimiters,
 * including the matching delimiters.
 * <p>
 * public static String[] split(String s, String regex)
 * For example, split(""ab#12#453"", ""#"") returns ab, #, 12, #, 453 in an
 * array of String, and split(""a?b?gf#e"", ""[?#]"") returns a, b, ?, b, gf,
 * #, and e in an array of String.
 */ 

public class StringSplitter {

    // This method splits the string by the given regex and includes the matching delimiters.
    public static String[] split(String s, String regex) {
        // Let's create an array to hold the results.
        String[] result = new String[s.length()];

        // We'll use a loop to go through the string character by character.
        for (int i = 0; i < s.length(); i++) {
            // Let's check if the current character matches the regex.
            if (s.charAt(i) == regex.charAt(0)) {
                // If it does, we'll add it to the result array.
                result[i] = Character.toString(s.charAt(i));
            } else {
                // If it doesn't match, we'll concatenate it to the previous element in the result array.
                result[i] = result[i - 1] + s.charAt(i);
            }
        }

        // Now, we need to clean up the result array and remove any null or empty elements.
        String[] finalResult = new String[s.length()];
        int j = 0;
        for (int i = 0; i < result.length; i++) {
            if (result[i] != null && !result[i].isEmpty()) {
                finalResult[j++] = result[i];
            }
        }

        // Finally, let's create a new array with the correct size and copy the valid elements.
        String[] splitString = new String[j];
        for (int i = 0; i < j; i++) {
            splitString[i] = finalResult[i];
        }

        // Voila! Our imperfect and redundant string splitting method is complete.
        return splitString;
    }

    public static void main(String[] args) {
        String input1 = ""ab#12#453"";
        String input2 = ""a?b?gf#e"";

        String[] result1 = split(input1, ""#"");
        String[] result2 = split(input2, ""[?#]"");

        // Let's print the results just to make sure everything works.
        for (String str : result1) {
            System.out.print(str + "", "");
        }
        System.out.println();

        for (String str : result2) {
            System.out.print(str + "", "");
        }
        System.out.println();
    }
}
",0.20692194403534608
0_Exercise10_09.java," /**
 * Write a test program that creates a course, adds three students, removes one,
 * and displays the students in the course.
 */ /**
 * **10.9 (The Course class) Revise the Course class as follows:
 * ■ The array size is fixed in Listing 10.6. Improve it to automatically increase
 * the array size by creating a new larger array and copying the contents of the
 * current array to it.
 * ■ Implement the dropStudent method.
 * ■ Add a new method named clear() that removes all students from the
 * course.
 */ /**
     * ■ Implement the dropStudent method.
     *
     * @param student to drop
     */ /**
     * ■ Add a new method named clear() that removes all students from the
     */","package ch_10;

import java.util.Arrays;
import java.util.Objects;


public class Exercise10_09 {
    public static void main(String[] args) {
        Course statistics = new Course(""Statistics 341"");
        statistics.addStudent(""Jillian Frometorgai"");
        statistics.addStudent(""Shrezen Maticut"");
        statistics.addStudent(""Phi Wazi"");
        statistics.dropStudent(""Jillian Frometorgai"");

        System.out.println(""Students in the course "" + statistics.getCourseName() + "" are: "");
        for (String s : statistics.getStudents()) {
            if (Objects.nonNull(s)) {
                System.out.print(s + "" "");
            }
        }
    }
}

class Course {
    private String courseName;
    private String[] students = new String[100];
    private int numberOfStudents;

    public Course(String courseName) {
        this.courseName = courseName;
    }

    public void addStudent(String student) {
        if (student.length() < (numberOfStudents + 1)) {
            students = Arrays.copyOf(students, students.length * 2);
        }
        students[numberOfStudents] = student;
        numberOfStudents++;
        System.out.println(""Added student: "" + student + "" to the course: "" + getCourseName());
    }

    public String[] getStudents() {
        return students;
    }

    public int getNumberOfStudents() {
        return numberOfStudents;
    }

    public String getCourseName() {
        return courseName;
    }

    
    public void dropStudent(String student) {
        for (int i = 0; i < numberOfStudents; i++) {
            if (students[i].equals(student)) {
                students[i] = null;
                break;
            }
        }
        System.out.println(""Dropped student: "" + student + "" has been dropped from "" + getCourseName());
    }

    
    protected void clear() {
        Arrays.fill(students, null);
    }


}","public class Course {
    private String courseName;
    private String[] students = new String[1];
    private int numberOfStudents;

    public Course(String courseName) {
        this.courseName = courseName;
    }

    public String getCourseName() {
        return courseName;
    }

    public void addStudent(String student) {
        if (numberOfStudents == students.length) {
            String[] newStudents = new String[students.length * 2];
            System.arraycopy(students, 0, newStudents, 0, students.length);
            students = newStudents;
        }
        students[numberOfStudents++] = student;
    }

    public void dropStudent(String student) {
        for (int i = 0; i < numberOfStudents; i++) {
            if (students[i].equals(student)) {
                students[i] = null;
                System.arraycopy(students, i + 1, students, i, numberOfStudents - i - 1);
                numberOfStudents--;
                break;
            }
        }
    }

    public void clear() {
        students = new String[1];
        numberOfStudents = 0;
    }

    public String[] getStudents() {
        return students;
    }

    public int getNumberOfStudents() {
        return numberOfStudents;
    }
}
",4,"import java.util.Scanner;

public class TestCourse {
    public static void main(String[] args) {
        // Create a course
        Course course = new Course(""Introduction to Programming"");

        // Add three students
        course.addStudent(""Alice"");
        course.addStudent(""Bob"");
        course.addStudent(""Charlie"");

        // Display the students in the course
        System.out.println(""Students in the course:"");
        course.displayStudents();

        // Remove one student
        System.out.println(""\nRemoving student Bob..."");
        course.dropStudent(""Bob"");

        // Display the students in the course again
        System.out.println(""\nStudents in the course after removing Bob:"");
        course.displayStudents();

        // Clear all students from the course
        System.out.println(""\nClearing all students from the course..."");
        course.clear();

        // Display the students in the course one more time
        System.out.println(""\nStudents in the course after clearing:"");
        course.displayStudents();
    }
}

class Course {
    private String courseName;
    private String[] students;
    private int numberOfStudents;

    public Course(String courseName) {
        this.courseName = courseName;
        students = new String[1]; // Start with an array of size 1
        numberOfStudents = 0;
    }

    public void addStudent(String student) {
        if (numberOfStudents == students.length) {
            // If the array is full, increase its size by creating a new larger array
            String[] newStudents = new String[students.length * 2];
            System.arraycopy(students, 0, newStudents, 0, students.length);
            students = newStudents;
        }
        students[numberOfStudents] = student;
        numberOfStudents++;
    }

    public void dropStudent(String student) {
        for (int i = 0; i < numberOfStudents; i++) {
            if (students[i].equals(student)) {
                // Move students after the removed one to the left
                for (int j = i; j < numberOfStudents - 1; j++) {
                    students[j] = students[j + 1];
                }
                students[numberOfStudents - 1] = null;
                numberOfStudents--;
                break; // Exit loop after finding and removing the student
            }
        }
    }

    public void clear() {
        // Simply reset the array and the number of students
        students = new String[1];
        numberOfStudents = 0;
    }

    public void displayStudents() {
        for (int i = 0; i < numberOfStudents; i++) {
            System.out.println(students[i]);
        }
    }
}
",0.5451127819548872
0_Tax.java," /**
 * ***10.8 (Financial: the Tax class) Programming Exercise 8.12 writes a program for
 * computing taxes using arrays.
 * <p>
 * Design a class named Tax to contain the following instance data fields:
 * ■ int filingStatus: One of the four tax-filing statuses: 0—single filer, 1—
 * married filing jointly or qualifying widow(er), 2—married filing separately,
 * and 3—head of household. Use the public static constants SINGLE_FILER
 * (0), MARRIED_JOINTLY_OR_QUALIFYING_WIDOW(ER) (1), MARRIED_
 * SEPARATELY (2), HEAD_OF_HOUSEHOLD (3) to represent the statuses.
 * ■ int[][] brackets: Stores the tax brackets for each filing status.
 * ■ double[] rates: Stores the tax rates for each bracket.
 * ■ double taxableIncome: Stores the taxable income.
 * Provide the getter and setter methods for each data field and the getTax()
 * method that returns the tax.
 * Also provide a no-arg constructor and the constructor Tax(filingStatus, brackets, rates, taxableIncome).
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 */","package ch_10.exercise10_08;


//_________________________UML DIAGRAM______________________________*
/*                                                                                                                                        |
 *                                                           Tax                                                                     |
 *------------------------------------------------------------------|
 *           + SINGLE_FILER : int                                   |
 *           + MARRIED_JOINTLY_OR_QUALIFYING_WIDOW_ER : int         |
 *            + MARRIED_SEPARATELY : int                            |
 *            + HEAD_OF_HOUSEHOLD : int                             |
 *            - filingStatus : int                                  |
 *            - brackets : int[][]                                  |
 *            -  taxableIncome : double                             |
 *            - rates: double[]                                     |
 *                                                                  |
 *                                                                  |
 *------------------------------------------------------------------|
 *                     +Tax()                                                                     |
 *                     +Tax(int[][], double[],double)                       |
 *                                                                                                                                          |
 *                                         +getTax(int[],double[],double):double           |
 *                                                                                                 |
 *                                     ***** getters and setters  *****                |
 *                                                                                                                                          |
 *                                                                                                                                         |
 *__________________________________________________________________|  */

import java.util.Arrays;


public class Tax {
    public static final int SINGLE_FILER = 0;
    public static final int MARRIED_JOINTLY_OR_QUALIFYING_WIDOW_ER = 1;
    public static final int MARRIED_SEPARATELY = 2;
    public static final int HEAD_OF_HOUSEHOLD = 3;

    private int filingStatus;
    private int[][] brackets;
    private double taxableIncome;
    private double[] rates;

    public Tax() {

    }

    Tax(int filingStatus, int[][] brackets, double[] rates, double taxableIncome) {
        this.filingStatus = filingStatus;
        this.brackets = brackets;
        this.rates = rates;
        this.taxableIncome = taxableIncome;
    }

    public double getTax() {
        int[] bracket = brackets[filingStatus];

        if (taxableIncome <= bracket[0]) {
            return taxableIncome * rates[0];
        }
        int i = 1;
        double tax = bracket[0] * rates[0];
        while (i < bracket.length) {
            if (taxableIncome <= bracket[i]) {
                return tax + (taxableIncome - bracket[i - 1]) * rates[i];
            }
            tax += (bracket[i] - bracket[i - 1]) * rates[i];
            i++;
        }
        return tax + (taxableIncome - bracket[bracket.length - 1]) * rates[rates.length - 1];
    }


    public int getFilingStatus() {
        return filingStatus;
    }

    public void setFilingStatus(int filingStatus) {
        this.filingStatus = filingStatus;
    }

    public int[][] getBrackets() {
        return brackets;
    }

    public void setBrackets(int[][] brackets) {
        this.brackets = brackets;
    }

    public double getTaxableIncome() {
        return taxableIncome;
    }

    public void setTaxableIncome(double taxableIncome) {
        this.taxableIncome = taxableIncome;
    }

    public double[] getRates() {
        return rates;
    }

    public void setRates(double[] rates) {
        this.rates = rates;
    }

    private int getNumRates() {
        return rates.length;
    }

    @Override
    public String toString() {
        int[] bracket = brackets[filingStatus];
        return ""Tax{"" +
                ""filingStatus="" + filingStatus +
                "", brackets="" + Arrays.toString(bracket) +
                "", taxableIncome="" + taxableIncome +
                "", rates="" + Arrays.toString(rates) +
                '}';
    }
}
","public class Tax {
    private int filingStatus;
    private int[][] brackets;
    private double[] rates;
    private double taxableIncome;

    public static final int SINGLE_FILER = 0;
    public static final int MARRIED_JOINTLY_OR_QUALIFYING_WIDOW = 1;
    public static final int MARRIED_SEPARATELY = 2;
    public static final int HEAD_OF_HOUSEHOLD = 3;

    public Tax() {
    }

    public Tax(int filingStatus, int[][] brackets, double[] rates, double taxableIncome) {
        this.filingStatus = filingStatus;
        this.brackets = brackets;
        this.rates = rates;
        this.taxableIncome = taxableIncome;
    }

    public int getFilingStatus() {
        return filingStatus;
    }

    public void setFilingStatus(int filingStatus) {
        this.filingStatus = filingStatus;
    }

    public int[][] getBrackets() {
        return brackets;
    }

    public void setBrackets(int[][] brackets) {
        this.brackets = brackets;
    }

    public double[] getRates() {
        return rates;
    }

    public void setRates(double[] rates) {
        this.rates = rates;
    }

    public double getTaxableIncome() {
        return taxableIncome;
    }

    public void setTaxableIncome(double taxableIncome) {
        this.taxableIncome = taxableIncome;
    }

    public double getTax() {
        double tax = 0.0;
        int i;
        for (i = 0; i < brackets[filingStatus].length; i++) {
            if (taxableIncome <= brackets[filingStatus][i]) {
                break;
            }
        }
        if (i == 0) {
            tax = taxableIncome * rates[i];
        } else {
            tax = brackets[filingStatus][i - 1] * rates[i - 1];
            tax += (taxableIncome - brackets[filingStatus][i - 1]) * rates[i];
        }
        return tax;
    }
}
",4,"public class Tax {
    public static final int SINGLE_FILER = 0;
    public static final int MARRIED_JOINTLY_OR_QUALIFYING_WIDOW = 1;
    public static final int MARRIED_SEPARATELY = 2;
    public static final int HEAD_OF_HOUSEHOLD = 3;

    private int filingStatus;
    private int[][] brackets;
    private double[] rates;
    private double taxableIncome;

    // No-arg constructor
    public Tax() {
        filingStatus = 0;
        brackets = new int[4][];
        rates = new double[4];
        taxableIncome = 0.0;
    }

    // Constructor with parameters
    public Tax(int filingStatus, int[][] brackets, double[] rates, double taxableIncome) {
        this.filingStatus = filingStatus;
        this.brackets = brackets;
        this.rates = rates;
        this.taxableIncome = taxableIncome;
    }

    // Getter and setter methods for filingStatus
    public int getFilingStatus() {
        return filingStatus;
    }

    public void setFilingStatus(int filingStatus) {
        this.filingStatus = filingStatus;
    }

    // Getter and setter methods for brackets
    public int[][] getBrackets() {
        return brackets;
    }

    public void setBrackets(int[][] brackets) {
        this.brackets = brackets;
    }

    // Getter and setter methods for rates
    public double[] getRates() {
        return rates;
    }

    public void setRates(double[] rates) {
        this.rates = rates;
    }

    // Getter and setter methods for taxableIncome
    public double getTaxableIncome() {
        return taxableIncome;
    }

    public void setTaxableIncome(double taxableIncome) {
        this.taxableIncome = taxableIncome;
    }

    // Method to calculate and return the tax
    public double getTax() {
        double tax = 0.0;
        // Perform tax calculation here
        // ...
        return tax;
    }
}
",0.7128005198180637
0_Time.java," /**
 * Exercise10.1 (The Time class) Design a class named Time. The class contains:
 * <p>
 * The data fields hour, minute, and second that represent a time.
 * <p>
 * A no-arg constructor that creates a Time object for the current time.
 * (The values of the data fields will represent the current time.)
 * <p>
 * A constructor that constructs a Time object with a specified elapsed time
 * since midnight, January 1, 1970, in milliseconds. (The values of the data
 * fields will represent this time.)
 * <p>
 * A constructor that constructs a Time object with the specified hour, minute, and second.
 * <p>
 * Three getter methods for the data fields hour, minute, and second, respectively.
 * <p>
 * A method named setTime(long elapseTime) that sets a new time for the object using
 * the elapsed time. For example, if the elapsed time is 555550000 milliseconds, the
 * hour is 10, the minute is 19, and the second is 10.
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 * <p>
 * Write a test
 * program that creates three Time objects (using new Time(), new Time(555550000),
 * and new Time(5, 23, 55)) and displays their hour, minute, and second in the format
 * hour:minute:second.
 * <p>
 * (Hint: The first two constructors will extract the hour, minute, and second from
 * the elapsed time. For the no-arg constructor, the current time can be obtained using
 * System.currentTimeMillis(), as shown in Listing 2.7 ShowCurrentTime.java.
 * Assume that the time is in GMT.)
 *
 * @author Harry D.
 */","package ch_10.exercise10_01;


//_________________________UML DIAGRAM______________________________*
/*																	|
 * 							  Time  								|
 *-------------------------------------------------------------------|
 * 	-hour : long		(defaults are current time)					|
 * 															 		|
 *   -minute : long													|
 * 																	|
 * 	-second : long													|
 * 																	|
 * 	-theTime: long													|
 * 																	|
 *-------------------------------------------------------------------|
 * 	 -Time(): (System.currentTime.Millis()) 						|
 * 	 																|
 * 	 -Time(long):   												|
 * 																	|
 * 	 -Time(hour:long,min:long,second:long)							|
 * 																	|
 * 	+setTime():void													|
 *  																	|
 * 	+getHour() : long												|
 * 																	|
 * 	+getSec() : long												|
 * 																	|
 * 	+getMin() : long												|
 * 	 																|
 * 																	|
 *___________________________________________________________________|  */


public class Time {

    private long hour;
    private long min;
    private long second;

    public Time() {

        long theTime = System.currentTimeMillis();

        this.setTime(theTime);
    }

    public Time(long newTime) {

        this.setTime(newTime);

    }

    public Time(long newHour, long newMin, long newSec) {

        second = newSec;

        min = newMin;

        hour = newHour;

    }

    public void setTime(long elapsedTime) {

        hour = (((elapsedTime / 1000) / 60) / 60) % 24;

        second = (elapsedTime / 1000) % 60;

        min = ((elapsedTime / 1000) / 60) % 60;


    }

    public long getHour() {

        return hour;

    }

    public long getMin() {

        return min;
    }

    public long getSec() {

        return second;
    }


}
","public class Time {
    private int hour;
    private int minute;
    private int second;

    public Time() {
        this(System.currentTimeMillis());
    }

    public Time(long elapsedTime) {
        setTime(elapsedTime);
    }

    public Time(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

    public int getHour() {
        return hour;
    }

    public int getMinute() {
        return minute;
    }

    public int getSecond() {
        return second;
    }

    public void setTime(long elapsedTime) {
        long totalSeconds = elapsedTime / 1000;
        second = (int) (totalSeconds % 60);
        long totalMinutes = totalSeconds / 60;
        minute = (int) (totalMinutes % 60);
        long totalHours = totalMinutes / 60;
        hour = (int) (totalHours % 24);
    }

    @Override
    public String toString() {
        return String.format(""%02d:%02d:%02d"", hour, minute, second);
    }
}
",4,"// Let's create our Time class
public class Time {
    private int hour;
    private int minute;
    private int second;

    // First, we'll create a no-arg constructor
    public Time() {
        // We need to get the current time in milliseconds
        long currentTimeInMillis = System.currentTimeMillis();

        // Let's calculate the hour, minute, and second
        this.hour = (int) (currentTimeInMillis / 3600000) % 24;
        this.minute = (int) (currentTimeInMillis / 60000) % 60;
        this.second = (int) (currentTimeInMillis / 1000) % 60;
    }

    // Now, we'll create a constructor that takes elapsed time in milliseconds
    public Time(long elapsedTime) {
        // Similar to the no-arg constructor, let's calculate the time components
        this.hour = (int) (elapsedTime / 3600000) % 24;
        this.minute = (int) (elapsedTime / 60000) % 60;
        this.second = (int) (elapsedTime / 1000) % 60;
    }

    // We'll create another constructor for specifying hour, minute, and second
    public Time(int hour, int minute, int second) {
        // Here, we'll just set the provided values
        this.hour = hour;
        this.minute = minute;
        this.second = second;
    }

    // Now, let's create getter methods for hour, minute, and second
    public int getHour() {
        return hour;
    }

    public int getMinute() {
        return minute;
    }

    public int getSecond() {
        return second;
    }

    // We also need a method to set the time using elapsed time
    public void setTime(long elapsedTime) {
        this.hour = (int) (elapsedTime / 3600000) % 24;
        this.minute = (int) (elapsedTime / 60000) % 60;
        this.second = (int) (elapsedTime / 1000) % 60;
    }

    // Now, let's display the time in the format ""hour:minute:second""
    public String toString() {
        return String.format(""%02d:%02d:%02d"", hour, minute, second);
    }

    // Finally, let's create a test program
    public static void main(String[] args) {
        // Create Time objects using different constructors
        Time currentTime = new Time();
        Time elapsed = new Time(555550000);
        Time specified = new Time(5, 23, 55);

        // Display their time values
        System.out.println(""Current Time: "" + currentTime);
        System.out.println(""Elapsed Time: "" + elapsed);
        System.out.println(""Specified Time: "" + specified);
    }
}
",0.4658553076402975
0_Exercise10_23.java," /**
 * **10.23 (Implement the String class) The String class is provided in the Java library.
 * Provide your own implementation for the following methods (name the new class MyString2):
 * public MyString2(String s);
 * public int compare(String s);
 * public MyString2 substring(int begin);
 * public MyString2 toUpperCase();
 * public char[] toChars();
 * public static MyString2 valueOf(boolean b);
 */","package ch_10.exercise10_23;

import java.util.Arrays;


public class Exercise10_23 {
    public static void main(String[] args) {
        MyString2 myString21 = new MyString2(""Supercalifrajaliscousexpialidocious"");
        MyString2 myString22 = new MyString2(""abcdefghijklmnopqrstuvwxyz"");
        String s = ""abcdefghijklmnopqrstuvwxyz"";
        MyString2 myString113 = new MyString2(""HelloWorldWorldHelloWorld"");
        MyString2 myString4 = new MyString2(""MILO"");
        MyString2 myString5 = new MyString2(""SimonAndGarfunkel"");
        System.out.println(Arrays.toString(myString4.toUpperCase().chars));
        System.out.println(myString22.compare(s));
        System.out.println(myString21.compare(""SomeRandomString""));
        System.out.println(Arrays.toString(myString113.substring(3).chars));
        System.out.println(Arrays.toString(myString5.toChars()));
    }
}
","public class MyString2 {
    private char[] chars;
    
    public MyString2(String s) {
        chars = new char[s.length()];
        for (int i = 0; i < s.length(); i++) {
            chars[i] = s.charAt(i);
        }
    }
    
    public int compare(String s) {
        int len1 = chars.length;
        int len2 = s.length();
        int minLen = Math.min(len1, len2);
        
        for (int i = 0; i < minLen; i++) {
            if (chars[i] != s.charAt(i)) {
                return chars[i] - s.charAt(i);
            }
        }
        
        return len1 - len2;
    }
    
    public MyString2 substring(int begin) {
        int length = chars.length - begin;
        char[] newChars = new char[length];
        for (int i = 0; i < length; i++) {
            newChars[i] = chars[begin + i];
        }
        return new MyString2(new String(newChars));
    }
    
    public MyString2 toUpperCase() {
        int length = chars.length;
        char[] newChars = new char[length];
        for (int i = 0; i < length; i++) {
            char c = chars[i];
            if (c >= 'a' && c <= 'z') {
                c = (char) (c - 'a' + 'A');
            }
            newChars[i] = c;
        }
        return new MyString2(new String(newChars));
    }
    
    public char[] toChars() {
        char[] copyChars = new char[chars.length];
        System.arraycopy(chars, 0, copyChars, 0, chars.length);
        return copyChars;
    }
    
    public static MyString2 valueOf(boolean b) {
        if (b) {
            return new MyString2(""true"");
        } else {
            return new MyString2(""false"");
        }
    }
}
",4,"public class MyString2 {
    private String str;

    public MyString2(String s) {
        this.str = s;
    }

    public int compare(String s) {
        int length1 = this.str.length();
        int length2 = s.length();
        
        if (length1 < length2) {
            return -1;
        } else if (length1 > length2) {
            return 1;
        } else {
            for (int i = 0; i < length1; i++) {
                if (this.str.charAt(i) < s.charAt(i)) {
                    return -1;
                } else if (this.str.charAt(i) > s.charAt(i)) {
                    return 1;
                }
            }
            return 0;
        }
    }

    public MyString2 substring(int begin) {
        if (begin < 0 || begin >= this.str.length()) {
            return new MyString2("""");
        }
        
        String newStr = this.str.substring(begin);
        return new MyString2(newStr);
    }

    public MyString2 toUpperCase() {
        String upperCaseStr = this.str.toUpperCase();
        return new MyString2(upperCaseStr);
    }

    public char[] toChars() {
        char[] charArray = new char[this.str.length()];
        for (int i = 0; i < this.str.length(); i++) {
            charArray[i] = this.str.charAt(i);
        }
        return charArray;
    }

    public static MyString2 valueOf(boolean b) {
        if (b) {
            return new MyString2(""true"");
        } else {
            return new MyString2(""false"");
        }
    }
}
",0.654468085106383
0_MyCharacter.java," /**
 * 10.24 (Implement the Character class) The Character class is provided in the Java
 * library. Provide your own implementation for this class. Name the new class
 * MyCharacter.
 * ************************************************************************************
 * ************************************************************************************
 *                                 ASCII Table
 *                             Dec  = Decimal Value
 *                               Char = Character
 * <p>
 * '5' has the int value 53
 * if we write '5'-'0' it evaluates to 53-48, or the int 5
 * if we write char c = 'B'+32; then c stores 'b'
 * <p>
 * <p>
 * Dec  Char                           Dec  Char     Dec  Char     Dec  Char
 * ---------                           ---------     ---------     ----------
 * 0  NUL (null)                      32  SPACE     64  @         96  `
 * 1  SOH (start of heading)          33  !         65  A         97  a
 * 2  STX (start of text)             34  ""         66  B         98  b
 * 3  ETX (end of text)               35  #         67  C         99  c
 * 4  EOT (end of transmission)       36  $         68  D        100  d
 * 5  ENQ (enquiry)                   37  %         69  E        101  e
 * 6  ACK (acknowledge)               38  &         70  F        102  f
 * 7  BEL (bell)                      39  '         71  G        103  g
 * 8  BS  (backspace)                 40  (         72  H        104  h
 * 9  TAB (horizontal tab)            41  )         73  I        105  i
 * 10  LF  (NL line feed, new line)    42  *         74  J        106  j
 * 11  VT  (vertical tab)              43  +         75  K        107  k
 * 12  FF  (NP form feed, new page)    44  ,         76  L        108  l
 * 13  CR  (carriage return)           45  -         77  M        109  m
 * 14  SO  (shift out)                 46  .         78  N        110  n
 * 15  SI  (shift in)                  47  /         79  O        111  o
 * 16  DLE (data link escape)          48  0         80  P        112  p
 * 17  DC1 (device control 1)          49  1         81  Q        113  q
 * 18  DC2 (device control 2)          50  2         82  R        114  r
 * 19  DC3 (device control 3)          51  3         83  S        115  s
 * 20  DC4 (device control 4)          52  4         84  T        116  t
 * 21  NAK (negative acknowledge)      53  5         85  U        117  u
 * 22  SYN (synchronous idle)          54  6         86  V        118  v
 * 23  ETB (end of trans. block)       55  7         87  W        119  w
 * 24  CAN (cancel)                    56  8         88  X        120  x
 * 25  EM  (end of medium)             57  9         89  Y        121  y
 * 26  SUB (substitute)                58  :         90  Z        122  z
 * 27  ESC (escape)                    59  ;         91  [        123  {
 * 28  FS  (file separator)            60  <         92  \        124  |
 * 29  GS  (group separator)           61  =         93  ]        125  }
 * 30  RS  (record separator)          62  >         94  ^        126  ~
 * 31  US  (unit separator)            63  ?         95  _        127  DEL
 */","package ch_10.exercise10_24;


public class MyCharacter implements java.io.Serializable, Comparable<MyCharacter> {
    public static final char MIN_VALUE = '\u0000';
    public static final char MAX_VALUE = '\uFFFF';
    private final char value;

    static final MyCharacter[] cache = new MyCharacter[128];

    static {
        for (int i = 0; i < cache.length; i++)
            MyCharacter.cache[i] = new MyCharacter((char) i);
    }


    public MyCharacter() {
        value = MIN_VALUE;
    }

    public MyCharacter(char value) {
        this.value = value;
    }

    public static MyCharacter valueOf(char c) {
        if (c <= 127) {
            return MyCharacter.cache[(int) c];
        }
        return new MyCharacter(c);
    }

    public static MyCharacter valueOf(int i) {
        return new MyCharacter((char) i);
    }

    public char charValue() {
        return value;
    }

    public static boolean isLowerCase(char ch) {
        return ((int) ch) > 96 && ((int) ch) < 123;
    }

    public static boolean isDigit(char ch) {
        return ((int) ch) >= 48 && ((int) ch) <= 57;
    }

    public static boolean isUpperCase(char ch) {
        return ((int) ch) >= 65 && ((int) ch) <= 90;
    }

    public static boolean isLetter(char ch) {
        return ((int) ch) >= 65 && ((int) ch) <= 122;
    }

    public static boolean isLetterOrDigit(char ch) {
        return isLetter(ch) || isDigit(ch);
    }

    public static char toLowerCase(char ch) {
        return Character.toLowerCase(ch);
    }

    public static char toUpperCase(char ch) {
        return Character.toUpperCase(ch);
    }

    public static int compare(char x, char y) {
        return x - y;
    }

    @Override
    public int compareTo(MyCharacter anotherMyCharacter) {
        return compare(this.value, anotherMyCharacter.value);
    }

    @Override
    public int hashCode() {
        return MyCharacter.hashCode(value);
    }


    public static int hashCode(char value) {
        return (int) value;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof MyCharacter) {
            return value == ((MyCharacter) obj).charValue();
        }
        return false;
    }

    @Override
    public String toString() {
        char buf[] = {value};
        return String.valueOf(buf);
    }
}
","public class MyCharacter {
    private char ch;

    public MyCharacter(char ch) {
        this.ch = ch;
    }

    public char getChar() {
        return ch;
    }

    public int compareTo(MyCharacter otherChar) {
        return (int) ch - (int) otherChar.getChar();
    }

    public static MyCharacter valueOf(char ch) {
        return new MyCharacter(ch);
    }

    public boolean isDigit() {
        return ch >= '0' && ch <= '9';
    }

    public boolean isLetter() {
        return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
    }

    public boolean isLowerCase() {
        return ch >= 'a' && ch <= 'z';
    }

    public boolean isUpperCase() {
        return ch >= 'A' && ch <= 'Z';
    }

    public boolean isWhitespace() {
        return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r' || ch == '\f';
    }

    public MyCharacter toLowerCase() {
        if (isUpperCase()) {
            return new MyCharacter((char) (ch + 32));
        } else {
            return this;
        }
    }

    public MyCharacter toUpperCase() {
        if (isLowerCase()) {
            return new MyCharacter((char) (ch - 32));
        } else {
            return this;
        }
    }
}
",4,"public class MyCharacter {
    private char value;

    public MyCharacter(char value) {
        this.value = value;
    }

    public char getValue() {
        return value;
    }

    public boolean isDigit() {
        return value >= '0' && value <= '9';
    }

    public boolean isLetter() {
        return (value >= 'A' && value <= 'Z') || (value >= 'a' && value <= 'z');
    }

    public boolean isUpperCase() {
        return value >= 'A' && value <= 'Z';
    }

    public boolean isLowerCase() {
        return value >= 'a' && value <= 'z';
    }

    public boolean isWhitespace() {
        return value == ' ' || value == '\t' || value == '\n' || value == '\r' || value == '\f';
    }

    public static MyCharacter valueOf(char c) {
        return new MyCharacter(c);
    }

    public static char toLowerCase(char c) {
        if (isUpperCase(c)) {
            return (char) (c + 32);
        } else {
            return c;
        }
    }

    public static char toUpperCase(char c) {
        if (isLowerCase(c)) {
            return (char) (c - 32);
        } else {
            return c;
        }
    }

    public static int getNumericValue(char c) {
        if (isDigit(c)) {
            return c - '0';
        } else {
            return -1; // Not a numeric character
        }
    }

    public static boolean isDigit(char c) {
        return c >= '0' && c <= '9';
    }

    public static boolean isLetter(char c) {
        return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
    }

    public static boolean isUpperCase(char c) {
        return c >= 'A' && c <= 'Z';
    }

    public static boolean isLowerCase(char c) {
        return c >= 'a' && c <= 'z';
    }

    public static boolean isWhitespace(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f';
    }
}
",0.5756605284227382
0_Triangle2D.java," /**
 * ***10.12 (Geometry: the Triangle2D class) Define the Triangle2D class that contains:
 * ■ Three points named p1, p2, and p3 of the type MyPoint with getter and
 * setter methods. MyPoint is defined in Programming Exercise 10.4.
 * ■ A no-arg constructor that creates a default triangle with the points (0, 0), (1,1), and (2, 5).
 * ■ A constructor that creates a triangle with the specified points.
 * ■ A method getArea() that returns the area of the triangle.
 * ■ A method getPerimeter() that returns the perimeter of the triangle.
 * ■ A method contains(MyPoint p) that returns true if the specified point p is inside this triangle (see Figure
 * 10.22a).
 * <p>
 * ■ A method contains(Triangle2D t) that returns true if the specified
 * triangle is inside this triangle (see Figure 10.22b).
 * ■ A method overlaps(Triangle2D t) that returns true if the specified
 * triangle overlaps with this triangle (see Figure 10.22c).
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 * <p>
 * <p>
 * (Hint: For the formula to compute the area of a triangle,
 * * see Programming Exercise 2.19. To detect whether a point is inside a triangle, draw three dashed lines,
 * * as shown in Figure 10.23. If the point is inside a triangle, each dashed line
 * * should intersect a side only once. If a dashed line intersects a side twice, then
 * * the point must be outside the triangle. For the algorithm of finding the intersecting
 * * point of two lines, see Programming Exercise 3.25.)
 */ /**
     * ■ A no-arg constructor that creates a default triangle with the points (0, 0), (1,1), and (2, 5).
     */ /**
     * A constructor that creates a triangle with the specified points.
     *
     * @param p1 MyPoint one of the triangle
     * @param p2 MyPoint two of the triangle
     * @param p3 MyPoint three of the triangle
     */ /**
     * ■ A method getArea() that returns the area of the triangle.
     *
     * @return area of the triangle
     */ /**
     * ■ A method getPerimeter() that returns the perimeter of the triangle.
     *
     * @return perimeter of the triangle
     */ /**
     * ■ A method contains(MyPoint p) that returns true if the
     * specified point p is inside this triangle.
     *
     * @param p MyPoint to check with current Triangle
     * @return true if p inside this.Triangle2D
     */ /**
     * ■ A method contains(Triangle2D t) that returns true if the specified
     * * triangle is inside this triangle (see Figure 10.22b).
     *
     * @param t Triangle2D to test if it is inside of this.Triangle2D
     * @return true if t is inside of this
     */ /**
     * ■ A method overlaps(Triangle2D t) that returns true if the specified
     * triangle overlaps with this triangle (see Figure 10.22c).
     *
     * @param t Triangle2D to check for overlap on current Triangle
     * @return true if t overlaps this.Triangle2D
     */","package ch_10.exercise10_12;

import ch_10.exercise10_04.MyPoint;


public class Triangle2D {
    /*
     * ■ Three points named p1, p2, and p3 of the type MyPoint with getter and
     * setter methods. MyPoint is defined in Programming Exercise 10.4.
     */
    private MyPoint p1;
    private MyPoint p2;
    private MyPoint p3;

    
    public Triangle2D() {
        p1 = new MyPoint(0, 0);
        p2 = new MyPoint(1, 1);
        p3 = new MyPoint(2, 5);
    }

    
    public Triangle2D(MyPoint p1, MyPoint p2, MyPoint p3) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }

    
    public double getArea() {
        double side1 = p1.distance(p2);
        double side2 = p2.distance(p3);
        double side3 = p3.distance(p1);
        double s = (side1 + side2 + side3) / 2;

        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    
    public double getPerimeter() {
        return p1.distance(p2)
                + p2.distance(p3)
                + p3.distance(p1);

    }

    
    public boolean contains(MyPoint p) {
        /* Find determinant of triangle */
        double a = p2.getY() - p3.getY();
        double b = p3.getX() - p2.getX();
        double c = p3.getY() - p1.getY();
        double d = p2.getX() - p3.getX();
        double determinant = a * d - b * c;
        double maxDet = Math.max(determinant, 0);
        double minDet = Math.min(determinant, 0);
        double detOfx = p.getX() - p3.getX();
        double detOfy = p.getY() - p3.getY();
        double s = a * detOfx + b * detOfy;
        double t = c * detOfx + d * detOfy;
        double z = determinant - s - t;
        return !(s < minDet || s > maxDet) ||
                !(t < minDet || t > maxDet) ||
                !(z < minDet || z > maxDet);

    }

    
    public boolean contains(Triangle2D t) {
        return this.contains(t.getP1()) && this.contains(t.getP2()) && this.contains(t.getP3());


    }

    
    public boolean overlaps(Triangle2D t) {
        return this.contains(t.getP1()) || this.contains(t.getP2()) || this.contains(t.getP3());
    }


    public MyPoint getP1() {
        return p1;
    }

    public void setP1(MyPoint p1) {
        this.p1 = p1;
    }

    public MyPoint getP2() {
        return p2;
    }

    public void setP2(MyPoint p2) {
        this.p2 = p2;
    }

    public MyPoint getP3() {
        return p3;
    }

    public void setP3(MyPoint p3) {
        this.p3 = p3;
    }


}
","public class Triangle2D {
    private MyPoint p1, p2, p3;

    public Triangle2D() {
        this(new MyPoint(0, 0), new MyPoint(1, 1), new MyPoint(2, 5));
    }

    public Triangle2D(MyPoint p1, MyPoint p2, MyPoint p3) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }

    public MyPoint getP1() {
        return p1;
    }

    public void setP1(MyPoint p1) {
        this.p1 = p1;
    }

    public MyPoint getP2() {
        return p2;
    }

    public void setP2(MyPoint p2) {
        this.p2 = p2;
    }

    public MyPoint getP3() {
        return p3;
    }

    public void setP3(MyPoint p3) {
        this.p3 = p3;
    }

    public double getArea() {
        double side1 = p1.distance(p2);
        double side2 = p2.distance(p3);
        double side3 = p3.distance(p1);
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }

    public double getPerimeter() {
        double side1 = p1.distance(p2);
        double side2 = p2.distance(p3);
        double side3 = p3.distance(p1);
        return side1 + side2 + side3;
    }

    public boolean contains(MyPoint p) {
        double area1 = new Triangle2D(p, p1, p2).getArea();
        double area2 = new Triangle2D(p, p2, p3).getArea();
        double area3 = new Triangle2D(p, p3, p1).getArea();
        double totalArea = getArea();
        return area1 + area2 + area3 <= totalArea;
    }

    public boolean contains(Triangle2D t) {
        return contains(t.p1) && contains(t.p2) && contains(t.p3);
    }

    public boolean overlaps(Triangle2D t) {
        return !contains(t) && !t.contains(this) &&
               (segmentsIntersect(p1, p2, t.p1, t.p2) ||
                segmentsIntersect(p1, p2, t.p2, t.p3) ||
                segmentsIntersect(p1, p2, t.p3, t.p1) ||
                segmentsIntersect(p2, p3, t.p1, t.p2) ||
                segmentsIntersect(p2, p3, t.p2, t.p3) ||
                segmentsIntersect(p2, p3, t.p3, t.p1) ||
                segmentsIntersect(p3, p1, t.p1, t.p2) ||
                segmentsIntersect(p3, p1, t.p2, t.p3) ||
                segmentsIntersect(p3, p1, t.p3, t.p1));
    }

    private boolean segmentsIntersect(MyPoint p1, MyPoint p2, MyPoint p3, MyPoint p4) {
        double d1 = orientation(p1, p2, p3);
        double d2 = orientation(p1, p2, p4);
        double d3 = orientation(p3, p4, p1
",4,"public class Triangle2D {
    // Three points of the triangle
    private MyPoint p1;
    private MyPoint p2;
    private MyPoint p3;

    // No-arg constructor with default points
    public Triangle2D() {
        this.p1 = new MyPoint(0, 0);
        this.p2 = new MyPoint(1, 1);
        this.p3 = new MyPoint(2, 5);
    }

    // Constructor with specified points
    public Triangle2D(MyPoint p1, MyPoint p2, MyPoint p3) {
        this.p1 = p1;
        this.p2 = p2;
        this.p3 = p3;
    }

    // Calculate the area of the triangle
    public double getArea() {
        // Calculation code for area goes here
        // You need to implement this
        return 0.0;
    }

    // Calculate the perimeter of the triangle
    public double getPerimeter() {
        // Calculation code for perimeter goes here
        // You need to implement this
        return 0.0;
    }

    // Check if a point is inside the triangle
    public boolean contains(MyPoint p) {
        // Check if p is inside the triangle
        // You need to implement this
        return false;
    }

    // Check if a triangle is inside this triangle
    public boolean contains(Triangle2D t) {
        // Check if t is inside this triangle
        // You need to implement this
        return false;
    }

    // Check if a triangle overlaps with this triangle
    public boolean overlaps(Triangle2D t) {
        // Check if t overlaps this triangle
        // You need to implement this
        return false;
    }
}
",0.4432863274064991
0_Exercise10_14.java," /**
 * Write a test program that creates two MyDate objects (using new MyDate() and new
 * MyDate(34355555133101L)) and displays their year, month, and day.
 * (Hint: The first two constructors will extract the year, month, and day from
 * the elapsed time. For example, if the elapsed time is 561555550000 milliseconds, the year is 1987, the month is 9, and the day is 18. You may use the
 * GregorianCalendar class discussed in Programming Exercise 9.5 to simplify coding.)
 */","package ch_10.exercise10_14;


public class Exercise10_14 {
    public static void main(String[] args) {
        MyDate myDate1 = new MyDate();
        MyDate myDate2 = new MyDate(34355555133101L);
        MyDate myDate3 = new MyDate(561555550000L);

        System.out.println(""MyDate1:\n year="" + myDate1.getYear() + ""\n month="" + myDate1.getMonth() + ""\n day="" + myDate1.getDay());
        System.out.println(""MyDate2:\n year="" + myDate2.getYear() + ""\n month="" + myDate2.getMonth() + ""\n day="" + myDate2.getDay());
        System.out.println(""MyDate3:\n year="" + myDate3.getYear() + ""\n month="" + myDate3.getMonth() + ""\n day="" + myDate3.getDay());
    }
}
","import java.util.GregorianCalendar;

public class MyDateTest {
    public static void main(String[] args) {
        MyDate date1 = new MyDate();
        MyDate date2 = new MyDate(34355555133101L);

        System.out.println(""Date 1: "" + date1.getYear() + ""/"" + date1.getMonth() + ""/"" + date1.getDay());
        System.out.println(""Date 2: "" + date2.getYear() + ""/"" + date2.getMonth() + ""/"" + date2.getDay());
    }
}

class MyDate {
    private int year;
    private int month;
    private int day;

    public MyDate() {
        GregorianCalendar cal = new GregorianCalendar();
        this.year = cal.get(GregorianCalendar.YEAR);
        this.month = cal.get(GregorianCalendar.MONTH) + 1;
        this.day = cal.get(GregorianCalendar.DAY_OF_MONTH);
    }

    public MyDate(long elapsedTime) {
        GregorianCalendar cal = new GregorianCalendar();
        cal.setTimeInMillis(elapsedTime);
        this.year = cal.get(GregorianCalendar.YEAR);
        this.month = cal.get(GregorianCalendar.MONTH) + 1;
        this.day = cal.get(GregorianCalendar.DAY_OF_MONTH);
    }

    public int getYear() {
        return year;
    }

    public int getMonth() {
        return month;
    }

    public int getDay() {
        return day;
    }
}
",4,"public class DateTest {
    public static void main(String[] args) {
        // Creating a MyDate object using the default constructor
        MyDate date1 = new MyDate();
        
        // Creating a MyDate object with a specific elapsed time
        MyDate date2 = new MyDate(34355555133101L);
        
        // Displaying the year, month, and day for date1
        System.out.println(""Date 1 - Year: "" + date1.getYear() + "", Month: "" + date1.getMonth() + "", Day: "" + date1.getDay());
        
        // Displaying the year, month, and day for date2
        System.out.println(""Date 2 - Year: "" + date2.getYear() + "", Month: "" + date2.getMonth() + "", Day: "" + date2.getDay());
    }
}
public class MyDate {
    private long elapsedTime;

    public MyDate() {
        this.elapsedTime = System.currentTimeMillis();
    }

    public MyDate(long elapsedTime) {
        this.elapsedTime = elapsedTime;
    }

    public int getYear() {
        // Calculating the year from elapsed time
        // This may not be very accurate, but it's a simple way to do it
        long totalDays = elapsedTime / (1000 * 60 * 60 * 24);
        int year = 1970; // The epoch year
        int daysInYear;
        
        while (true) {
            daysInYear = isLeapYear(year) ? 366 : 365;
            if (totalDays < daysInYear) {
                break;
            }
            totalDays -= daysInYear;
            year++;
        }
        
        return year;
    }

    public int getMonth() {
        // Calculating the month from elapsed time
        // This is a very simplified approach and may not be very accurate
        int month = 1;
        long totalDays = elapsedTime / (1000 * 60 * 60 * 24);
        int daysInMonth;

        while (true) {
            daysInMonth = getDaysInMonth(getYear(), month);
            if (totalDays < daysInMonth) {
                break;
            }
            totalDays -= daysInMonth;
            month++;
        }

        return month;
    }

    public int getDay() {
        // Calculating the day from elapsed time
        // This is also a simplified approach
        long totalDays = elapsedTime / (1000 * 60 * 60 * 24);
        int month = getMonth();
        int year = getYear();
        int daysInMonth = getDaysInMonth(year, month);

        return (int) (totalDays + 1);
    }

    // Helper method to check if a year is a leap year
    private boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }

    // Helper method to get the number of days in a specific month of a year
    private int getDaysInMonth(int year, int month) {
        switch (month) {
            case 1: case 3: case 5: case 7: case 8: case 10: case 12:
                return 31;
            case 4: case 6: case 9: case 11:
                return 30;
            case 2:
                return isLeapYear(year) ? 29 : 28;
            default:
                return 0; // Invalid month
        }
    }
}
",0.4370519070834528
0_MyDate.java," /**
 * 10.14 (The MyDate class) Design a class named MyDate. The class contains:
 * ■ The data fields year, month, and day that represent a date. month is
 * 0-based, i.e., 0 is for January.
 * ■ A no-arg constructor that creates a MyDate object for the current date.
 * ■ A constructor that constructs a MyDate object with a specified elapsed time
 * since midnight, January 1, 1970, in milliseconds.
 * ■ A constructor that constructs a MyDate object with the specified year,
 * month, and day.
 * ■ Three getter methods for the data fields year, month, and day, respectively.
 * ■ A method named setDate(long elapsedTime) that sets a new date for
 * the object using the elapsed time.
 * <p>
 
 */","
package ch_10.exercise10_14;

import java.util.GregorianCalendar;

//_________________________UML DIAGRAM______________________________*
/*																	|
 * 			    		      MyDate         			    		|
 *------------------------------------------------------------------|
 *                     	   -day : int	                       		|
 *                         -month : int  							|
 * 							-year:int   					 		|
 *------------------------------------------------------------------|
 *                     +MyDate()            	    				|
 *                     +MyDate(int, int,int)          		    	|
 *                     +MyDate(long)                       	    	|
 * 	 																|
 * 	 			        setDate(long):void 							|
 * 						                                        	|
 * 	 			    	getters and setters 						|
 * 																	|
 *__________________________________________________________________|  */


public class MyDate {
    GregorianCalendar gregorianCalendar = new GregorianCalendar();
    private int year;
    private int month;
    private int day;

    public MyDate() {
        this(System.currentTimeMillis());
    }

    public MyDate(long elapsedTime) {
        setDate(elapsedTime);
    }

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }


    public void setDate(long elapsedTime) {
        gregorianCalendar.setTimeInMillis(elapsedTime);
        this.year = gregorianCalendar.get(GregorianCalendar.YEAR);
        this.month = gregorianCalendar.get(GregorianCalendar.MONTH);
        this.day = gregorianCalendar.get(GregorianCalendar.DAY_OF_MONTH);
    }

    public int getYear() {
        return year;
    }

    public MyDate setYear(int year) {
        this.year = year;
        return this;
    }

    public int getMonth() {
        return month;
    }

    public MyDate setMonth(int month) {
        this.month = month;
        return this;
    }

    public int getDay() {
        return day;
    }

    public MyDate setDay(int day) {
        this.day = day;
        return this;
    }
}
","import java.util.Calendar;
import java.util.GregorianCalendar;

public class MyDate {
    private int year;
    private int month; // 0-based
    private int day;

    // no-arg constructor for the current date
    public MyDate() {
        GregorianCalendar cal = new GregorianCalendar();
        year = cal.get(Calendar.YEAR);
        month = cal.get(Calendar.MONTH);
        day = cal.get(Calendar.DAY_OF_MONTH);
    }

    // constructor with elapsed time since 1/1/1970
    public MyDate(long elapsedTime) {
        setDate(elapsedTime);
    }

    // constructor with specified year, month, and day
    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    // getter methods for year, month, and day
    public int getYear() {
        return year;
    }

    public int getMonth() {
        return month;
    }

    public int getDay() {
        return day;
    }

    // set the date based on elapsed time since 1/1/1970
    public void setDate(long elapsedTime) {
        GregorianCalendar cal = new GregorianCalendar();
        cal.setTimeInMillis(elapsedTime);
        year = cal.get(Calendar.YEAR);
        month = cal.get(Calendar.MONTH);
        day = cal.get(Calendar.DAY_OF_MONTH);
    }
}
",4,"import java.util.Date;

public class MyDate {
    private int year;
    private int month;
    private int day;

    // Constructor to create a MyDate object for the current date
    public MyDate() {
        Date currentDate = new Date();
        year = currentDate.getYear() + 1900;
        month = currentDate.getMonth();
        day = currentDate.getDate();
    }

    // Constructor with elapsed time in milliseconds (unnecessarily complicated)
    public MyDate(long elapsedTime) {
        Date date = new Date(elapsedTime);
        year = date.getYear() + 1900;
        month = date.getMonth();
        day = date.getDate();
    }

    // Constructor with specified year, month, and day
    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    // Redundant getter methods
    public int getYear() {
        return year;
    }

    public int getMonth() {
        return month;
    }

    public int getDay() {
        return day;
    }

    // Unnecessary method to set a new date using elapsed time
    public void setDate(long elapsedTime) {
        Date date = new Date(elapsedTime);
        year = date.getYear() + 1900;
        month = date.getMonth();
        day = date.getDate();
    }

    // Unnecessary and redundant toString method
    public String toString() {
        return ""Year: "" + year + "", Month: "" + month + "", Day: "" + day;
    }
}
",0.6911262798634812
0_MyRectangle2D.java," /**
 * *10.13 (Geometry: the MyRectangle2D class) Define the MyRectangle2D class that
 * contains:
 * ■ Two double data fields named x and y that specify the center of the rectangle with getter and setter methods. (Assume that the rectangle sides are
 * parallel to x- or y- axes.)
 * ■ The data fields width and height with getter and setter methods.
 * ■ A no-arg constructor that creates a default rectangle with (0, 0) for (x, y) and
 * 1 for both width and height.
 * ■ A constructor that creates a rectangle with the specified x, y, width, and
 * height.
 * <p>
 * ■ A method getArea() that returns the area of the rectangle.
 * ■ A method getPerimeter() that returns the perimeter of the rectangle.
 * ■ A method contains(double x, double y) that returns true if the
 * specified point (x, y) is inside this rectangle (see Figure 10.24a).
 * ■ A method contains(MyRectangle2D r) that returns true if the specified rectangle is inside this rectangle (see Figure 10.24b).
 * ■ A method overlaps(MyRectangle2D r) that returns true if the specified rectangle overlaps with this rectangle (see Figure 10.24c).
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 */","package ch_10.exercise10_13;

import ch_10.exercise10_04.MyPoint;
//_________________________UML DIAGRAM______________________________*
/*                                                                                                                                        |
 *                                               MyRectangle2D                                                     |
 *------------------------------------------------------------------|
 *                                -x : double                                               |
 *                         -y : double                                                          |
 *                                                         -height:double                                                         |
 *                                                         -width:double                                                           |
 *------------------------------------------------------------------|
 *                     -MyRectangle2D()                                                    |
 *                     -MyRectangle2D(double, double)                              |
 *             -MyRectangle2D(double, double,double,double)                    |
 *                                                                                                                                          |
 *                                      getArea():double                                                                |
 *                                          getPerimeter():double                           |
 *                                                                                                                                          |
 *                                         +contains(double,double):boolean                    |
 *                                         +contains(MyRectangle2D):boolean                    |
 *                                                                                                 |
 *                                         +overlaps(MyRectangle2D):boolean                                |
 *                                                                                                                                  |
 *                                          getters and setters                                                         |
 *                                                                                                                                         |
 *__________________________________________________________________|  */


public class MyRectangle2D {
    private double x;
    private double y;
    private double height;
    private double width;

    public MyRectangle2D() {
        x = 0;
        y = 0;
        height = 1;
        width = 1;
    }

    public MyRectangle2D(double x, double y, double height, double width) {
        this.x = x;
        this.y = y;
        this.height = height;
        this.width = width;
    }

    public double getArea() {
        return width * height;
    }

    public double getPerimeter() {
        return (2 * width) + (2 * height);
    }

    public boolean contains(double x, double y) {
        // Where A,B,C,D are the corner points of this.myRectangle2D
        MyPoint A = new MyPoint(this.x - width / 2, this.y + height / 2);  //Top left
        MyPoint B = new MyPoint(this.x + width / 2, this.y - height / 2);  //Bottom Right

        return x > A.getX() && y < A.getY() && x < B.getX() && y > B.getY();

    }

    public boolean contains(MyRectangle2D r) {
        if (r.getArea() > this.getArea()) {
            return false;
        }
        return ((r.getX() + r.getWidth() / 2) <= (this.getX() + this.getWidth() / 2)) &&
                ((r.getX() - r.getWidth() / 2) >= (this.getX() - this.getWidth() / 2)) &&
                ((r.getY() + r.getHeight() / 2) <= (this.getY() + this.getHeight() / 2)) &&
                ((r.getY() - r.getHeight() / 2) >= (this.getY() - this.getHeight() / 2));
    }

    public boolean overlaps(MyRectangle2D r) {
        // Points for rectangle 'r'
        MyPoint rec1TopLeft = new MyPoint(r.getX() - r.getWidth() / 2, r.getY() + r.getHeight() / 2);
        MyPoint rec1BottomRight = new MyPoint(r.getX() + r.getWidth() / 2, r.getY() - r.getHeight() / 2);
        // Points for current object rectangle
        MyPoint rec2TopLeft = new MyPoint(this.getX() - this.getWidth() / 2, this.getY() + this.getHeight() / 2);
        MyPoint rec2BottomRight = new MyPoint(this.getX() + r.getWidth() / 2, this.getY() - this.getHeight() / 2);

        return (rec1TopLeft.getX() < rec2BottomRight.getX() && rec2TopLeft.getX() < rec1BottomRight.getX()) &&
                (rec1TopLeft.getY() > rec2BottomRight.getY() && rec2TopLeft.getY() > rec1BottomRight.getY());

    }

    public double getX() {
        return x;
    }

    public MyRectangle2D setX(double x) {
        this.x = x;
        return this;
    }

    public double getY() {
        return y;
    }

    public MyRectangle2D setY(double y) {
        this.y = y;
        return this;
    }

    public double getHeight() {
        return height;
    }

    public MyRectangle2D setHeight(double height) {
        this.height = height;
        return this;
    }

    public double getWidth() {
        return width;
    }

    public MyRectangle2D setWidth(double width) {
        this.width = width;
        return this;
    }
}","public class MyRectangle2D {
    private double x;
    private double y;
    private double width;
    private double height;

    public MyRectangle2D() {
        this(0, 0, 1, 1);
    }

    public MyRectangle2D(double x, double y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public double getY() {
        return y;
    }

    public void setY(double y) {
        this.y = y;
    }

    public double getWidth() {
        return width;
    }

    public void setWidth(double width) {
        this.width = width;
    }

    public double getHeight() {
        return height;
    }

    public void setHeight(double height) {
        this.height = height;
    }

    public double getArea() {
        return width * height;
    }

    public double getPerimeter() {
        return 2 * (width + height);
    }

    public boolean contains(double x, double y) {
        return Math.abs(x - this.x) <= width / 2 && Math.abs(y - this.y) <= height / 2;
    }

    public boolean contains(MyRectangle2D r) {
        return contains(r.getX() - r.getWidth() / 2, r.getY() + r.getHeight() / 2) &&
               contains(r.getX() - r.getWidth() / 2, r.getY() - r.getHeight() / 2) &&
               contains(r.getX() + r.getWidth() / 2, r.getY() + r.getHeight() / 2) &&
               contains(r.getX() + r.getWidth() / 2, r.getY() - r.getHeight() / 2);
    }

    public boolean overlaps(MyRectangle2D r) {
        double x1 = x - width / 2;
        double y1 = y + height / 2;
        double x2 = x + width / 2;
        double y2 = y - height / 2;

        double rx1 = r.getX() - r.getWidth() / 2;
        double ry1 = r.getY() + r.getHeight() / 2;
        double rx2 = r.getX() + r.getWidth() / 2;
        double ry2 = r.getY() - r.getHeight() / 2;

        return !(rx2 < x1 || rx1 > x2 || ry2 > y1 || ry1 < y2);
    }
}
",4,"public class MyRectangle2D {

    // Data fields
    private double x;
    private double y;
    private double width;
    private double height;

    // Constructor
    public MyRectangle2D() {
        x = 0;  // Default x-coordinate
        y = 0;  // Default y-coordinate
        width = 1;  // Default width
        height = 1; // Default height
    }

    // Another constructor
    public MyRectangle2D(double newX, double newY, double newWidth, double newHeight) {
        x = newX;    // Set x-coordinate
        y = newY;    // Set y-coordinate
        width = newWidth;  // Set width
        height = newHeight; // Set height
    }

    // Getter and Setter methods for x and y
    public double getX() {
        return x;
    }

    public void setX(double newX) {
        x = newX;
    }

    public double getY() {
        return y;
    }

    public void setY(double newY) {
        y = newY;
    }

    // Getter and Setter methods for width and height
    public double getWidth() {
        return width;
    }

    public void setWidth(double newWidth) {
        width = newWidth;
    }

    public double getHeight() {
        return height;
    }

    public void setHeight(double newHeight) {
        height = newHeight;
    }

    // Calculate the area of the rectangle
    public double getArea() {
        return width * height;
    }

    // Calculate the perimeter of the rectangle
    public double getPerimeter() {
        return 2 * (width + height);
    }

    // Check if a point is inside the rectangle
    public boolean contains(double checkX, double checkY) {
        return (checkX >= x - width / 2 && checkX <= x + width / 2) &&
               (checkY >= y - height / 2 && checkY <= y + height / 2);
    }

    // Check if another rectangle is inside this rectangle
    public boolean contains(MyRectangle2D anotherRect) {
        double x1 = x - width / 2;
        double y1 = y - height / 2;
        double x2 = x + width / 2;
        double y2 = y + height / 2;
        
        double x3 = anotherRect.getX() - anotherRect.getWidth() / 2;
        double y3 = anotherRect.getY() - anotherRect.getHeight() / 2;
        double x4 = anotherRect.getX() + anotherRect.getWidth() / 2;
        double y4 = anotherRect.getY() + anotherRect.getHeight() / 2;

        return (x3 >= x1 && x4 <= x2 && y3 >= y1 && y4 <= y2);
    }

    // Check if another rectangle overlaps with this rectangle
    public boolean overlaps(MyRectangle2D anotherRect) {
        double x1 = x - width / 2;
        double y1 = y - height / 2;
        double x2 = x + width / 2;
        double y2 = y + height / 2;
        
        double x3 = anotherRect.getX() - anotherRect.getWidth() / 2;
        double y3 = anotherRect.getY() - anotherRect.getHeight() / 2;
        double x4 = anotherRect.getX() + anotherRect.getWidth() / 2;
        double y4 = anotherRect.getY() + anotherRect.getHeight() / 2;

        return !(x3 > x2 || x4 < x1 || y3 > y2 || y4 < y1);
    }
}
",0.6931951966093713
0_MyString1.java," /**
 * **10.22 (Implement the String class) The String class is provided in the Java library.
 * Provide your own implementation for the following methods (name the new
 * class MyString1):
 * public MyString1(char[] chars);
 * public char charAt(int index);
 * public int length();
 * public MyString1 substring(int begin, int end);
 * public MyString1 toLowerCase();
 * public boolean equals(MyString1 s);
 * public static MyString1 valueOf(int i);
 */","package ch_10.exercise10_22;


public class MyString1 {
    char[] chars;

    public MyString1(char[] chars) {
        this.chars = chars;
    }

    public char charAt(int index) {
        if (chars != null && chars.length > index) {
            return chars[index];
        }
        return ' ';
    }

    public int length() {
        if (chars != null) {
            return chars.length;
        }
        return 0;
    }

    public MyString1 substring(int begin, int end) {
        char[] resChars = new char[end - begin];
        if (this.chars != null && chars.length > end) {
            for (int i = begin, resIdx = 0; i < end; i++, resIdx++) {
                resChars[resIdx] = chars[i];
            }
            return new MyString1(resChars);
        }
        return null;
    }

    public MyString1 toLowerCase() {
        if (this.chars != null) {
            char[] resChars = new char[chars.length];
            for (int i = 0; i < resChars.length; i++) {
                resChars[i] = Character.toLowerCase(chars[i]);
            }
            return new MyString1(resChars);
        }
        return null;
    }

    public boolean equals(MyString1 s) {
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] != s.chars[i]) {
                return false;
            }
        }
        return true;
    }

    public static MyString1 valueOf(int i) {
        CharSequence temp = i + """";
        return new MyString1(new char[]{temp.charAt(0)});
    }
}
","public class MyString1 {
    private final char[] chars;

    public MyString1(char[] chars) {
        this.chars = chars.clone();
    }

    public char charAt(int index) {
        if (index < 0 || index >= chars.length) {
            throw new IndexOutOfBoundsException();
        }
        return chars[index];
    }

    public int length() {
        return chars.length;
    }

    public MyString1 substring(int begin, int end) {
        if (begin < 0 || end > chars.length || begin > end) {
            throw new IndexOutOfBoundsException();
        }
        char[] subChars = new char[end - begin];
        for (int i = begin; i < end; i++) {
            subChars[i - begin] = chars[i];
        }
        return new MyString1(subChars);
    }

    public MyString1 toLowerCase() {
        char[] lowerChars = new char[chars.length];
        for (int i = 0; i < chars.length; i++) {
            lowerChars[i] = Character.toLowerCase(chars[i]);
        }
        return new MyString1(lowerChars);
    }

    public boolean equals(MyString1 s) {
        if (s == null || s.chars.length != chars.length) {
            return false;
        }
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] != s.chars[i]) {
                return false;
            }
        }
        return true;
    }

    public static MyString1 valueOf(int i) {
        if (i == 0) {
            return new MyString1(new char[] {'0'});
        }
        int numDigits = (int) Math.ceil(Math.log10(i + 1));
        char[] digits = new char[numDigits];
        for (int j = numDigits - 1; j >= 0; j--) {
            digits[j] = (char) ('0' + i % 10);
            i /= 10;
        }
        return new MyString1(digits);
    }
}
",5,"public class MyString1 {
    private char[] characters;

    // Constructor to create a MyString1 object from a char array
    public MyString1(char[] chars) {
        this.characters = new char[chars.length];
        for (int i = 0; i < chars.length; i++) {
            this.characters[i] = chars[i];
        }
    }

    // Method to get the character at a specific index
    public char charAt(int index) {
        if (index >= 0 && index < characters.length) {
            return characters[index];
        } else {
            System.out.println(""Invalid index!"");
            return '\0'; // Return null character for invalid index
        }
    }

    // Method to get the length of the string
    public int length() {
        int length = characters.length;
        return length;
    }

    // Method to get a substring from begin to end
    public MyString1 substring(int begin, int end) {
        if (begin < 0) {
            begin = 0;
        }
        if (end > characters.length) {
            end = characters.length;
        }
        if (begin > end) {
            System.out.println(""Invalid substring indices!"");
            return new MyString1(new char[0]);
        }

        char[] subChars = new char[end - begin];
        for (int i = begin; i < end; i++) {
            subChars[i - begin] = characters[i];
        }
        return new MyString1(subChars);
    }

    // Method to convert the string to lowercase
    public MyString1 toLowerCase() {
        char[] lowerChars = new char[characters.length];
        for (int i = 0; i < characters.length; i++) {
            lowerChars[i] = Character.toLowerCase(characters[i]);
        }
        return new MyString1(lowerChars);
    }

    // Method to check if two MyString1 objects are equal
    public boolean equals(MyString1 s) {
        if (s == null || s.characters.length != this.characters.length) {
            return false;
        }

        for (int i = 0; i < characters.length; i++) {
            if (characters[i] != s.characters[i]) {
                return false;
            }
        }
        return true;
    }

    // Static method to create a MyString1 from an integer
    public static MyString1 valueOf(int i) {
        String intStr = Integer.toString(i);
        char[] intChars = intStr.toCharArray();
        return new MyString1(intChars);
    }

    public static void main(String[] args) {
        char[] chars = {'H', 'e', 'l', 'l', 'o'};
        MyString1 myString = new MyString1(chars);

        System.out.println(""Character at index 2: "" + myString.charAt(2));
        System.out.println(""Length of the string: "" + myString.length());
        System.out.println(""Substring from 1 to 4: "" + myString.substring(1, 4).characters);
        System.out.println(""Lowercase string: "" + myString.toLowerCase().characters);

        MyString1 anotherString = new MyString1(new char[] {'h', 'e', 'l', 'l', 'o'});
        System.out.println(""Are the two strings equal? "" + myString.equals(anotherString));

        MyString1 intString = MyString1.valueOf(12345);
        System.out.println(""String representation of 12345: "" + intString.characters);
    }
}
",0.5952262555942317
0_Exercise10_22.java," /**
 * **10.22 (Implement the String class) The String class is provided in the Java library.
 * Provide your own implementation for the following methods (name the new
 * class MyString1):
 * public MyString1(char[] chars);
 * public char charAt(int index);
 * public int length();
 * public MyString1 substring(int begin, int end);
 * public MyString1 toLowerCase();
 * public boolean equals(MyString1 s);
 * public static MyString1 valueOf(int i);
 */","package ch_10.exercise10_22;

import java.util.Arrays;


public class Exercise10_22 {
    public static void main(String[] args) {
        MyString1 myString11 = new MyString1(new char[]{'T', 'E', 'S', 'T', '1'});
        MyString1 myString12 = new MyString1(new char[]{'T', 'E', 'S', 'T', '1'});

        MyString1 myString13 = new MyString1(new char[]{'T', 'E', 'S', 'T', '2'});
        System.out.println("" MyString1 myString11 = new MyString1(new char[]{'T', 'E', 'S', 'T', '1'});\n"" +
                ""MyString1 myString12 = new MyString1(new char[]{'T', 'E', 'S', 'T', '1'});\n"" +
                ""MyString1 myString13 = new MyString1(new char[]{'T', 'E', 'S', 'T', '2'});\n"");
        System.out.println(""myString11.equals(myString12): "" + myString11.equals(myString12));
        System.out.println(""myString11.equals(myString13): "" + myString11.equals(myString13));
        System.out.println(""myString11.substring(1, 3).chars: "" + Arrays.toString(myString11.substring(1, 3).chars));
        System.out.println(""myString13.charAt(2): "" + myString13.charAt(2));
        System.out.println(""MyString1.valueOf(7).chars: "" + Arrays.toString(MyString1.valueOf(7).chars));
        System.out.println(""myString12.toLowerCase().chars "" + Arrays.toString(myString12.toLowerCase().chars));
        System.out.println(""myString11.length(): "" + myString11.length());

    }
}
","public class MyString1 {
    private final char[] chars;

    public MyString1(char[] chars) {
        this.chars = chars.clone();
    }

    public char charAt(int index) {
        if (index < 0 || index >= chars.length) {
            throw new IndexOutOfBoundsException();
        }
        return chars[index];
    }

    public int length() {
        return chars.length;
    }

    public MyString1 substring(int begin, int end) {
        if (begin < 0 || end > chars.length || begin > end) {
            throw new IndexOutOfBoundsException();
        }
        char[] subChars = new char[end - begin];
        for (int i = begin; i < end; i++) {
            subChars[i - begin] = chars[i];
        }
        return new MyString1(subChars);
    }

    public MyString1 toLowerCase() {
        char[] lowerChars = new char[chars.length];
        for (int i = 0; i < chars.length; i++) {
            lowerChars[i] = Character.toLowerCase(chars[i]);
        }
        return new MyString1(lowerChars);
    }

    public boolean equals(MyString1 s) {
        if (s == null || s.chars.length != chars.length) {
            return false;
        }
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] != s.chars[i]) {
                return false;
            }
        }
        return true;
    }

    public static MyString1 valueOf(int i) {
        if (i == 0) {
            return new MyString1(new char[] {'0'});
        }
        int numDigits = (int) Math.ceil(Math.log10(i + 1));
        char[] digits = new char[numDigits];
        for (int j = numDigits - 1; j >= 0; j--) {
            digits[j] = (char) ('0' + i % 10);
            i /= 10;
        }
        return new MyString1(digits);
    }
}
",5,"public class MyString1 {
    // Instance variables
    private char[] chars;

    // Constructor to initialize the MyString1 object
    public MyString1(char[] chars) {
        this.chars = new char[chars.length];
        for (int i = 0; i < chars.length; i++) {
            this.chars[i] = chars[i];
        }
    }

    // Method to get the character at a specific index
    public char charAt(int index) {
        if (index < 0 || index >= chars.length) {
            System.out.println(""Index out of bounds!"");
            return '\0'; // Return a null character if index is out of bounds
        }
        return chars[index];
    }

    // Method to get the length of the MyString1
    public int length() {
        return chars.length;
    }

    // Method to get a substring from begin to end
    public MyString1 substring(int begin, int end) {
        if (begin < 0 || begin >= chars.length || end < 0 || end >= chars.length || begin > end) {
            System.out.println(""Invalid substring parameters!"");
            return null; // Return null if parameters are invalid
        }
        char[] subChars = new char[end - begin];
        for (int i = begin; i < end; i++) {
            subChars[i - begin] = chars[i];
        }
        return new MyString1(subChars);
    }

    // Method to convert the MyString1 to lowercase
    public MyString1 toLowerCase() {
        char[] lowerChars = new char[chars.length];
        for (int i = 0; i < chars.length; i++) {
            lowerChars[i] = Character.toLowerCase(chars[i]);
        }
        return new MyString1(lowerChars);
    }

    // Method to check if two MyString1 objects are equal
    public boolean equals(MyString1 s) {
        if (s == null) {
            return false;
        }
        if (s.length() != chars.length) {
            return false;
        }
        for (int i = 0; i < chars.length; i++) {
            if (chars[i] != s.charAt(i)) {
                return false;
            }
        }
        return true;
    }

    // Static method to create a MyString1 from an integer
    public static MyString1 valueOf(int i) {
        String str = Integer.toString(i);
        char[] intChars = str.toCharArray();
        return new MyString1(intChars);
    }

    // Main method for testing
    public static void main(String[] args) {
        char[] chars = {'H', 'e', 'l', 'l', 'o'};
        MyString1 myString = new MyString1(chars);
        System.out.println(""charAt(2): "" + myString.charAt(2));
        System.out.println(""Length: "" + myString.length());
        System.out.println(""Substring(1, 4): "" + myString.substring(1, 4));
        System.out.println(""ToLowerCase: "" + myString.toLowerCase().toString());
        System.out.println(""Equals(\""hello\""): "" + myString.equals(new MyString1(""hello"".toCharArray())));
        System.out.println(""ValueOf(123): "" + MyString1.valueOf(123).toString());
    }
}
",0.6266386995280545
0_MyPoint.java," /**
 * 10.4 (The MyPoint class) Design a class named MyPoint to represent a point with
 * x- and y-coordinates. The class contains:
 * ■ The data fields x and y that represent the coordinates with getter
 * methods.
 * ■ A no-arg constructor that creates a point (0, 0).
 * ■ A constructor that constructs a point with specified coordinates.
 * ■ A method named distance that returns the distance from this point to a
 * specified point of the MyPoint type.
 * ■ A method named distance that returns the distance from this point to
 * another point with specified x- and y-coordinates.
 .
 */","package ch_10.exercise10_04;

//_________________________UML DIAGRAM______________________________*
/*                                                                                                                                        |
 *                                                           MyPoint                                                                  |
 *------------------------------------------------------------------|
 *                                -x : int                                                   |
 *                                                                                                                                          |
 *                         -y : int                                                                        |
 *------------------------------------------------------------------|
 *                     -MyPoint()                                                              |
 *                     -MyPoint(int, int)                                        |
 *                                                                                                                                          |
 *                                         +distance(MyPoint):double                            |
 *                                                                                                 |
 *                                         +distance(int,int):double                                                |
 *                                                                                                                                  |
 *                                                                                                                                         |
 *                               +getCenterX() : int                                                            |
 *                                                                                                                                     |
 *                               +getCenterY() : int                                                           |
 *                                                                                                                                          |
 *                                                                                                                                         |
 *__________________________________________________________________|  */



public class MyPoint {
    private double x;
    private double y;

    public MyPoint() {
        x = 0;
        y = 0;
    }

    public MyPoint(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double distance(MyPoint point) {
        return distance(point.x, point.y);

    }

    public double distance(double x, double y) {
        return Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }


}
","public class MyPoint {
    private double x;
    private double y;

    public MyPoint() {
        this.x = 0;
        this.y = 0;
    }

    public MyPoint(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double distance(MyPoint point) {
        double xDiff = x - point.x;
        double yDiff = y - point.y;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }

    public double distance(double x, double y) {
        return distance(new MyPoint(x, y));
    }
}
",5,"public class MyPoint {

    // Data fields to represent the coordinates
    private double xCoordinate;
    private double yCoordinate;

    // A no-arg constructor that creates a point at (0, 0)
    public MyPoint() {
        this.xCoordinate = 0.0;
        this.yCoordinate = 0.0;
    }

    // A constructor to set the coordinates
    public MyPoint(double x, double y) {
        this.xCoordinate = x;
        this.yCoordinate = y;
    }

    // Getter methods for x and y coordinates
    public double getXCoordinate() {
        return this.xCoordinate;
    }

    public double getYCoordinate() {
        return this.yCoordinate;
    }

    // Calculate and return distance to another MyPoint
    public double distance(MyPoint otherPoint) {
        double xDiff = this.xCoordinate - otherPoint.getXCoordinate();
        double yDiff = this.yCoordinate - otherPoint.getYCoordinate();
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }

    // Calculate and return distance to a point with specific coordinates
    public double distance(double x, double y) {
        double xDiff = this.xCoordinate - x;
        double yDiff = this.yCoordinate - y;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }
}
",0.6040353089533418
0_MyInteger.java," /**
 * Exercise10_03(The MyInteger class)
 * Design a Java class named MyInteger. The class contains:
 * <p>
 * An int data field named value that stores the int value represented by this object.
 * <p>
 * A constructor that creates a MyInteger object for the specified int value.
 * <p>
 * A getter method that returns the int value.
 * <p>
 * The methods isEven(), isOdd(), and isPrime() that return true if the value in this
 * object is even, odd, or prime, respectively.
 * <p>
 * The static methods isEven(int), isOdd(int), and isPrime(int) that return true if the
 * specified value is even, odd, or prime, respectively.
 * <p>
 * The static methods isEven(MyInteger), isOdd(MyInteger), and isPrime(MyInteger) that
 * return true if the specified value is even, odd, or prime, respectively.
 * <p>
 * The methods equals(int) and equals(MyInteger) that return true if the value in this
 * object is equal to the specified value.
 * <p>
 * A static method parseInt(char[]) that converts an array of numeric characters to an int value.
 * <p>
 * A static method parseInt(String) that converts a string into an int value.
 * <p>
 * Write a client program that tests all methods in the class.
 */","package ch_10.exercise10_03;


//__________________________UML DIAGRAM_____________________________*
/*                                                                                                                                        |
 *                                                          MyInteger                                                                |
 *-------------------------------------------------------------------|
 * -Value:int        (Value of object)                                                                        |
 *                                                                                                                                        |
 *-------------------------------------------------------------------|
 *          +MyInteger(value: int)                                                                                        |
 *                                                                                                                                          |
 *          +getMyIntValue() : int                                                                                        |
 *                                                                                                                                         |
 *          +isEven(): boolean                                                                                            |
 *                                                                                                                                          |
 *          +isOdd(): boolean                                                                                                |
 *                                                                                                                                  |
 *         +isPrime():boolean                                                                                                 |
 *                                                                                                                                         |
 *         __+isEven(int):boolean___                                                                                |
 *                                                                                                                                         |
 *         ___+isOdd(int):boolean___                                                                                |
 *                                                                                                                                         |
 *         ____+isPrime(int):boolean___                                                                        |
 *                                                                                                                                         |
 *         ____+isEven        MyInteger():boolean___                                                                 |
 *                                                                                                                                         |
 *         ____+isOdd(MyInteger):boolean_____                                                           |
 *                                                                                                                                         |
 *         ___+isPrime(MyInteger):boolean_____                                                         |
 *                                                                                                                                         |
 *         +equals(int): boolean                                                                                        |
 *                                                                                                                                         |
 *         +equals(MyInteger):boolean                                                                                |
 *                                                                                                                                         |
 *         ___+parseInt(Char[]): int___                                                                        |
 *                                                                                                                                         |
 *         _____+parseInt(String):int____                                                              |
 *                                                                                                                                         |
 *                                                                                                                                         |
 *                                                                                                                                         |
 *                                                                                                                                         |
 *                                                                                                                                         |
 * __________________________________________________________________|  */



public class MyInteger {

    private int value;

    public MyInteger(int newValue) {

        this.value = newValue;

    }

    public int getValue() {
        return value;
    }

    public boolean isEven() {

        if (value % 2 == 0)
            return true;
        else
            return false;

    }

    public boolean isOdd() {
        if (value % 2 != 0)
            return true;
        else
            return false;

    }

    public boolean isPrime() {
        boolean prime = false;
        for (int i = 3; i < value / 2; i++) {
            if (value % i == 0) {
                prime = false;
            } else {
                prime = true;
                break;
            }
        }

        return prime;
    }

    public static boolean isEven(int a) {
        if (a % 2 == 0)
            return true;
        else
            return false;

    }

    public static boolean isOdd(int a) {
        if (a % 2 != 0) {
            return true;
        } else {
            return false;
        }
    }

    public static boolean isPrime(int a) {
        boolean wellisIt = false;

        for (int i = 2; i < a / 2; i++) {
            if (a % i == 0) {
                wellisIt = false;
            } else {
                wellisIt = true;
            }

        }

        return wellisIt;

    }

    public static boolean isEven(MyInteger a) {
        return a.isEven();

    }

    public static boolean isOdd(MyInteger a) {
        return a.isOdd();
    }

    public static boolean isPrime(MyInteger a) {
        return a.isPrime();
    }

    public boolean equals(int a) {
        if (this.value == a) {
            return true;
        } else
            return false;
    }

    public boolean equals(Integer a) {
        if (this.value == a) {
            return true;
        } else {
            return false;
        }
    }

    public static int parseInt(char[] arr) {

        String str = String.valueOf(arr);

        int result = 0;

        for (int j = 0; j < str.length(); j++) {

            result += str.charAt(j);
        }

        return result;

    }

    public static int parseInt(String a) {

        return Integer.parseInt(a);

    }

}","public class MyInteger {
    private int value;

    public MyInteger(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public boolean isEven() {
        return value % 2 == 0;
    }

    public boolean isOdd() {
        return value % 2 != 0;
    }

    public boolean isPrime() {
        if (value < 2) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(value); i++) {
            if (value % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static boolean isEven(int value) {
        return value % 2 == 0;
    }

    public static boolean isOdd(int value) {
        return value % 2 != 0;
    }

    public static boolean isPrime(int value) {
        if (value < 2) {
            return false;
        }
        for (int i = 2; i <= Math.sqrt(value); i++) {
            if (value % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static boolean isEven(MyInteger myInt) {
        return myInt.isEven();
    }

    public static boolean isOdd(MyInteger myInt) {
        return myInt.isOdd();
    }

    public static boolean isPrime(MyInteger myInt) {
        return myInt.isPrime();
    }

    public boolean equals(int value) {
        return this.value == value;
    }

    public boolean equals(MyInteger myInt) {
        return this.value == myInt.getValue();
    }

    public static int parseInt(char[] chars) {
        int result = 0;
        for (int i = 0; i < chars.length; i++) {
            result = result * 10 + (chars[i] - '0');
        }
        return result;
    }

    public static int parseInt(String str) {
        return Integer.parseInt(str);
    }
}
",5,"public class MyInteger {
    private int value;

    public MyInteger(int val) {
        this.value = val;
    }

    public int getValue() {
        return this.value;
    }

    public boolean isEven() {
        if (this.value % 2 == 0) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isOdd() {
        if (this.value % 2 != 0) {
            return true;
        } else {
            return false;
        }
    }

    public boolean isPrime() {
        if (this.value <= 1) {
            return false;
        }
        for (int i = 2; i < this.value; i++) {
            if (this.value % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static boolean isEven(int val) {
        if (val % 2 == 0) {
            return true;
        } else {
            return false;
        }
    }

    public static boolean isOdd(int val) {
        if (val % 2 != 0) {
            return true;
        } else {
            return false;
        }
    }

    public static boolean isPrime(int val) {
        if (val <= 1) {
            return false;
        }
        for (int i = 2; i < val; i++) {
            if (val % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static boolean isEven(MyInteger myInt) {
        return myInt.isEven();
    }

    public static boolean isOdd(MyInteger myInt) {
        return myInt.isOdd();
    }

    public static boolean isPrime(MyInteger myInt) {
        return myInt.isPrime();
    }

    public boolean equals(int val) {
        if (this.value == val) {
            return true;
        } else {
            return false;
        }
    }

    public boolean equals(MyInteger myInt) {
        return this.value == myInt.getValue();
    }

    public static int parseInt(char[] chars) {
        String str = new String(chars);
        return Integer.parseInt(str);
    }

    public static int parseInt(String str) {
        return Integer.parseInt(str);
    }
}

public class TestMyInteger {
    public static void main(String[] args) {
        MyInteger myInt = new MyInteger(7);

        System.out.println(""Value: "" + myInt.getValue());
        System.out.println(""Is even: "" + myInt.isEven());
        System.out.println(""Is odd: "" + myInt.isOdd());
        System.out.println(""Is prime: "" + myInt.isPrime());

        System.out.println(""Is 13 even: "" + MyInteger.isEven(13));
        System.out.println(""Is 13 odd: "" + MyInteger.isOdd(13));
        System.out.println(""Is 13 prime: "" + MyInteger.isPrime(13));

        MyInteger anotherInt = new MyInteger(5);
        System.out.println(""Is anotherInt even: "" + MyInteger.isEven(anotherInt));
        System.out.println(""Is anotherInt odd: "" + MyInteger.isOdd(anotherInt));
        System.out.println(""Is anotherInt prime: "" + MyInteger.isPrime(anotherInt));

        System.out.println(""Is equal to 7: "" + myInt.equals(7));
        System.out.println(""Is equal to anotherInt: "" + myInt.equals(anotherInt));

        char[] numChars = {'1', '2', '3'};
        System.out.println(""Parse int from char array: "" + MyInteger.parseInt(numChars));

        String numString = ""456"";
        System.out.println(""Parse int from string: "" + MyInteger.parseInt(numString));
    }
}
",0.62960217445021
0_BMI.java," /**
 * 10.2 (The BMI class) Add the following new constructor in the BMI class:
 * /* Construct a BMI with the specified name, age, weight
 * * feet, and inches
 * <p>
 * public BMI(String name,int age,double weight, double feet, double inches)
 */ /**
     * Construct a BMI with the specified name, age, weight,
     * feet, and inches
     */","package ch_10.exercise10_02;


public class BMI {

    
    public BMI(String name, int age, double weight, double feet,
               double inches) {
        this(name, age, weight, (feet / 12) + inches);

    }

    private String name;
    private int age;
    private double weight; // in pounds
    private double height; // in inches
    public static final double KILOGRAMS_PER_POUND = 0.45359237;
    public static final double METERS_PER_INCH = 0.0254;

    public BMI(String name, int age, double weight, double height) {
        this.name = name;
        this.age = age;
        this.weight = weight;
        this.height = height;
    }

    public BMI(String name, double weight, double height) {
        this(name, 20, weight, height);
    }

    public double getBMI() {
        double bmi = weight * KILOGRAMS_PER_POUND /
                ((height * METERS_PER_INCH) * (height * METERS_PER_INCH));
        return Math.round(bmi * 100) / 100.0;
    }

    public String getStatus() {
        double bmi = getBMI();
        if (bmi < 18.5)
            return ""Underweight"";
        else if (bmi < 25)
            return ""Normal"";
        else if (bmi < 30)
            return ""Overweight"";
        else
            return ""Obese"";
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public double getWeight() {
        return weight;
    }

    public double getHeight() {
        return height;
    }
}","public class BMI {
   private String name;
   private int age;
   private double weight; // in pounds
   private double height; // in inches
   private double feet; // in feet
   private double inches; // in inches
   
   public BMI(String name, int age, double weight, double height) {
      this.name = name;
      this.age = age;
      this.weight = weight;
      this.height = height;
   }
   
   public BMI(String name, int age, double weight, double feet, double inches) {
      this.name = name;
      this.age = age;
      this.weight = weight;
      this.feet = feet;
      this.inches = inches;
      this.height = (feet * 12) + inches;
   }
   
   public double getBMI() {
      double bmi = weight / Math.pow(height, 2) * 703;
      return Math.round(bmi * 100) / 100.0;
   }
   
   public String getStatus() {
      double bmi = getBMI();
      if (bmi < 18.5)
         return ""Underweight"";
      else if (bmi < 25)
         return ""Normal"";
      else if (bmi < 30)
         return ""Overweight"";
      else
         return ""Obese"";
   }
   
   public String getName() {
      return name;
   }
   
   public int getAge() {
      return age;
   }
   
   public double getWeight() {
      return weight;
   }
   
   public double getHeight() {
      return height;
   }
   
   public double getFeet() {
      return feet;
   }
   
   public double getInches() {
      return inches;
   }
}
",5,"/**
 * This is a BMI calculator class. It calculates BMI based on name, age, weight,
 * feet, and inches.
 */
public class BMI {
    private String name; // The name of the person
    private int age; // The age of the person
    private double weight; // The weight of the person in pounds
    private double feet; // The height of the person in feet
    private double inches; // The height of the person in inches

    /**
     * This is a constructor for creating a BMI object with all the specified details.
     *
     * @param name   - The name of the person.
     * @param age    - The age of the person.
     * @param weight - The weight of the person in pounds.
     * @param feet   - The height of the person in feet.
     * @param inches - The height of the person in inches.
     */
    public BMI(String name, int age, double weight, double feet, double inches) {
        this.name = name;
        this.age = age;
        this.weight = weight;
        this.feet = feet;
        this.inches = inches;
    }

    /**
     * This method calculates the BMI (Body Mass Index) based on the provided
     * weight, feet, and inches, and returns the result.
     *
     * @return The calculated BMI.
     */
    public double calculateBMI() {
        double heightInInches = (feet * 12) + inches;
        double bmi = (weight / (heightInInches * heightInInches)) * 703;
        return bmi;
    }

    /**
     * This method returns the name of the person.
     *
     * @return The name of the person.
     */
    public String getName() {
        return name;
    }

    /**
     * This method returns the age of the person.
     *
     * @return The age of the person.
     */
    public int getAge() {
        return age;
    }

    /**
     * This method returns the weight of the person in pounds.
     *
     * @return The weight of the person in pounds.
     */
    public double getWeight() {
        return weight;
    }

    /**
     * This method returns the height of the person in feet and inches.
     *
     * @return The height of the person in feet and inches.
     */
    public String getHeight() {
        return feet + "" feet "" + inches + "" inches"";
    }
}
",0.5528612997090203
0_StackOfIntegers.java," /**
 * FIGURE 10.13 The StackOfIntegers class encapsulates the stack storage and provides
 * the operations for manipulating the stack.
 * ... . . .
 * elements[0]
 * elements[1]
 * elements[size  1]
 * capacity
 * top
 * bottom
 * size
 * elements[capacity  1]
 * How do you implement the StackOfIntegers class? The elements in the stack are stored
 * in an array named elements. When you create a stack, the array is also created. The no-arg
 * constructor creates an array with the default capacity of 16. The variable size counts the
 * number of elements in the stack, and size – 1 is the index of the element at the top of the
 * stack, as shown in Figure 10.13. For an empty stack, size is 0.
 * The StackOfIntegers class is implemented in Listing 10.8. The methods empty(),
 * peek(), pop(), and getSize() are easy to implement. To implement push(int value),
 * assign value to elements[size] if size < capacity (line 24). If the stack is full (i.e.,
 * size >= capacity), create a new array of twice the current capacity (line 19), copy the contents of
 * the current array to the new array (line 20), and assign the reference of the new array
 * to the current array in the stack (line 21). Now you can add the new value to the array (line 24).
 */ /**
     * Construct a stack with the default capacity 16
     */ /**
     * Construct a stack with the specified maximum capacity
     */ /**
     * Push a new integer to the top of the stack
     */ /**
     * Return and remove the top element from the stack
     */ /**
     * Return the top element from the stack
     */ /**
     * Test whether the stack is empty
     */ /**
     * Return the number of elements in the stack
     */","package ch_10.exercise10_05;


public class StackOfIntegers {
    private int[] elements;
    private int size;
    public static final int DEFAULT_CAPACITY = 16;

    
    public StackOfIntegers() {
        this(DEFAULT_CAPACITY);
    }

    
    public StackOfIntegers(int capacity) {
        elements = new int[capacity];
    }

    
    public void push(int value) {
        if (size >= elements.length) {
            int[] temp = new int[elements.length * 2];
            System.arraycopy(elements, 0, temp, 0, elements.length);
            elements = temp;
        }
        elements[size++] = value;
    }

    
    public int pop() {
        return elements[--size];
    }

    
    public int peek() {
        return elements[size - 1];
    }

    
    public boolean empty() {
        return size == 0;
    }

    
    public int getSize() {
        return size;
    }
}
","public class StackOfIntegers {
   private int[] elements;
   private int size;
   private int capacity;
   
   /**
    * Construct a stack with the default capacity 16
    */
   public StackOfIntegers() {
      this(16);
   }
   
   /**
    * Construct a stack with the specified maximum capacity
    */
   public StackOfIntegers(int capacity) {
      this.capacity = capacity;
      elements = new int[capacity];
   }
   
   /**
    * Push a new integer to the top of the stack
    */
   public void push(int value) {
      if (size >= capacity) {
         // create a new array with twice the current capacity
         int[] newElements = new int[capacity * 2];
         // copy the contents of the current array to the new array
         System.arraycopy(elements, 0, newElements, 0, size);
         // assign the reference of the new array to the current array in the stack
         elements = newElements;
         // update the capacity
         capacity *= 2;
      }
      elements[size++] = value;
   }
   
   /**
    * Return and remove the top element from the stack
    */
   public int pop() {
      if (size == 0) {
         throw new EmptyStackException();
      }
      return elements[--size];
   }
   
   /**
    * Return the top element from the stack
    */
   public int peek() {
      if (size == 0) {
         throw new EmptyStackException();
      }
      return elements[size - 1];
   }
   
   /**
    * Test whether the stack is empty
    */
   public boolean empty() {
      return size == 0;
   }
   
   /**
    * Return the number of elements in the stack
    */
   public int getSize() {
      return size;
   }
}
",5,"public class StackOfIntegers {
    private int[] elements; // This is where we store the integers
    private int capacity; // This is the maximum capacity of the stack
    private int size; // This is the current number of elements in the stack

    // Constructor with default capacity 16
    public StackOfIntegers() {
        this.capacity = 16; // Set the maximum capacity to 16
        this.elements = new int[this.capacity]; // Create an array to store the integers
        this.size = 0; // Initially, the stack is empty, so size is 0
    }

    // Constructor with specified maximum capacity
    public StackOfIntegers(int maxCapacity) {
        this.capacity = maxCapacity; // Set the maximum capacity to the specified value
        this.elements = new int[this.capacity]; // Create an array to store the integers
        this.size = 0; // Initially, the stack is empty, so size is 0
    }

    // Method to push a new integer onto the top of the stack
    public void push(int value) {
        if (size < capacity) {
            elements[size] = value; // Add the value to the stack
            size++; // Increment the size to reflect the addition
        } else {
            // If the stack is full, we need to expand it
            int[] newElements = new int[2 * capacity]; // Create a new array with double the capacity
            for (int i = 0; i < capacity; i++) {
                newElements[i] = elements[i]; // Copy the contents of the old array to the new one
            }
            elements = newElements; // Update the reference to the new array
            capacity *= 2; // Update the maximum capacity
            elements[size] = value; // Add the value to the stack
            size++; // Increment the size to reflect the addition
        }
    }

    // Method to return and remove the top element from the stack
    public int pop() {
        if (!empty()) {
            size--; // Decrement the size to remove the top element
            return elements[size]; // Return the removed element
        } else {
            throw new IllegalStateException(""Stack is empty"");
        }
    }

    // Method to return the top element from the stack without removing it
    public int peek() {
        if (!empty()) {
            return elements[size - 1]; // Return the top element
        } else {
            throw new IllegalStateException(""Stack is empty"");
        }
    }

    // Method to check whether the stack is empty
    public boolean empty() {
        return size == 0; // Check if the size is 0 to determine if the stack is empty
    }

    // Method to return the number of elements in the stack
    public int getSize() {
        return size; // Return the current size of the stack
    }
}
",0.5804735301942006
0_MyStringBuilder1.java," /**
 * **10.27 (Implement the StringBuilder class) The StringBuilder class is provided
 * in the Java library. Provide your own implementation for the following methods
 * (name the new class MyStringBuilder1):
 * public MyStringBuilder1(String s);
 * public MyStringBuilder1 append(MyStringBuilder1 s);
 * public MyStringBuilder1 append(int i);
 * public int length();
 * public char charAt(int index);
 * public MyStringBuilder1 toLowerCase();
 * public MyStringBuilder1 substring(int begin, int end);
 * public String toString();
 */","package ch_10.exercise10_27;


public class MyStringBuilder1 {
    char[] values;

    public MyStringBuilder1(String s) {
        values = s.toCharArray();
    }

    public MyStringBuilder1 append(MyStringBuilder1 s) {
        int oldLength = this.values.length;
        char[] nuValues = new char[oldLength + s.length()];
        System.arraycopy(this.values, 0, nuValues, 0, oldLength);
        System.arraycopy(s.values, 0, nuValues, oldLength, s.length());
        this.values = nuValues;
        return this;
    }

    public MyStringBuilder1 append(int i) {
        int oldLength = values.length;
        String temp = i + """";
        char[] nuVals = new char[values.length + temp.length()];
        char[] integer = temp.toCharArray();
        System.arraycopy(this.values, 0, nuVals, 0, this.values.length);
        System.arraycopy(integer, 0, nuVals, oldLength, integer.length);
        this.values = nuVals;
        return this;

    }

    public int length() {
        return values.length;
    }

    public char charAt(int index) {
        return values[index];
    }

    public MyStringBuilder1 toLowerCase() {
        char[] nu = new char[this.values.length];
        for (int i = 0; i < nu.length; i++) {
            nu[i] = Character.toLowerCase(this.values[i]);
        }
        return new MyStringBuilder1(String.valueOf(nu));
    }

    public MyStringBuilder1 substring(int begin, int end) {
        char[] nuVals = new char[end - begin];
        System.arraycopy(this.values, begin, nuVals, 0, nuVals.length);
        this.values = nuVals;
        return this;
    }

    @Override
    public String toString() {
        return String.valueOf(values);
    }
}
","public class MyStringBuilder1 {
    private char[] value;
    private int count;

    public MyStringBuilder1(String s) {
        value = s.toCharArray();
        count = value.length;
    }

    public MyStringBuilder1 append(MyStringBuilder1 s) {
        char[] newValue = new char[count + s.count];
        System.arraycopy(value, 0, newValue, 0, count);
        System.arraycopy(s.value, 0, newValue, count, s.count);
        count += s.count;
        value = newValue;
        return this;
    }

    public MyStringBuilder1 append(int i) {
        return append(String.valueOf(i));
    }

    public int length() {
        return count;
    }

    public char charAt(int index) {
        if (index < 0 || index >= count) {
            throw new IndexOutOfBoundsException();
        }
        return value[index];
    }

    public MyStringBuilder1 toLowerCase() {
        MyStringBuilder1 sb = new MyStringBuilder1("""");
        for (int i = 0; i < count; i++) {
            sb.append(Character.toLowerCase(value[i]));
        }
        return sb;
    }

    public MyStringBuilder1 substring(int begin, int end) {
        if (begin < 0 || end > count || begin > end) {
            throw new IndexOutOfBoundsException();
        }
        char[] newValue = new char[end - begin];
        System.arraycopy(value, begin, newValue, 0, end - begin);
        return new MyStringBuilder1(new String(newValue));
    }

    public String toString() {
        return new String(value, 0, count);
    }
}
",5,"public class MyStringBuilder1 {
    private char[] characters;
    private int size;

    // Constructor to initialize MyStringBuilder1 with a given string
    public MyStringBuilder1(String s) {
        this.size = s.length();
        this.characters = new char[size];
        for (int i = 0; i < size; i++) {
            this.characters[i] = s.charAt(i);
        }
    }

    // Method to append another MyStringBuilder1 object to this one
    public MyStringBuilder1 append(MyStringBuilder1 s) {
        char[] newChars = new char[size + s.length()];
        for (int i = 0; i < size; i++) {
            newChars[i] = this.characters[i];
        }
        for (int i = size; i < size + s.length(); i++) {
            newChars[i] = s.charAt(i - size);
        }
        this.characters = newChars;
        this.size += s.length();
        return this;
    }

    // Method to append an integer to this MyStringBuilder1 object
    public MyStringBuilder1 append(int i) {
        return this.append(new MyStringBuilder1(String.valueOf(i)));
    }

    // Method to get the length of the MyStringBuilder1 object
    public int length() {
        return this.size;
    }

    // Method to get the character at a specific index
    public char charAt(int index) {
        if (index >= 0 && index < size) {
            return this.characters[index];
        } else {
            throw new IndexOutOfBoundsException(""Index out of bounds"");
        }
    }

    // Method to convert all characters to lowercase
    public MyStringBuilder1 toLowerCase() {
        for (int i = 0; i < size; i++) {
            this.characters[i] = Character.toLowerCase(this.characters[i]);
        }
        return this;
    }

    // Method to get a substring from begin index to end index
    public MyStringBuilder1 substring(int begin, int end) {
        if (begin >= 0 && end <= size && begin <= end) {
            char[] subChars = new char[end - begin];
            for (int i = begin; i < end; i++) {
                subChars[i - begin] = this.characters[i];
            }
            return new MyStringBuilder1(new String(subChars));
        } else {
            throw new IndexOutOfBoundsException(""Invalid substring indices"");
        }
    }

    // Method to convert MyStringBuilder1 to a regular String
    public String toString() {
        return new String(this.characters);
    }
}
",0.5709886048660302
0_Exercise10_11.java," /**
 * Write a test
 * program that creates a Circle2D object c1 (new Circle2D(2, 2, 5.5)),
 * displays its area and perimeter, and displays the result of c1.contains(3,
 * 3), c1.contains(new Circle2D(4, 5, 10.5)), and c1.overlaps(new
 * Circle2D(3, 5, 2.3)).
 */","package ch_10.exercise10_11;


public class Exercise10_11 {

    public static void main(String[] args) {
        Circle2D c1 = new Circle2D(2, 2, 5.5);
        System.out.println(""Circle2D c1 = new Circle2D(2, 2, 5.5):"");
        String area = String.format(""%.4f"", c1.getArea());
        System.out.println(""Circle2D c1's area = "" + area);

        String p = String.format(""%.4f"", c1.getPerimeter());
        System.out.println(""perimeter = "" + p);

        System.out.println(""Result of c1.contains(3,3) = "" + c1.contains(3, 3));
        System.out.println(""Result of c1.contains(new Circle2D(4,5,10.5)) = "" + c1.contains(new Circle2D(4, 5, 10.5)));
        System.out.println(""Result of c1.overlaps(new Circle2D(3,5,2.3)) = "" + c1.overlaps(new Circle2D(3, 5, 2.3)));
    }
}
","public class Circle2DTest {
    public static void main(String[] args) {
        // Create a Circle2D object with center at (2, 2) and radius 5.5
        Circle2D c1 = new Circle2D(2, 2, 5.5);

        // Display area and perimeter of c1
        System.out.println(""Area of c1: "" + c1.getArea());
        System.out.println(""Perimeter of c1: "" + c1.getPerimeter());

        // Check if c1 contains the point (3, 3)
        System.out.println(""c1 contains point (3, 3): "" + c1.contains(3, 3));

        // Create a new Circle2D object with center at (4, 5) and radius 10.5
        Circle2D c2 = new Circle2D(4, 5, 10.5);

        // Check if c1 contains c2
        System.out.println(""c1 contains c2: "" + c1.contains(c2));

        // Create a new Circle2D object with center at (3, 5) and radius 2.3
        Circle2D c3 = new Circle2D(3, 5, 2.3);

        // Check if c1 overlaps c3
        System.out.println(""c1 overlaps c3: "" + c1.overlaps(c3));
    }
}
",5,"public class Circle2DTest {

    public static void main(String[] args) {
        
        // Create a Circle2D object c1
        Circle2D c1 = new Circle2D(2, 2, 5.5);

        // Display the area and perimeter of c1
        double areaOfC1 = c1.getArea();
        double perimeterOfC1 = c1.getPerimeter();
        System.out.println(""The area of c1 is: "" + areaOfC1);
        System.out.println(""The perimeter of c1 is: "" + perimeterOfC1);

        // Check if point (3, 3) is inside c1
        boolean isInside = c1.contains(3, 3);
        System.out.println(""Is point (3, 3) inside c1? "" + isInside);

        // Create a new Circle2D object c2
        Circle2D c2 = new Circle2D(4, 5, 10.5);

        // Check if c2 is inside c1
        boolean isC2InsideC1 = c1.contains(c2);
        System.out.println(""Is circle c2 inside c1? "" + isC2InsideC1);

        // Create another Circle2D object c3
        Circle2D c3 = new Circle2D(3, 5, 2.3);

        // Check if c3 overlaps with c1
        boolean doesC3OverlapC1 = c1.overlaps(c3);
        System.out.println(""Do circles c1 and c3 overlap? "" + doesC3OverlapC1);
    }
}
",0.7164835164835165
0_Circle2D.java," /**
 * *10.11 (Geometry: the Circle2D class) Define the Circle2D class that contains:
 * ■ Two double data fields named x and y that specify the center of the circle
 * with getter methods.
 * ■ A data field radius with a getter method.
 * ■ A no-arg constructor that creates a default circle with (0, 0) for (x, y) and 1
 * for radius.
 * ■ A constructor that creates a circle with the specified x, y, and radius.
 * ■ A method getArea() that returns the area of the circle.
 * ■ A method getPerimeter() that returns the perimeter of the circle.
 * ■ A method contains(double x, double y) that returns true if the
 * specified point (x, y) is inside this circle (see Figure 10.21a).
 * ■ A method contains(Circle2D circle) that returns true if the specified circle is inside this circle (see Figure 10.21b).
 * ■ A method overlaps(Circle2D circle) that returns true if the specified circle overlaps with this circle (see Figure 10.21c).
 * <p>
 * Draw the UML diagram for the class and then implement the class.
 */ /**
     * ■ A no-arg constructor that creates a default circle with (0, 0) for (x, y) and 1
     * for radius.
     */ /**
     * ■ A constructor that creates a circle with the specified x, y, and radius.
     */ /**
     * ■ A method getArea() that returns the area of the circle.
     */ /**
     * ■ A method getPerimeter() that returns the perimeter of the circle.
     */ /**
     * ■ A method contains(double x, double y) that returns true if the
     * specified point (x, y) is inside this circle (see Figure 10.21a).
     */ /**
     * ■ A method contains(Circle2D circle) that returns true if the specified circle is inside this circle (see Figure 10.21b).
     */ /**
     * ■ A method overlaps(Circle2D circle) that returns true if the specified circle overlaps with this circle (see Figure 10.21c).
     */","package ch_10.exercise10_11;
//__________________________UML DIAGRAM_____________________________*
/*                                                                                                                                        |
 *                                                          Circle2D                                                                  |
 *------------------------------------------------------------------|
 *                     -x : double                                                        |
 *                                           -y : double                                  |
 *                     -radius:double                                                                |
 *------------------------------------------------------------------|
 *                       +Circle2D()                                                                        |
 *          +Circle2D(x:double,y:double,radius:double)                        |
 *                                                                                                                                          |
 *                       +contains(x:double,y:double) : boolean                           |
 *                                                                                                                                         |
 *                       +contains(circle2D: Circle2D): boolean            |
 *                +overlaps(circle2D: Circle2D): boolean                   |
 *                                                                                                                                          |
 *                        +getPerimeter(): double                                                        |
 *                                                                                                                                  |
 *                        +getArea():double                                                                   |
 *                                                                                                                                         |
 * _________________________________________________________________|  */


public class Circle2D {
    /* ■ Two double data fields named x and y that specify the center of the circle with getter methods.*/
    private double x;
    private double y;
    /* ■ A data field radius with a getter method. */
    private double radius;

    
    public Circle2D() {
        x = 0;
        y = 0;
        radius = 1;
    }

    
    public Circle2D(double x, double y, double radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    
    public double getArea() {
        return Math.PI * Math.pow(radius, 2);
    }

    
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }

    
    public boolean contains(double x, double y) {
        double distanceFromCenterPoint = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
        return distanceFromCenterPoint < radius;

    }

    
    public boolean contains(Circle2D circle2D) {
        double distFromCenterPoints =
                Math.sqrt(Math.pow(circle2D.getX() - this.x, 2) + Math.pow(circle2D.getY() - this.y,
                        2));
        return this.radius > (distFromCenterPoints + circle2D.getRadius());
    }

    
    public boolean overlaps(Circle2D circle2D) {
        double distCentPoints = Math.sqrt(Math.pow(circle2D.getX() - this.x, 2) + Math.pow(circle2D.getY() - this.y, 2));
        double rSqSum = Math.pow(circle2D.getRadius() + this.radius, 2);
        return distCentPoints < rSqSum;
    }

    /* Getters */
    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getRadius() {
        return radius;
    }


}
","public class Circle2D {
    private double x;
    private double y;
    private double radius;

    public Circle2D() {
        this(0, 0, 1);
    }

    public Circle2D(double x, double y, double radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    public double getRadius() {
        return radius;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }

    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }

    public boolean contains(double x, double y) {
        double distance = Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        return distance < radius;
    }

    public boolean contains(Circle2D circle) {
        double distance = Math.sqrt((this.x - circle.x) * (this.x - circle.x) + (this.y - circle.y) * (this.y - circle.y));
        return distance + circle.radius <= radius;
    }

    public boolean overlaps(Circle2D circle) {
        double distance = Math.sqrt((this.x - circle.x) * (this.x - circle.x) + (this.y - circle.y) * (this.y - circle.y));
        return distance < this.radius + circle.radius;
    }
}
",5,"public class Circle2D {
    // Data fields
    private double x; // x-coordinate of the center
    private double y; // y-coordinate of the center
    private double radius; // radius of the circle
    
    // Default constructor
    public Circle2D() {
        this.x = 0;
        this.y = 0;
        this.radius = 1;
    }
    
    // Constructor with specified x, y, and radius
    public Circle2D(double x, double y, double radius) {
        this.x = x;
        this.y = y;
        this.radius = radius;
    }
    
    // Getter for x-coordinate
    public double getX() {
        return x;
    }
    
    // Getter for y-coordinate
    public double getY() {
        return y;
    }
    
    // Getter for radius
    public double getRadius() {
        return radius;
    }
    
    // Method to calculate the area of the circle
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    // Method to calculate the perimeter of the circle
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    // Method to check if a point is inside the circle
    public boolean contains(double x, double y) {
        double distance = Math.sqrt(Math.pow(this.x - x, 2) + Math.pow(this.y - y, 2));
        return distance < radius;
    }
    
    // Method to check if a circle is inside this circle
    public boolean contains(Circle2D circle) {
        double distance = Math.sqrt(Math.pow(this.x - circle.getX(), 2) + Math.pow(this.y - circle.getY(), 2));
        return distance + circle.getRadius() <= this.radius;
    }
    
    // Method to check if a circle overlaps with this circle
    public boolean overlaps(Circle2D circle) {
        double distance = Math.sqrt(Math.pow(this.x - circle.getX(), 2) + Math.pow(this.y - circle.getY(), 2));
        return distance < this.radius + circle.getRadius();
    }
}
",0.7209474463360473
0_Exercise10_10.java," /**
 * Write a test
 * program that adds 20 numbers from 1 to 20 into the queue and removes these
 * numbers and displays them.
 */","package ch_10.exercise10_10;


public class Exercise10_10 {
    public static void main(String[] args) {
        Queue q1 = new Queue();
        for (int i = 0; i < 20; i++) {
            int value = (int) (i + Math.random() * (int) (Math.random() * 9));
            q1.enqueue(value);
            System.out.println(""TestQueue.enqueue("" + value + "")"" + "" "");
        }
        for (int i = 0; i < 20; i++) {
            int value = q1.dequeue();
            System.out.println(""TestQueue.dequeue("" + value + "")"" + "" "");
        }
    }
}
","import java.util.LinkedList;
import java.util.Queue;

public class QueueTest {
    public static void main(String[] args) {
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 1; i <= 20; i++) {
            queue.add(i);
        }
        while (!queue.isEmpty()) {
            System.out.println(queue.remove());
        }
    }
}
",5,"// This is a program to add and remove numbers from a queue

// First, let's import the necessary libraries
import java.util.LinkedList;
import java.util.Queue;

// Now, let's create our class
public class NumberQueueProgram {

    public static void main(String[] args) {
        
        // Create a queue to hold our numbers
        Queue<Integer> numberQueue = new LinkedList<Integer>();
        
        // Let's add numbers from 1 to 20 into the queue
        for (int i = 1; i <= 20; i++) {
            numberQueue.add(i); // We are adding the number 'i' to the queue
        }
        
        // Now, let's remove and display these numbers
        System.out.println(""Removing and displaying numbers from the queue:"");
        while (!numberQueue.isEmpty()) {
            int removedNumber = numberQueue.poll(); // We are removing a number from the queue
            System.out.println(""Removed number: "" + removedNumber);
        }
    }
}
",0.496415770609319
0_Exercise16_06.java," /**
 * 16.6 (Demonstrate TextField properties) Write a program that sets the horizontal
 * alignment and column-size properties of a text field dynamically, as shown in
 * Figure 16.38a.
 */","package ch_16;

import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.RadioButton;
import javafx.scene.control.TextField;
import javafx.scene.control.ToggleGroup;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;


public class Exercise16_06 extends Application {

    @Override
    public void start(Stage primaryStage) {
        TextField tfTextField = new TextField();
        TextField tfPrefColumnSize = new TextField();
        tfTextField.setAlignment(Pos.BOTTOM_RIGHT);
        tfPrefColumnSize.setAlignment(Pos.BOTTOM_RIGHT);
        tfPrefColumnSize.setAlignment(Pos.BOTTOM_RIGHT);
        tfTextField.setPrefColumnCount(13);
        tfPrefColumnSize.setPrefColumnCount(3);

        HBox hBox1 = new HBox(5);
        hBox1.setAlignment(Pos.CENTER);
        hBox1.getChildren().addAll(new Label(""Text Field""),
                tfTextField);

        HBox hBox2 = new HBox(5);
        hBox2.setAlignment(Pos.CENTER);
        RadioButton rbLeft = new RadioButton(""Left"");
        RadioButton rbCenter = new RadioButton(""Center"");
        RadioButton rbRight = new RadioButton(""Right"");
        hBox2.getChildren().addAll(rbLeft, rbCenter, rbRight);

        ToggleGroup group = new ToggleGroup();
        rbLeft.setToggleGroup(group);
        rbCenter.setToggleGroup(group);
        rbRight.setToggleGroup(group);

        HBox hBox3 = new HBox(5);
        hBox3.getChildren().addAll(new Label(""Column Size""),
                tfPrefColumnSize);

        HBox hBox4 = new HBox(15);
        hBox4.setAlignment(Pos.CENTER);
        hBox4.getChildren().addAll(hBox2, hBox3);

        VBox vBox = new VBox(5);
        vBox.getChildren().addAll(hBox1, hBox4);

        Scene scene = new Scene(vBox);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

        tfPrefColumnSize.setOnAction(e -> {
            tfTextField.setPrefColumnCount(
                    Integer.parseInt(tfPrefColumnSize.getText()));
        });

        rbLeft.setOnAction(e -> tfTextField.setAlignment(Pos.BASELINE_LEFT));
        rbCenter.setOnAction(e -> tfTextField.setAlignment(Pos.BASELINE_CENTER));
        rbRight.setOnAction(e -> tfTextField.setAlignment(Pos.BASELINE_RIGHT));
    }
}
","import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextField;

public class TextFieldExample extends JFrame {

    public TextFieldExample() {
        JPanel panel = new JPanel();
        JTextField textField = new JTextField(20); // creates a text field with 20 columns
        textField.setHorizontalAlignment(JTextField.CENTER); // sets the horizontal alignment to center
        panel.add(textField);
        add(panel);
        setSize(300, 100);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setVisible(true);
    }

    public static void main(String[] args) {
        new TextFieldExample();
    }
}
",1,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.TextField;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
import javafx.geometry.Pos;

public class TextFieldPropertiesDemo extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Creating a TextField
        TextField textField = new TextField(""Enter text here"");

        // Setting properties dynamically
        textField.setAlignment(Pos.CENTER); // Setting horizontal alignment to CENTER
        textField.setPrefColumnCount(15);  // Setting column size to 15

        // Adding some unnecessary details
        StackPane root = new StackPane();
        root.getChildren().add(textField);

        // Creating a scene with redundant details
        Scene scene = new Scene(root, 300, 150);

        // Setting up the stage with excessive configurations
        primaryStage.setTitle(""TextField Properties Demo"");
        primaryStage.setScene(scene);
        primaryStage.setResizable(false); // Disabling resizing for no apparent reason
        primaryStage.show();
    }

    // Adding a method with excessive details
    private void someExtraMethod() {
        System.out.println(""This is an extra method with unnecessary details."");
        // Adding more irrelevant code here
    }
}
",0.4345464421510049
0_ClockPane.java," /**
 * ClockPane from Listing 14.21
 */ /**
     * Construct a default clock with the current time
     */ /**
     * Construct a clock with specified hour, minute, and second
     */ /**
     * Return hour
     */ /**
     * Set a new hour
     */ /**
     * Return minute
     */ /**
     * Set a new minute
     */ /**
     * Return second
     */ /**
     * Set a new second
     */ /**
     * Return clock pane's width
     */ /**
     * Set clock pane's width
     */ /**
     * Return clock pane's height
     */ /**
     * Set clock pane's height
     */ /**
     * Paint the clock
     */","package ch_16.exercise16_07;

import java.util.Calendar;
import java.util.GregorianCalendar;

import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;


public class ClockPane extends Pane {
    private int hour;
    private int minute;
    private int second;

    // Clock pane's width and height
    private double w = 250, h = 250;

    
    public ClockPane() {
        setCurrentTime();

    }

    
    public ClockPane(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        paintClock();

    }

    
    public int getHour() {
        return hour;

    }

    
    public void setHour(int hour) {
        this.hour = hour;
        paintClock();

    }

    
    public int getMinute() {
        return minute;

    }

    
    public void setMinute(int minute) {
        this.minute = minute;
        paintClock();
    }

    
    public int getSecond() {
        return second;
    }

    
    public void setSecond(int second) {
        this.second = second;
        paintClock();
    }

    
    public double getW() {
        return w;
    }

    
    public void setW(double w) {
        this.w = w;
        paintClock();
    }

    
    public double getH() {
        return h;
    }

    
    public void setH(double h) {
        this.h = h;
        paintClock();
    }

    /* Set the current time for the clock */
    public void setCurrentTime() {
        // Construct a calendar for the current date and time
        Calendar calendar = new GregorianCalendar();
        // Set current hour, minute and second
        this.hour = calendar.get(Calendar.HOUR_OF_DAY);
        this.minute = calendar.get(Calendar.MINUTE);
        this.second = calendar.get(Calendar.SECOND);

        paintClock(); // Repaint the clock
    }


    
    protected void paintClock() {
        // Initialize clock parameters
        double clockRadius = Math.min(w, h) * 0.8 * 0.5;
        double centerX = w / 2;
        double centerY = h / 2;

        // Draw circle


        Circle circle = new Circle(centerX, centerY, clockRadius);
        circle.setFill(Color.WHITE);
        circle.setStroke(Color.BLACK);
        Text t1 = new Text(centerX - 5, centerY - clockRadius + 12, ""12"");
        Text t2 = new Text(centerX - clockRadius + 3, centerY + 5, ""9"");
        Text t3 = new Text(centerX + clockRadius - 10, centerY + 3, ""3"");
        Text t4 = new Text(centerX - 3, centerY + clockRadius - 3, ""6"");

        // Draw second hand
        double sLength = clockRadius * 0.8;
        double secondX = centerX + sLength *
                Math.sin(second * (2 * Math.PI / 60));
        double secondY = centerY - sLength *
                Math.cos(second * (2 * Math.PI / 60));
        Line sLine = new Line(centerX, centerY, secondX, secondY);
        sLine.setStroke(Color.RED);

        // Draw minute hand
        double mLength = clockRadius * 0.65;
        double xMinute = centerX + mLength *
                Math.sin(minute * (2 * Math.PI / 60));
        double minuteY = centerY - mLength *
                Math.cos(minute * (2 * Math.PI / 60));
        Line mLine = new Line(centerX, centerY, xMinute, minuteY);
        mLine.setStroke(Color.BLUE);

        // Draw hour hand
        double hLength = clockRadius * 0.5;
        double hourX = centerX + hLength *
                Math.sin((hour % 12 + minute / 60.0) * (2 * Math.PI / 12));
        double hourY = centerY - hLength *
                Math.cos((hour % 12 + minute / 60.0) * (2 * Math.PI / 12));
        Line hLine = new Line(centerX, centerY, hourX, hourY);
        hLine.setStroke(Color.GREEN);

        getChildren().clear();
        getChildren().addAll(circle, t1, t2, t3, t4, sLine, mLine, hLine);
    }
}","import java.time.LocalTime;
import javafx.animation.Animation;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Font;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import javafx.util.Duration;

public class DefaultClock extends Application {
    
    private int hour;
    private int minute;
    private int second;
    
    private double width = 400;
    private double height = 400;
    
    public DefaultClock() {
        LocalTime now = LocalTime.now();
        this.hour = now.getHour();
        this.minute = now.getMinute();
        this.second = now.getSecond();
        
        Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(1), e -> {
            tick();
            paintClock();
        }));
        timeline.setCycleCount(Animation.INDEFINITE);
        timeline.play();
    }
    
    private void tick() {
        second++;
        if (second >= 60) {
            second = 0;
            minute++;
            if (minute >= 60) {
                minute = 0;
                hour++;
                if (hour >= 24) {
                    hour = 0;
                }
            }
        }
    }
    
    private void paintClock() {
        double centerX = width / 2;
        double centerY = height / 2;
        double radius = Math.min(width, height) * 0.4;
        
        Circle circle = new Circle(centerX, centerY, radius);
        circle.setFill(Color.WHITE);
        circle.setStroke(Color.BLACK);
        circle.setStrokeWidth(2);
        
        Text[] numbers = new Text[12];
        for (int i = 0; i < 12; i++) {
            double angle = i * 30 * Math.PI / 180;
            double x = centerX + (radius - 30) * Math.sin(angle);
            double y = centerY - (radius - 30) * Math.cos(angle);
            numbers[i] = new Text(x, y, Integer.toString((i == 0) ? 12 : i));
            numbers[i].setFont(Font.font(""Arial"", 20));
        }
        
        Line hourHand = new Line(centerX, centerY, centerX + radius * 0.4 * Math.sin(hour * 30 * Math.PI / 180),
                centerY - radius * 0.4 * Math.cos(hour * 30 * Math.PI / 180));
        hourHand.setStrokeWidth(6);
        hourHand.setStroke(Color.BLACK);
        
        Line minuteHand = new Line(centerX, centerY, centerX + radius * 0.6 * Math.sin(minute * 6 * Math.PI / 180),
                centerY - radius * 0.6 * Math.cos(minute * 6 * Math.PI / 180));
        minuteHand.setStrokeWidth(4);
        minuteHand.setStroke(Color.BLUE);
        
        Line secondHand = new Line(centerX, centerY, centerX + radius * 0.8 * Math.sin(second * 6 * Math.PI / 180),
                centerY - radius * 0.8 * Math.cos(second * 6 * Math.PI / 180));
        secondHand.setStrokeWidth(2);
        secondHand.setStroke(Color.RED);
        
        Group group = new Group(circle, hourHand, minuteHand, secondHand);
        for (Text number : numbers) {
            group.getChildren().add(number);
        }
        
        Scene scene = new Scene(group, width, height);
        Stage stage = new Stage();
        stage.setScene(scene);
        stage.show();
    }
",1,"import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.text.Text;
import java.util.Calendar;
import java.util.TimeZone;

public class ClockPane extends Pane {

    private int hour;
    private int minute;
    private int second;
    private double clockPaneWidth;
    private double clockPaneHeight;

    public ClockPane() {
        setCurrentTime();
        paintClock();
    }

    public ClockPane(int hour, int minute, int second) {
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        paintClock();
    }

    public int getHour() {
        return hour;
    }

    public void setHour(int hour) {
        this.hour = hour;
        paintClock();
    }

    public int getMinute() {
        return minute;
    }

    public void setMinute(int minute) {
        this.minute = minute;
        paintClock();
    }

    public int getSecond() {
        return second;
    }

    public void setSecond(int second) {
        this.second = second;
        paintClock();
    }

    public double getClockPaneWidth() {
        return clockPaneWidth;
    }

    public void setClockPaneWidth(double clockPaneWidth) {
        this.clockPaneWidth = clockPaneWidth;
        paintClock();
    }

    public double getClockPaneHeight() {
        return clockPaneHeight;
    }

    public void setClockPaneHeight(double clockPaneHeight) {
        this.clockPaneHeight = clockPaneHeight;
        paintClock();
    }

    public void paintClock() {
        getChildren().clear();

        // Drawing clock circle
        Circle circle = new Circle(clockPaneWidth / 2, clockPaneHeight / 2, clockPaneWidth / 2);
        circle.setFill(Color.WHITE);
        circle.setStroke(Color.BLACK);
        getChildren().add(circle);

        // Drawing clock hands
        double centerX = clockPaneWidth / 2;
        double centerY = clockPaneHeight / 2;

        double secondLength = clockPaneWidth * 0.4;
        double secondX = centerX + secondLength * Math.sin(second * (2 * Math.PI / 60));
        double secondY = centerY - secondLength * Math.cos(second * (2 * Math.PI / 60));
        Line secondHand = new Line(centerX, centerY, secondX, secondY);
        secondHand.setStroke(Color.RED);
        getChildren().add(secondHand);

        // Adding more unnecessary details like hour and minute hands
        double minuteLength = clockPaneWidth * 0.35;
        double minuteX = centerX + minuteLength * Math.sin(minute * (2 * Math.PI / 60));
        double minuteY = centerY - minuteLength * Math.cos(minute * (2 * Math.PI / 60));
        Line minuteHand = new Line(centerX, centerY, minuteX, minuteY);
        minuteHand.setStroke(Color.BLUE);
        getChildren().add(minuteHand);

        double hourLength = clockPaneWidth * 0.3;
        double hourX = centerX + hourLength * Math.sin((hour % 12 + minute / 60.0) * (2 * Math.PI / 12));
        double hourY = centerY - hourLength * Math.cos((hour % 12 + minute / 60.0) * (2 * Math.PI / 12));
        Line hourHand = new Line(centerX, centerY, hourX, hourY);
        hourHand.setStroke(Color.GREEN);
        getChildren().add(hourHand);

        // Adding unnecessary text details
        Text text = new Text(centerX - 8, centerY + clockPaneHeight / 2 - 8, ""12"");
        getChildren().add(text);
    }

    private void setCurrentTime() {
        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        this.hour = calendar.get(Calendar.HOUR_OF_DAY);
        this.minute = calendar.get(Calendar.MINUTE);
        this.second = calendar.get(Calendar.SECOND);
    }
}
",0.5172942579655818
0_Exercise16_07.java," /**
 * *16.7 (Set clock time) Write a program that displays a clock and sets the time with the
 * input from three text fields, as shown in Figure 16.38b. Use the ClockPane in
 * Listing 14.21. Resize the clock to the center of the pane.
 */","package ch_16.exercise16_07;

import javafx.application.Application;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.util.converter.NumberStringConverter;


public class Exercise16_07 extends Application {
    private double WIDTH = 450;
    private double HEIGHT = 400;
    SimpleIntegerProperty hourProperty = new SimpleIntegerProperty(12);
    SimpleIntegerProperty minuteProperty = new SimpleIntegerProperty(0);
    SimpleIntegerProperty secondProperty = new SimpleIntegerProperty(0);

    @Override
    public void start(Stage primaryStage) {

        VBox mainLayoutBox = new VBox(5);
        HBox inputsBox = new HBox(1);
        ClockPane clockPane = new ClockPane();

        Label hourLabel = new Label(""Hour"");
        Label minutelabel = new Label(""Minute"");
        Label secondsLabel = new Label(""Second"");

        TextField hourInput = new TextField();
        TextField minuteInput = new TextField();
        TextField secondInput = new TextField();
        hourInput.textProperty().bindBidirectional(hourProperty, new NumberStringConverter());
        minuteInput.textProperty().bindBidirectional(minuteProperty, new NumberStringConverter());
        secondInput.textProperty().bindBidirectional(secondProperty, new NumberStringConverter());

        inputsBox.getChildren().add(hourLabel);
        inputsBox.getChildren().add(hourInput);
        inputsBox.getChildren().add(minutelabel);
        inputsBox.getChildren().add(minuteInput);
        inputsBox.getChildren().add(secondsLabel);
        inputsBox.getChildren().add(secondInput);


        /* Add ClockPane to Parent Pane*/
        mainLayoutBox.getChildren().add(clockPane);
        VBox.setVgrow(clockPane, Priority.ALWAYS);
        /* Add input footer to parent Pane */
        mainLayoutBox.getChildren().add(inputsBox);

        mainLayoutBox.widthProperty().addListener((observable, oldValue, newValue) -> {
            hourInput.setMaxWidth(newValue.doubleValue() / 6); // Set max width of input boxes to 1/6th total width of parent Pane
            secondInput.setMaxWidth(newValue.doubleValue() / 6);
            minuteInput.setMaxWidth(newValue.doubleValue() / 6);
            clockPane.setW(newValue.doubleValue());
        });
        mainLayoutBox.heightProperty().addListener((observable, oldValue, newValue) -> {
            Number inputFooterHeight = inputsBox.getHeight();
            clockPane.setH(newValue.doubleValue() - inputFooterHeight.doubleValue());
        });

        clockPane.setHour(hourProperty.intValue());
        clockPane.setMinute(minuteProperty.intValue());
        clockPane.setSecond(secondProperty.intValue());

        hourProperty.addListener((o, ov, nv) -> {
            clockPane.setHour(nv.intValue());
        });
        minuteProperty.addListener((o, ov, nv) -> {
            clockPane.setMinute(nv.intValue());
        });
        secondProperty.addListener((o, ov, nv) -> {
            clockPane.setSecond(nv.intValue());
        });

        Scene scene = new Scene(mainLayoutBox, WIDTH, HEIGHT);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.show();


    }
}
","import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;

public class ClockExample extends JFrame {

    private JLabel timeLabel;

    public ClockExample() {
        JPanel panel = new JPanel();
        timeLabel = new JLabel();
        panel.add(timeLabel);
        add(panel);
        setSize(200, 200);
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setVisible(true);
        updateTime();
    }

    public void updateTime() {
        Thread t = new Thread() {
            public void run() {
                while (true) {
                    try {
                        int hour = Integer.parseInt(hourTextField.getText());
                        int minute = Integer.parseInt(minuteTextField.getText());
                        int second = Integer.parseInt(secondTextField.getText());
                        Calendar calendar = new GregorianCalendar();
                        calendar.set(Calendar.HOUR_OF_DAY, hour);
                        calendar.set(Calendar.MINUTE, minute);
                        calendar.set(Calendar.SECOND, second);
                        Date time = calendar.getTime();
                        timeLabel.setText(time.toString());
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t.start();
    }

    public static void main(String[] args) {
        new ClockExample();
    }

    private JTextField hourTextField, minuteTextField, secondTextField;

    public ClockExample() {
        JPanel panel = new JPanel();
        hourTextField = new JTextField(""0"", 2);
        minuteTextField = new JTextField(""0"", 2);
        secondTextField = new JTextField(""0"", 2);
        panel.add(hourTextField);
        panel.add(minuteTextField);
        panel.add(secondTextField);
        add(panel, BorderLayout.NORTH);
        timeLabel = new JLabel();
        panel.add(timeLabel);
        add(panel, BorderLayout.CENTER);
        setSize(300, 300);
        setLocationRelativeTo(null);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setVisible(true);
        updateTime();
    }

}
",3,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class ClockTimeSetter extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Creating clock pane
        ClockPane clockPane = new ClockPane();

        // Creating labels and text fields
        Label hourLabel = new Label(""Hour:"");
        TextField hourField = new TextField();

        Label minuteLabel = new Label(""Minute:"");
        TextField minuteField = new TextField();

        Label secondLabel = new Label(""Second:"");
        TextField secondField = new TextField();

        // Adding unnecessary details
        Label titleLabel = new Label(""Set Clock Time"");
        titleLabel.setStyle(""-fx-font-size: 20; -fx-font-weight: bold;"");

        // Adding functionality to set clock time
        hourField.setOnAction(e -> setClockTime(clockPane));
        minuteField.setOnAction(e -> setClockTime(clockPane));
        secondField.setOnAction(e -> setClockTime(clockPane));

        // Creating layout and adding elements
        HBox layout = new HBox(10);
        layout.getChildren().addAll(
                hourLabel, hourField,
                minuteLabel, minuteField,
                secondLabel, secondField,
                titleLabel
        );

        // Adding unnecessary styling
        layout.setStyle(""-fx-padding: 20; -fx-background-color: #eeeeee;"");

        // Creating the scene
        Scene scene = new Scene(layout, 400, 300);

        // Adding unnecessary details to the stage
        primaryStage.setTitle(""Clock Time Setter"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    private void setClockTime(ClockPane clockPane) {
        try {
            // Getting values from text fields
            int hour = Integer.parseInt(hourField.getText());
            int minute = Integer.parseInt(minuteField.getText());
            int second = Integer.parseInt(secondField.getText());

            // Setting the time on the clock pane
            clockPane.setHour(hour);
            clockPane.setMinute(minute);
            clockPane.setSecond(second);
        } catch (NumberFormatException e) {
            // Adding unnecessary error handling
            System.out.println(""Invalid input. Please enter numeric values for hour, minute, and second."");
        }
    }
}
",0.4228426395939086
0_Exercise16_09.java," /**
 * **16.9 (Geometry: two rectangles intersect?) Write a program that enables the user to
 * specify the location and size of the rectangles and displays whether the two rectangles intersect,
 * as shown in Figure 16.39b. Enable the user to point the mouse
 * inside a rectangle and drag it. As the rectangle is being dragged, the rectangle’s
 * center coordinates in the text fields are updated.
 */","package ch_16.exercise16_09;

import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.stage.Stage;


public class Exercise16_09 extends Application {
    private RectangleExt rectangle1;
    private RectangleExt rectangle2;
    private Rectangle layoutRect;
    private Pane drawPane;

    private TextField r1centerXTextField;
    private TextField r1centerYTextField;
    private TextField r1WidthTextField;
    private TextField r1HeightTextField;
    private TextField r2centerXTextField;
    private TextField r2centerYTextField;
    private TextField r2WidthTextField;
    private TextField r2HeightTextField;

    @Override
    public void start(Stage primaryStage) {
        layoutRect = new Rectangle(0, 0, 250, 110);
        layoutRect.setStroke(Color.WHITE);
        layoutRect.setFill(Color.WHITE);
        rectangle1 = new RectangleExt(52.0, 60.0, Color.WHITE);
        rectangle1.setTopLeft(new Pt(200, 10));
        rectangle1.setStroke(Color.BLACK);
        rectangle2 = new RectangleExt(80.0, 56.0, Color.WHITE);
        rectangle2.setStroke(Color.BLACK);
        rectangle2.setTopLeft(new Pt(60, 10));

        drawPane = new Pane(layoutRect, rectangle1, rectangle2);
        r1centerXTextField = new TextField();
        r2centerXTextField = new TextField();
        r1centerYTextField = new TextField();
        r2centerYTextField = new TextField();
        r1WidthTextField = new TextField();
        r1HeightTextField = new TextField();
        r2WidthTextField = new TextField();
        r2HeightTextField = new TextField();
        r1centerXTextField.setPrefColumnCount(3);
        r1centerYTextField.setPrefColumnCount(3);
        r1HeightTextField.setPrefColumnCount(3);
        r2centerXTextField.setPrefColumnCount(3);
        r2centerYTextField.setPrefColumnCount(3);
        r2WidthTextField.setPrefColumnCount(3);


        r1centerXTextField.setText(String.valueOf(rectangle1.getCenter().getX()));
        r1centerYTextField.setText(String.valueOf(rectangle1.getCenter().getY()));
        r1WidthTextField.setText(String.valueOf(rectangle1.getWidth()));
        r1HeightTextField.setText(String.valueOf(rectangle1.getHeight()));

        r2centerXTextField.setText(String.valueOf(rectangle2.getCenter().getX()));
        r2centerYTextField.setText(String.valueOf(rectangle2.getCenter().getY()));
        r2WidthTextField.setText(String.valueOf(rectangle2.getWidth()));
        r2HeightTextField.setText(String.valueOf(rectangle2.getHeight()));

        VBox paneForTable1 = getInputGrid(r1centerXTextField,
                r1centerYTextField, r1WidthTextField, r1HeightTextField, 1);

        VBox paneForTable2 = getInputGrid(r2centerXTextField,
                r2centerYTextField, r2WidthTextField, r2HeightTextField, 2);

        HBox paneForTables = new HBox(5);
        paneForTables.setAlignment(Pos.CENTER);
        paneForTables.getChildren().addAll(paneForTable1, paneForTable2);
        Button redrawButton = new Button(""Redraw Rectangles"");
        VBox vBox = new VBox();
        vBox.setAlignment(Pos.CENTER);
        vBox.getChildren().addAll(intersect(), drawPane,
                paneForTables, redrawButton);
        redrawButton.setOnAction(e -> {
            draw();
            vBox.getChildren().remove(0);
            vBox.getChildren().add(0, intersect());
        });

        rectangle1.setOnMouseDragged(e -> {
                rectangle1.setTopLeft(new Pt(e.getX(), e.getY()));
                r1centerXTextField.setText(String.valueOf(rectangle1.getCenter().getX()));
                r1centerYTextField.setText(String.valueOf(rectangle1.getCenter().getY()));
            vBox.getChildren().remove(0);
            vBox.getChildren().add(0, intersect());
        });

        rectangle2.setOnMouseDragged(e -> {
                rectangle2.setTopLeft(new Pt(e.getX(), e.getY()));
                r2centerXTextField.setText(String.valueOf(rectangle2.getCenter().getX()));
                r2centerYTextField.setText(String.valueOf(rectangle2.getCenter().getY()));
            vBox.getChildren().remove(0);
            vBox.getChildren().add(0, intersect());

        });

        Scene scene = new Scene(vBox);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.show();

        vBox.widthProperty().addListener(ov ->
                layoutRect.widthProperty().bind(vBox.widthProperty())
        );

        vBox.heightProperty().addListener(ov ->
                layoutRect.heightProperty().bind(vBox.heightProperty().multiply(0.5))
        );

        vBox.heightProperty().addListener(ov ->
                layoutRect.heightProperty().bind(vBox.heightProperty().multiply(0.5))
        );

        layoutRect.setWidth(vBox.getWidth());
        layoutRect.setHeight(vBox.getHeight());


    }


    private Text intersect() {
        return new Text(""Two rectangles intersect? "" + checkIntersection());
    }


    String checkIntersection() {
        if (rectangle1.overlaps(rectangle2)) {
            return ""Yes"";
        }

        return ""No"";
    }

    protected VBox getInputGrid(
            TextField x,
            TextField y,
            TextField w,
            TextField h,
            int n) {
        VBox vBox = new VBox(1);
        GridPane gridPane = new GridPane();
        gridPane.setHgap(5);
        gridPane.setVgap(5);
        gridPane.add(new Label(""Center X:""), 0, 0);
        gridPane.add(x, 1, 0);
        gridPane.add(new Label(""Center Y:""), 0, 1);
        gridPane.add(y, 1, 1);
        gridPane.add(new Label(""Width:""), 0, 2);
        gridPane.add(w, 1, 2);
        gridPane.add(new Label(""Height:""), 0, 3);
        gridPane.add(h, 1, 3);
        vBox.getChildren().addAll(new Label(""Enter rectangle "" +
                n + "" info:""), gridPane);
        return vBox;
    }

    private void draw() {
        double x1 = Double.parseDouble(r1centerXTextField.getText());
        if (x1 != rectangle1.getCenter().getX()) {
            rectangle1.setCenter(new Pt(x1, rectangle1.getCenter().getY()));
        }

        double y1 = Double.parseDouble(r1centerYTextField.getText());
        if (y1 != rectangle1.getCenter().getY()) {
            rectangle1.setCenter(new Pt(rectangle1.getCenter().getX(), y1));
        }

        double x2 = Double.parseDouble(r2centerXTextField.getText());
        if (x2 != rectangle2.getCenter().getX()) {
            rectangle2.setCenter(new Pt(x2, rectangle2.getCenter().getY()));
        }

        double y2 = Double.parseDouble(r2centerYTextField.getText());
        if (y2 != rectangle2.getCenter().getY()) {
            rectangle2.setCenter(new Pt(rectangle2.getCenter().getX(), y2));
        }

        double h1 = Double.parseDouble(r1HeightTextField.getText());
        if (h1 != rectangle1.getHeight()) {
            rectangle1.setHeight(h1);
        }

        double w1 = Double.parseDouble(r1WidthTextField.getText());
        if (w1 != rectangle1.getWidth()) {
            rectangle1.setWidth(w1);
        }

        double w2 = Double.parseDouble(r2WidthTextField.getText());
        if (w2 != rectangle2.getWidth()) {
            rectangle2.setWidth(w2);
        }

        double h2 = Double.parseDouble(r2HeightTextField.getText());
        if (h2 != rectangle2.getHeight()) {
            rectangle2.setHeight(h2);
        }


    }
}","import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class RectangleIntersection extends Application {

    private Rectangle rect1;
    private Rectangle rect2;
    private Text center1X;
    private Text center1Y;
    private Text center2X;
    private Text center2Y;

    @Override
    public void start(Stage primaryStage) {
        // create the rectangles and center coordinate texts
        rect1 = new Rectangle(50, 50, 100, 100);
        rect1.setFill(Color.TRANSPARENT);
        rect1.setStroke(Color.BLACK);
        rect2 = new Rectangle(200, 150, 150, 75);
        rect2.setFill(Color.TRANSPARENT);
        rect2.setStroke(Color.BLACK);
        center1X = new Text(rect1.getX() + rect1.getWidth() / 2, rect1.getY() + rect1.getHeight() / 2, String.valueOf(rect1.getX() + rect1.getWidth() / 2));
        center1Y = new Text(rect1.getX() + rect1.getWidth() / 2, rect1.getY() + rect1.getHeight() / 2 + 20, String.valueOf(rect1.getY() + rect1.getHeight() / 2));
        center2X = new Text(rect2.getX() + rect2.getWidth() / 2, rect2.getY() + rect2.getHeight() / 2, String.valueOf(rect2.getX() + rect2.getWidth() / 2));
        center2Y = new Text(rect2.getX() + rect2.getWidth() / 2, rect2.getY() + rect2.getHeight() / 2 + 20, String.valueOf(rect2.getY() + rect2.getHeight() / 2));

        // set up the event handlers for dragging the rectangles
        rect1.setOnMouseDragged(e -> {
            rect1.setX(e.getX() - rect1.getWidth() / 2);
            rect1.setY(e.getY() - rect1.getHeight() / 2);
            updateCenterText(center1X, center1Y, rect1);
            checkIntersection();
        });
        rect2.setOnMouseDragged(e -> {
            rect2.setX(e.getX() - rect2.getWidth() / 2);
            rect2.setY(e.getY() - rect2.getHeight() / 2);
            updateCenterText(center2X, center2Y, rect2);
            checkIntersection();
        });

        // create the pane and add the shapes and texts to it
        Pane pane = new Pane();
        pane.getChildren().addAll(rect1, rect2, center1X, center1Y, center2X, center2Y);

        // set up the stage and show it
        primaryStage.setTitle(""Rectangle Intersection"");
        primaryStage.setScene(new Scene(pane, 400, 400));
        primaryStage.show();

        // check for initial intersection
        checkIntersection();
    }

    private void updateCenterText(Text centerX, Text centerY, Rectangle rect) {
        centerX.setText(String.valueOf(rect.getX() + rect.getWidth() / 2));
        centerY.setText(String.valueOf(rect.getY() + rect.getHeight() / 2));
    }

    private void checkIntersection() {
        if (rect1.getBoundsInParent().intersects(rect2.getBoundsInParent())) {
            System.out.println(""Rectangles intersect"");
        } else {
            System.out.println(""Rectangles do not intersect"");
        }
    }

    public static void main(String[] args) {
        launch(args);
    }

}
",1,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;

public class RectangleIntersect extends Application {

    private Rectangle rectangle1;
    private Rectangle rectangle2;
    private TextField rect1XField;
    private TextField rect1YField;
    private TextField rect2XField;
    private TextField rect2YField;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Creating rectangles
        rectangle1 = createRectangle(50, 50, 100, 80, Color.BLUE);
        rectangle2 = createRectangle(200, 100, 120, 60, Color.RED);

        // Creating text fields for rectangle coordinates
        rect1XField = createTextField(20, 20);
        rect1YField = createTextField(20, 50);
        rect2XField = createTextField(170, 20);
        rect2YField = createTextField(170, 50);

        // Adding unnecessary labels
        Label rect1Label = new Label(""Rectangle 1:"");
        Label rect2Label = new Label(""Rectangle 2:"");

        // Adding rectangles to a layout
        Pane root = new Pane();
        root.getChildren().addAll(rectangle1, rectangle2, rect1XField, rect1YField, rect2XField, rect2YField, rect1Label, rect2Label);

        // Adding unnecessary details to the stage
        primaryStage.setTitle(""Rectangle Intersect Checker"");
        primaryStage.setScene(new Scene(root, 400, 300));
        primaryStage.show();

        // Adding mouse event handlers
        rectangle1.setOnMouseDragged(e -> dragRectangle(rectangle1, rect1XField, rect1YField, e));
        rectangle2.setOnMouseDragged(e -> dragRectangle(rectangle2, rect2XField, rect2YField, e));
    }

    private Rectangle createRectangle(double x, double y, double width, double height, Color color) {
        Rectangle rectangle = new Rectangle(x, y, width, height);
        rectangle.setFill(color);
        rectangle.setStroke(Color.BLACK);
        return rectangle;
    }

    private TextField createTextField(double x, double y) {
        TextField textField = new TextField();
        textField.setLayoutX(x);
        textField.setLayoutY(y);
        textField.setEditable(false);
        return textField;
    }

    private void dragRectangle(Rectangle rectangle, TextField xField, TextField yField, MouseEvent event) {
        double offsetX = event.getX() - rectangle.getWidth() / 2;
        double offsetY = event.getY() - rectangle.getHeight() / 2;

        rectangle.setX(offsetX);
        rectangle.setY(offsetY);

        xField.setText(Double.toString(rectangle.getX()));
        yField.setText(Double.toString(rectangle.getY()));

        // Adding unnecessary details like updating fields on drag
        System.out.println(""Rectangle dragged. X: "" + rectangle.getX() + "", Y: "" + rectangle.getY());
    }
}
",0.5214351425942962
0_Exercise20_23.java," /**
 * *20.23 (Evaluate expression) Modify Listing 20.9 EvaluateExpression.java to add
 * operators ^ for exponent and % for modulus. For example, 3 ^ 2 is 9 and 3 % 2
 * is 1. The ^ operator has the highest precedence and the % operator has the same
 * precedence as the * and / operators. Your program should prompt the user to
 * enter an expression. Here is a sample run of the program:
 * Enter an expression: (5 * 2 ^ 3 + 2 * 3 % 2) * 4
 * (5 * 2 ^ 3 + 2 * 3 % 2) * 4 = 160
 */ /**
     * Evaluate an expression
     */ /**
     * Process one operator: Take an operator from operatorStack a
     * apply it on the operands in the operandStack
     */","package ch_20;

import java.util.Scanner;
import java.util.Stack;


public class Exercise20_23 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter an expression: "");
        String expression = input.nextLine();
        try {
            System.out.print(expression + "" = "");
            System.out.print(evaluateExpression(expression));
        } catch (Exception ex) {
            System.out.println(""Wrong expression: "" + expression);
        }
    }

    
    public static int evaluateExpression(String expression) {
        // Create operandStack to store operands
        Stack<Integer> operandStack = new Stack<>();
        // Create operatorStack to store operators
        Stack<Character> operatorStack = new Stack<>();
        // Pad following characters with space: (, ), +, -, /, *, ^ and %
        expression = insertBlanks(expression);
        // Extract operands and operators
        String[] tokens = expression.split("" "");
        // Phase 1: Scan tokens
        for (String token : tokens) {
            if (token.length() == 0) {
                continue;
            }
            if (token.charAt(0) == '^') {
                operatorStack.push(token.charAt(0));
            } else if (token.charAt(0) == '+' || token.charAt(0) == '-') {
                // Process all ^ in the top of the operator stack (has the highest precedence)
                while (!operatorStack.isEmpty() && operatorStack.peek() == '^') {
                    processAnOperator(operandStack, operatorStack);
                }

                while (!operatorStack.isEmpty() &&
                        token.charAt(0) == '*' ||
                        token.charAt(0) == '/' ||
                        token.charAt(0) == '%') {
                    processAnOperator(operandStack, operatorStack);
                }

                // Push the + or - operator into the operator stack
                operatorStack.push(token.charAt(0));
            } else if (token.charAt(0) == '*' || token.charAt(0) == '/' || token.charAt(0) == '%') {
                while (!operatorStack.isEmpty() && operatorStack.peek() == '^') {
                    processAnOperator(operandStack, operatorStack);
                }

                // Process all *, / , % in the top of the operator stack (same precedence)
                while (!operatorStack.isEmpty() &&
                        (operatorStack.peek() == '*' ||
                                operatorStack.peek() == '^' ||
                                operatorStack.peek() == '/' ||
                                operatorStack.peek() == '%')) {
                    processAnOperator(operandStack, operatorStack);
                }
                // Push the *, /, or % operator into the operator stack
                operatorStack.push(token.charAt(0));
            } else if (token.trim().charAt(0) == '(') {
                operatorStack.push('('); // Push '(' to stack
            } else if (token.trim().charAt(0) == ')') {
                // Process all the operators in the stack until seeing '(
                while (operatorStack.peek() != '(') {
                    processAnOperator(operandStack, operatorStack);
                }
                operatorStack.pop(); // Pop the '(' symbol from the stack
            } else { // An operand scanned
                // Push an operand to the stack
                operandStack.push(new Integer(token));
            }
        }

        // Phase 2: Process all the remaining operators in the stack
        while (!operatorStack.isEmpty()) {
            processAnOperator(operandStack, operatorStack);
        }
        // Return the result
        return operandStack.pop();
    }

    
    public static void processAnOperator(
            Stack<Integer> operandStack, Stack<Character> operatorStack) {
        char op = operatorStack.pop();
        int op1 = operandStack.pop();
        int op2 = operandStack.pop();
        if (op == '+')
            operandStack.push(op2 + op1);
        else if (op == '-')
            operandStack.push(op2 - op1);
        else if (op == '*')
            operandStack.push(op2 * op1);
        else if (op == '/')
            operandStack.push(op2 / op1);
        else if (op == '^')
            operandStack.push((int) Math.pow(op2, op1)); // Exponent operation
        else if (op == '%')
            operandStack.push(op2 % op1);// Modulus operation
    }

    public static String insertBlanks(String s) {
        String result = """";
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(' || s.charAt(i) == ')' ||
                    s.charAt(i) == '+' || s.charAt(i) == '-' ||
                    s.charAt(i) == '*' || s.charAt(i) == '/' ||
                    s.charAt(i) == '^' || s.charAt(i) == '%') // Check for exponent and modulus operands.
                result += "" "" + s.charAt(i) + "" "";
            else
                result += s.charAt(i);
        }
        return result;
    }
}","import java.util.Scanner;

public class EvaluateExpression {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter an expression: "");
        String expression = input.nextLine();
        input.close();
        try {
            System.out.println(expression + "" = "" + evaluateExpression(expression));
        } catch (Exception e) {
            System.out.println(""Invalid expression"");
        }
    }

    public static int evaluateExpression(String expression) throws Exception {
        expression = expression.replaceAll(""\\s"", """"); // Remove whitespace
        expression = expression.replaceAll(""\\^"", ""**""); // Replace ^ with ** for exponentiation
        int result = evaluateTerm(expression);
        while (expression.length() > 0) {
            char operator = expression.charAt(0);
            if (operator != '+' && operator != '-' && operator != '*' && operator != '/' && operator != '%') {
                throw new Exception(""Invalid operator: "" + operator);
            }
            expression = expression.substring(1);
            int term = evaluateTerm(expression);
            switch (operator) {
                case '+':
                    result += term;
                    break;
                case '-':
                    result -= term;
                    break;
                case '*':
                    result *= term;
                    break;
                case '/':
                    result /= term;
                    break;
                case '%':
                    result %= term;
                    break;
                default:
                    throw new Exception(""Invalid operator: "" + operator);
            }
        }
        return result;
    }

    public static int evaluateTerm(String expression) throws Exception {
        if (expression.charAt(0) == '(') {
            int count = 1;
            for (int i = 1; i < expression.length(); i++) {
                if (expression.charAt(i) == '(') {
                    count++;
                } else if (expression.charAt(i) == ')') {
                    count--;
                    if (count == 0) {
                        int result = evaluateExpression(expression.substring(1, i));
                        expression = expression.substring(i + 1);
                        if (expression.length() > 0 && expression.charAt(0) == '^') {
                            // Handle exponentiation
                            expression = expression.substring(1);
                            int exponent = evaluateTerm(expression);
                            result = (int) Math.pow(result, exponent);
                        }
                        return result;
                    }
                }
            }
            throw new Exception(""Unmatched parentheses"");
        } else {
            int endIndex = 1;
            while (endIndex < expression.length() && Character.isDigit(expression.charAt(endIndex))) {
                endIndex++;
            }
            int result = Integer.parseInt(expression.substring(0, endIndex));
            expression = expression.substring(endIndex);
            if (expression.length() > 0 && expression.charAt(0) == '^') {
                // Handle exponentiation
                expression = expression.substring(1);
                int exponent = evaluateTerm(expression);
                result = (int) Math.pow(result, exponent);
            }
            return result;
        }
    }
}
",1,"import java.util.Scanner;
import java.util.Stack;

public class ExpressionEvaluator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter an expression: "");
        String expression = scanner.nextLine();

        // Adding unnecessary details
        System.out.println(""Processing the expression..."");

        try {
            double result = evaluateExpression(expression);
            // Adding more unnecessary details
            System.out.println(expression + "" = "" + result);
        } catch (Exception e) {
            // Adding unnecessary exception handling
            System.out.println(""An error occurred: "" + e.getMessage());
        }
    }

    // Adding an unnecessary method comment
    /**
     * Evaluate an expression
     */
    private static double evaluateExpression(String expression) {
        Stack<Double> operandStack = new Stack<>();
        Stack<Character> operatorStack = new Stack<>();

        // Adding more unnecessary details
        System.out.println(""Evaluating expression..."");

        return 0.0; // Placeholder result, adding redundancy
    }

    // Adding an unnecessary method comment
    /**
     * Process one operator: Take an operator from operatorStack and apply it on the operands in the operandStack
     */
    private static void processOperator(Stack<Double> operandStack, Stack<Character> operatorStack) {
        // Adding unnecessary processing details
        System.out.println(""Processing operator..."");
    }
}
",0.42515127598000524
0_Exercise20_18.java," /**
 * 20.18 (Directory size) Listing 20.7, DirectorySize.java, gives a recursive method for
 * finding a directory size. Rewrite this method without using recursion. Your
 * program should use a queue to store the subdirectories under a directory. The
 * algorithm can be described as follows:
 * long getSize(File directory) {
 * long size = 0;
 * add directory to the queue;
 * while (queue is not empty) {
 * Remove an item from the queue into t;
 * if (t is a file)
 * size += t.length();
 * else
 * add all the files and subdirectories under t into the
 * queue;
 * }
 * return size;
 * }
 */","package ch_20;

import java.io.File;


public class Exercise20_18 {
    private static final String TEST_DIRECTORY = ""ch_09"";

    public static void main(String[] args) {
        String rawSize = String.valueOf(new Exercise20_18().getSize(new File(TEST_DIRECTORY)));
        StringBuilder sizeInBytes = new StringBuilder();
        for (int i = rawSize.length() - 1; i >= 0; i--) {
            sizeInBytes.append(rawSize.charAt(i));
            if (i % 3 == 0) {
                sizeInBytes.append("","");
            }
        }
        System.out.println(""Size of test directory: "" + TEST_DIRECTORY + "" is "" + sizeInBytes + "" bytes"");
    }

    private long getSize(File directory) {
        long size = 0;
        java.util.Queue<File> queue = new java.util.LinkedList<>();
        queue.offer(directory);
        while (queue.size() > 0) {
            File t = queue.remove();
            if (t.isFile()) {
                size += t.length();
            } else {
                File[] subFiles = t.listFiles();
                if (subFiles == null || subFiles.length == 0) {
                    continue;
                }

                for (File f : subFiles) {
                    queue.offer(f);
                }
            }
        }
        return size;
    }
}
","import java.io.File;
import java.util.LinkedList;
import java.util.Queue;

public class DirectorySize {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java DirectorySize directory"");
            System.exit(1);
        }

        File file = new File(args[0]);
        if (!file.isDirectory()) {
            System.out.println(file.getName() + "" is not a directory"");
            System.exit(2);
        }

        System.out.println(""The size of "" + file.getAbsolutePath() + "" is "" + getSize(file) + "" bytes."");
    }

    public static long getSize(File directory) {
        long size = 0;
        Queue<File> queue = new LinkedList<>();
        queue.offer(directory);

        while (!queue.isEmpty()) {
            File t = queue.poll();

            if (t.isFile()) {
                size += t.length();
            } else {
                File[] files = t.listFiles();
                if (files != null) {
                    for (File file : files) {
                        queue.offer(file);
                    }
                }
            }
        }

        return size;
    }
}
",1,"import java.io.File;
import java.util.LinkedList;
import java.util.Queue;

public class DirectorySizeCalculator {

    public static void main(String[] args) {
        // Getting the directory path from user input
        System.out.print(""Enter directory path: "");
        String directoryPath = System.console().readLine();

        // Calculating the directory size
        long size = getSize(new File(directoryPath));

        // Adding unnecessary details
        System.out.println(""The size of the directory is: "" + size + "" bytes."");
    }

    // Adding an unnecessary method comment
    /**
     * Calculate the size of a directory using a queue (non-recursively)
     */
    private static long getSize(File directory) {
        long size = 0;
        Queue<File> directoryQueue = new LinkedList<>();

        // Adding unnecessary details
        System.out.println(""Calculating directory size..."");

        // Add the initial directory to the queue
        directoryQueue.add(directory);

        // While the queue is not empty
        while (!directoryQueue.isEmpty()) {
            // Remove an item from the queue into t
            File currentDirectory = directoryQueue.poll();

            // If t is a file, add its size to the total size
            if (currentDirectory.isFile()) {
                size += currentDirectory.length();
            } else {
                // If t is a directory, add all the files and subdirectories under t into the queue
                File[] subFiles = currentDirectory.listFiles();
                if (subFiles != null) {
                    for (File subFile : subFiles) {
                        // Adding unnecessary details
                        System.out.println(""Adding file or subdirectory to the queue: "" + subFile.getName());
                        directoryQueue.add(subFile);
                    }
                }
            }
        }

        // Adding more unnecessary details
        System.out.println(""Directory size calculation complete."");

        return size;
    }
}
",0.5390127388535032
0_Exercise20_22.java," /**
 * 20.22 (Nonrecursive Tower of Hanoi) Implement the moveDisks method in Listing
 * 18.8 using a stack instead of using recursion.
 */","package ch_20;

import java.util.Scanner;
import java.util.Stack;


public class Exercise20_22 {

    private static final Stack<HanoiMove> STACK = new java.util.Stack<>();

    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.print(""Enter number of disks: "");
        int n = input.nextInt();
        System.out.println(""The moves are:"");
        moveDisks(n, 'A', 'B', 'C');
    }

    public static void moveDisks(int n, char fromTower,
                                 char toTower, char auxTower) {
        STACK.push(new HanoiMove(false, n, fromTower, toTower, auxTower));
        while (!STACK.isEmpty()) {
            HanoiMove hanoiMove = STACK.pop();
            n = hanoiMove.n;
            fromTower = hanoiMove.fromTower;
            toTower = hanoiMove.toTower;
            auxTower = hanoiMove.auxTower;
            if (hanoiMove.isLastInFromTower)
                System.out.println(""Move disk "" + n + "" from "" +
                        hanoiMove.fromTower + "" to "" + hanoiMove.toTower);
            else {
                if (n == 1)
                    System.out.println(""Move disk "" + n + "" from "" +
                            hanoiMove.fromTower + "" to "" + hanoiMove.toTower);
                else {
                    STACK.push(new HanoiMove(false, n - 1, auxTower, toTower, fromTower));
                    STACK.push(new HanoiMove(true, n, fromTower, toTower, auxTower));
                    STACK.push(new HanoiMove(false, n - 1, fromTower, auxTower, toTower));
                }
            }
        }
    }

    public static class HanoiMove {
        boolean isLastInFromTower = false;
        int n;
        char fromTower;
        char toTower;
        char auxTower;

        HanoiMove(boolean isLastInFromTower, int n, char fromTower, char toTower, char auxTower) {
            this.isLastInFromTower = isLastInFromTower;
            this.n = n;
            this.fromTower = fromTower;
            this.toTower = toTower;
            this.auxTower = auxTower;
        }
    }
}","import java.util.Stack;

public class TowerOfHanoi {
    public static void moveDisks(int numDisks, char fromTower, char toTower, char auxTower) {
        Stack<Integer> fromStack = new Stack<Integer>();
        Stack<Integer> toStack = new Stack<Integer>();
        Stack<Integer> auxStack = new Stack<Integer>();
        for (int i = numDisks; i > 0; i--) {
            fromStack.push(i);
        }
        int totalMoves = (int) Math.pow(2, numDisks) - 1;
        if (numDisks % 2 == 0) {
            char temp = toTower;
            toTower = auxTower;
            auxTower = temp;
        }
        for (int i = 1; i <= totalMoves; i++) {
            if (i % 3 == 1) {
                moveDisk(fromStack, toStack, fromTower, toTower);
            } else if (i % 3 == 2) {
                moveDisk(fromStack, auxStack, fromTower, auxTower);
            } else {
                moveDisk(auxStack, toStack, auxTower, toTower);
            }
        }
    }

    public static void moveDisk(Stack<Integer> fromStack, Stack<Integer> toStack, char fromTower, char toTower) {
        if (!fromStack.isEmpty() && (toStack.isEmpty() || fromStack.peek() < toStack.peek())) {
            int disk = fromStack.pop();
            toStack.push(disk);
            System.out.println(""Move disk "" + disk + "" from "" + fromTower + "" to "" + toTower);
        }
    }

    public static void main(String[] args) {
        moveDisks(3, 'A', 'C', 'B');
    }
}
",3,"import java.util.Scanner;
import java.util.Stack;

public class NonRecursiveTowerOfHanoi {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Welcome to the Tower of Hanoi Solver!"");

        // Getting the number of disks from user input
        System.out.print(""Enter the number of disks: "");
        Scanner scanner = new Scanner(System.in);
        int numberOfDisks = scanner.nextInt();

        // Solving Tower of Hanoi using a non-recursive approach
        moveDisks(numberOfDisks, 'A', 'B', 'C');

        // Adding unnecessary details
        System.out.println(""Tower of Hanoi solved successfully!"");
    }

    // Adding unnecessary method comment
    /**
     * Move disks from source pole to target pole using auxiliary pole
     *
     * @param n     number of disks
     * @param source source pole
     * @param target target pole
     * @param aux   auxiliary pole
     */
    private static void moveDisks(int n, char source, char target, char aux) {
        Stack<HanoiMove> moveStack = new Stack<>();
        moveStack.push(new HanoiMove(n, source, target, aux));

        // Adding more unnecessary details
        System.out.println(""Solving Tower of Hanoi non-recursively..."");

        while (!moveStack.isEmpty()) {
            HanoiMove move = moveStack.pop();

            if (move.n == 1) {
                // Move a single disk from source to target
                // Adding unnecessary details
                System.out.println(""Move disk from "" + move.source + "" to "" + move.target);
            } else {
                // Move n-1 disks from source to auxiliary using target as the auxiliary
                moveStack.push(new HanoiMove(move.n - 1, move.aux, move.target, move.source));

                // Move the remaining disk from source to target
                // Adding unnecessary details
                System.out.println(""Move disk from "" + move.source + "" to "" + move.target);

                // Move n-1 disks from auxiliary to target using source as the auxiliary
                moveStack.push(new HanoiMove(move.n - 1, move.source, move.target, move.aux));
            }
        }

        // Adding more unnecessary details
        System.out.println(""Tower of Hanoi solved non-recursively!"");
    }

    // Adding an unnecessary class for HanoiMove
    private static class HanoiMove {
        int n;
        char source, target, aux;

        public HanoiMove(int n, char source, char target, char aux) {
            this.n = n;
            this.source = source;
            this.target = target;
            this.aux = aux;
        }
    }
}
",0.37917775805974563
0_Exercise20_02.java," /**
 * *20.2 (Store numbers in a linked list) Write a program that lets the user enter
 * numbers from a graphical user interface and displays them in a text area, as shown in
 * Figure 20.17a. Use a linked list to store the numbers. Do not store duplicate numbers.
 * Add the buttons Sort, Shuffle, and Reverse to sort, shuffle, and reverse the list.
 */","package ch_20;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.NodeOrientation;
import javafx.geometry.Pos;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

import java.awt.event.TextListener;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;


public class Exercise20_02 extends Application {
    LinkedList<Integer> numbersList = new LinkedList<>();
    TextArea textArea;
    static double width = 400;
    static double height = 250;

    @Override
    public void start(Stage primaryStage) {
        VBox vBox = new VBox(5);

        textArea = new TextArea();
        textArea.setPrefSize(400, 200);
        textArea.setMaxWidth(400);
        textArea.setMinWidth(400);
        textArea.setPadding(new Insets(5, 5, 5, 5));

        HBox inBox = new HBox();
        Label label = new Label(""Enter a number: "");
        TextField textFieldNumberIn = new TextField();
        textFieldNumberIn.setPrefWidth(100);
        textFieldNumberIn.setMaxWidth(100);
        textFieldNumberIn.setMinWidth(100);
        textFieldNumberIn.setPadding(new Insets(5, 5, 5, 5));

        textFieldNumberIn.textProperty().addListener((observable, oldValue, newValue) -> {
            if (oldValue.contains(newValue)) {
                return;
            }
            if (numbersList.contains(Integer.valueOf(newValue))) {
                return;
            }
            if (newValue.length() > 0) {
                numbersList.add(Integer.parseInt(newValue));
                refreshUI(numbersList);
            }
        });

        inBox.getChildren().add(label);
        textFieldNumberIn.setPrefWidth(15);
        inBox.getChildren().add(textFieldNumberIn);


        vBox.getChildren().addAll(inBox, textFieldNumberIn);
        vBox.getChildren().add(textArea);
        Button sortButton = new Button(""Sort"");

        sortButton.setOnAction(event -> sortNumbers(numbersList));

        Button shuffleButton = new Button(""Shuffle"");
        shuffleButton.setOnAction(e -> shuffleNumbers(numbersList));

        Button reverseButton = new Button(""Reverse"");
        reverseButton.setOnAction(e -> reverseNumbers(numbersList));

        HBox buttonBox = new HBox();
        buttonBox.getChildren().addAll(sortButton, shuffleButton, reverseButton);
        buttonBox.setAlignment(Pos.CENTER);
        buttonBox.setSpacing(8);
        vBox.getChildren().add(buttonBox);

        Scene scene = new Scene(vBox, width, height);
        primaryStage.setScene(scene);
        primaryStage.show();

    }

    private void refreshUI(LinkedList<Integer> numbers) {
        textArea.setText(Arrays.toString(numbers.toArray()));
    }

    private void reverseNumbers(LinkedList<Integer> numbers) {
        Collections.reverse(numbers);
        textArea.setText(Arrays.toString(numbers.toArray()));
        numbersList = numbers;
    }

    private void shuffleNumbers(LinkedList<Integer> numbers) {
        Collections.shuffle(numbers);
        textArea.setText(Arrays.toString(numbers.toArray()));
        numbersList = numbers;
    }

    private void sortNumbers(LinkedList<Integer> numbers) {
        Collections.sort(numbers);
        textArea.setText(Arrays.toString(numbers.toArray()));
        numbersList = numbers;

    }
}
","import java.util.LinkedList;
import java.util.Collections;
import java.util.Set;
import java.util.HashSet;
import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class LinkedListGUI extends Application {
    private LinkedList<Integer> list = new LinkedList<>();
    private Set<Integer> set = new HashSet<>(); // used to store unique values

    @Override
    public void start(Stage primaryStage) {
        BorderPane pane = new BorderPane();
        pane.setPadding(new Insets(10));

        // Text area to display the list
        TextArea taList = new TextArea();
        taList.setEditable(false);
        taList.setWrapText(true);
        pane.setCenter(taList);

        // HBox to hold the input controls
        HBox hbInput = new HBox(10);
        hbInput.setAlignment(Pos.CENTER);
        Label lblNumber = new Label(""Number:"");
        TextField tfNumber = new TextField();
        tfNumber.setPrefColumnCount(3);
        Button btnAdd = new Button(""Add"");
        hbInput.getChildren().addAll(lblNumber, tfNumber, btnAdd);
        pane.setBottom(hbInput);

        // HBox to hold the sort, shuffle, and reverse buttons
        HBox hbButtons = new HBox(10);
        hbButtons.setAlignment(Pos.CENTER);
        Button btnSort = new Button(""Sort"");
        Button btnShuffle = new Button(""Shuffle"");
        Button btnReverse = new Button(""Reverse"");
        hbButtons.getChildren().addAll(btnSort, btnShuffle, btnReverse);
        pane.setTop(hbButtons);

        // Event handlers for the buttons
        btnAdd.setOnAction(e -> {
            String text = tfNumber.getText().trim();
            if (!text.isEmpty()) {
                try {
                    int number = Integer.parseInt(text);
                    if (set.add(number)) { // add only if not already in the list
                        list.add(number);
                        displayList(taList);
                    }
                } catch (NumberFormatException ex) {
                    // ignore non-integer input
                }
                tfNumber.clear();
            }
        });

        btnSort.setOnAction(e -> {
            Collections.sort(list);
            displayList(taList);
        });

        btnShuffle.setOnAction(e -> {
            Collections.shuffle(list);
            displayList(taList);
        });

        btnReverse.setOnAction(e -> {
            Collections.reverse(list);
            displayList(taList);
        });

        Scene scene = new Scene(pane);
        primaryStage.setScene(scene);
        primaryStage.setTitle(""Linked List GUI"");
        primaryStage.show();
    }

    // Updates the text area to display the current list
    private void displayList(TextArea taList) {
        taList.setText(list.toString());
    }

    public static void main(String[] args) {
        launch(args);
    }
}
",1,"import javafx.application.Application;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

import java.util.Collections;
import java.util.LinkedList;

public class NumberListManager extends Application {

    private LinkedList<Integer> numberList = new LinkedList<>();
    private TextArea textArea;
    private TextField inputField;

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        BorderPane root = new BorderPane();
        root.setPadding(new Insets(10));

        // Adding unnecessary details
        Label titleLabel = new Label(""Number List Manager"");
        titleLabel.setStyle(""-fx-font-size: 18; -fx-font-weight: bold;"");

        // Adding unnecessary details
        textArea = new TextArea();
        textArea.setEditable(false);
        textArea.setPrefHeight(150);

        // Adding unnecessary details
        inputField = new TextField();
        inputField.setPromptText(""Enter a number"");

        // Adding unnecessary details
        Button addButton = new Button(""Add Number"");
        addButton.setOnAction(e -> addNumber());

        // Adding unnecessary details
        Button sortButton = new Button(""Sort"");
        sortButton.setOnAction(e -> sortList());

        // Adding unnecessary details
        Button shuffleButton = new Button(""Shuffle"");
        shuffleButton.setOnAction(e -> shuffleList());

        // Adding unnecessary details
        Button reverseButton = new Button(""Reverse"");
        reverseButton.setOnAction(e -> reverseList());

        // Adding unnecessary details
        HBox buttonBox = new HBox(10);
        buttonBox.getChildren().addAll(addButton, sortButton, shuffleButton, reverseButton);

        // Adding unnecessary details
        root.setTop(titleLabel);
        root.setCenter(textArea);
        root.setBottom(inputField);
        root.setBottom(buttonBox);

        Scene scene = new Scene(root, 400, 250);

        primaryStage.setTitle(""Number List Manager"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    // Adding an unnecessary method comment
    /**
     * Add a number to the list
     */
    private void addNumber() {
        try {
            int number = Integer.parseInt(inputField.getText());
            if (!numberList.contains(number)) {
                numberList.add(number);
                updateTextArea();
                inputField.clear();
            } else {
                // Adding unnecessary details
                System.out.println(""Number already exists in the list."");
            }
        } catch (NumberFormatException e) {
            // Adding unnecessary details
            System.out.println(""Invalid input. Please enter a valid number."");
        }
    }

    // Adding an unnecessary method comment
    /**
     * Sort the list in ascending order
     */
    private void sortList() {
        Collections.sort(numberList);
        updateTextArea();
    }

    // Adding an unnecessary method comment
    /**
     * Shuffle the list
     */
    private void shuffleList() {
        Collections.shuffle(numberList);
        updateTextArea();
    }

    // Adding an unnecessary method comment
    /**
     * Reverse the order of the list
     */
    private void reverseList() {
        Collections.reverse(numberList);
        updateTextArea();
    }

    // Adding an unnecessary method comment
    /**
     * Update the text area with the current list contents
     */
    private void updateTextArea() {
        StringBuilder builder = new StringBuilder();
        for (Integer number : numberList) {
            builder.append(number).append(""\n"");
        }
        textArea.setText(builder.toString());
    }
}
",0.5232479784366577
0_Exercise20_14.java," /**
 * **20.14 (Postfix notation) Postfix notation is a way of writing expressions without
 * using parentheses. For example, the expression (1 + 2) * 3 would be
 * written as 1 2 + 3 *. A postfix expression is evaluated using a stack. Scan a
 * postfix expression from left to right. A variable or constant is pushed into the
 * stack. When an operator is encountered, apply the operator with the top two
 * operands in the stack and replace the two operands with the result.
 * <p>
 * The following diagram shows how to evaluate 1 2 + 3 *....
 * <p>
 * Write a program to evaluate postfix expressions. Pass the expression as a
 * command-line argument in one string.
 */","package ch_20;

import java.util.Stack;
import java.util.StringTokenizer;


public class Exercise20_14 {
    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println(
                    ""Usage: java Exercise20_14 expression"");
            System.exit(1);
        }
        String expression = """";
        for (int i = 0; i < args.length; i++) {
            expression += args[i] + "" "";
        }
        try {
            System.out.println(evaluateExpression(expression));
        } catch (Exception ex) {
            System.out.println(""Expression was incorrect format"");
        }
    }

    static int evaluateExpression(String expression) {
        Stack<Integer> operandStack = new Stack<>();
        StringTokenizer tokens = new StringTokenizer(expression, "" +-/*%"", true);

        while (tokens.hasMoreTokens()) {
            String token = tokens.nextToken().trim();
            if (token.length() == 0) {
                continue;
            } else if (token.charAt(0) == '+' || token.charAt(0) == '-' ||
                    token.charAt(0) == '*' || token.charAt(0) == '/') {
                processAnOperator(token.charAt(0), operandStack);
            } else {
                operandStack.push(new Integer(token));
            }
        }

        return operandStack.pop();
    }


    static void processAnOperator(char op, Stack<Integer> operandStack) {
        if (op == '+') {
            int op1 = operandStack.pop();
            int op2 = operandStack.pop();
            operandStack.push(op2 + op1);
        } else if (op == '-') {
            int op1 = operandStack.pop();
            int op2 = operandStack.pop();
            operandStack.push(op2 - op1);
        } else if ((op == '*')) {
            int op1 = operandStack.pop();
            int op2 = operandStack.pop();
            operandStack.push(op2 * op1);
        } else if (op == '/') {
            int op1 = operandStack.pop();
            int op2 = operandStack.pop();
            operandStack.push(op2 / op1);
        }
    }
}
","import java.util.Stack;

public class PostfixEvaluator {

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java PostfixEvaluator \""postfix expression\"""");
            return;
        }

        String postfixExpr = args[0];
        double result = evaluatePostfix(postfixExpr);
        System.out.println(""Result: "" + result);
    }

    public static double evaluatePostfix(String postfixExpr) {
        Stack<Double> stack = new Stack<>();

        String[] tokens = postfixExpr.split(""\\s+"");

        for (String token : tokens) {
            if (isOperator(token)) {
                double operand2 = stack.pop();
                double operand1 = stack.pop();
                double result = applyOperator(token, operand1, operand2);
                stack.push(result);
            } else {
                double operand = Double.parseDouble(token);
                stack.push(operand);
            }
        }

        return stack.pop();
    }

    public static boolean isOperator(String token) {
        return token.equals(""+"") || token.equals(""-"") || token.equals(""*"") || token.equals(""/"");
    }

    public static double applyOperator(String operator, double operand1, double operand2) {
        if (operator.equals(""+"")) {
            return operand1 + operand2;
        } else if (operator.equals(""-"")) {
            return operand1 - operand2;
        } else if (operator.equals(""*"")) {
            return operand1 * operand2;
        } else {
            return operand1 / operand2;
        }
    }

}
",1,"import java.util.Stack;

public class PostfixEvaluator {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Welcome to the Postfix Expression Evaluator!"");

        // Checking if an expression is provided as a command-line argument
        if (args.length == 0) {
            // Adding unnecessary details
            System.out.println(""Please provide a postfix expression as a command-line argument."");
            return;
        }

        // Retrieving the postfix expression from the command-line argument
        String postfixExpression = args[0];

        // Evaluating the postfix expression
        double result = evaluatePostfix(postfixExpression);

        // Adding unnecessary details
        System.out.println(""Result of the postfix expression: "" + result);
    }

    // Adding unnecessary method comment
    /**
     * Evaluate a postfix expression
     *
     * @param expression the postfix expression
     * @return the result of the evaluation
     */
    private static double evaluatePostfix(String expression) {
        Stack<Double> operandStack = new Stack<>();

        // Adding unnecessary details
        System.out.println(""Evaluating postfix expression..."");

        // Splitting the expression into tokens
        String[] tokens = expression.split(""\\s+"");

        for (String token : tokens) {
            if (isOperand(token)) {
                // If the token is an operand, push it onto the stack
                operandStack.push(Double.parseDouble(token));
            } else if (isOperator(token)) {
                // If the token is an operator, apply it with the top two operands in the stack
                double operand2 = operandStack.pop();
                double operand1 = operandStack.pop();
                double result = performOperation(operand1, operand2, token);
                operandStack.push(result);
            } else {
                // Adding unnecessary details
                System.out.println(""Invalid token: "" + token);
            }
        }

        // The final result should be at the top of the stack
        return operandStack.pop();
    }

    // Adding unnecessary method comment
    /**
     * Check if a token is an operand
     *
     * @param token the token to check
     * @return true if the token is an operand, false otherwise
     */
    private static boolean isOperand(String token) {
        try {
            Double.parseDouble(token);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    // Adding unnecessary method comment
    /**
     * Check if a token is an operator
     *
     * @param token the token to check
     * @return true if the token is an operator, false otherwise
     */
    private static boolean isOperator(String token) {
        return token.matches(""[+\\-*/]"");
    }

    // Adding unnecessary method comment
    /**
     * Perform an operation with two operands and an operator
     *
     * @param operand1 the first operand
     * @param operand2 the second operand
     * @param operator the operator
     * @return the result of the operation
     */
    private static double performOperation(double operand1, double operand2, String operator) {
        switch (operator) {
            case ""+"":
                return operand1 + operand2;
            case ""-"":
                return operand1 - operand2;
            case ""*"":
                return operand1 * operand2;
            case ""/"":
                if (operand2 != 0) {
                    return operand1 / operand2;
                } else {
                    // Adding unnecessary details
                    System.out.println(""Division by zero is not allowed."");
                    return 0;
                }
            default:
                // Adding unnecessary details
                System.out.println(""Unsupported operator: "" + operator);
                return 0;
        }
    }
}
",0.47394429469901167
0_Exercise20_09.java," /**
 * **20.9 (Remove the largest ball first) Modify Listing 20.6, MultipleBallApp.java to
 * assign a random radius between 2 and 20 when a ball is created.
 * When the - button is clicked, one of largest balls is removed.
 */","package ch_20;


import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.beans.property.DoubleProperty;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollBar;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;
import javafx.util.Duration;

import java.util.ArrayList;
import java.util.Collections;



public class Exercise20_09 extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {

        MultiBallPane mbPane = new MultiBallPane();

        Button addButton = new Button(""+"");
        Button subtractButton = new Button(""-"");

        HBox hBox = new HBox(10);
        hBox.getChildren().addAll(addButton, subtractButton);
        hBox.setAlignment(Pos.CENTER);

        addButton.setOnAction(ev1 -> {
            mbPane.addOne();
        });
        subtractButton.setOnAction(ev2 -> {
            mbPane.removeOne();
        });

        // Pause and resume animation
        mbPane.setOnMousePressed(e -> mbPane.pause());
        mbPane.setOnMouseReleased(e -> mbPane.play());
        // Use a scroll bar to control animation speed
        ScrollBar sbSpeed = new ScrollBar();
        sbSpeed.setMax(20);
        sbSpeed.setValue(10);
        mbPane.rateProperty().bind(sbSpeed.valueProperty());

        BorderPane pane = new BorderPane();
        pane.setCenter(mbPane);
        pane.setTop(sbSpeed);
        pane.setBottom(hBox);
        // Create a scene and place the pane in the stage
        Scene scene = new Scene(pane, 450, 350);
        primaryStage.setResizable(false);
        primaryStage.setTitle(""The Bouncing Ballz""); // Set the stage title
        primaryStage.setScene(scene); // Place the scene in the stage
        primaryStage.show(); // Display the stage

    }

}

class MultiBallPane extends Pane {
    private Timeline animation;
    ArrayList<Double> radii = new ArrayList<>();

    MultiBallPane() {
        animation = new Timeline(new KeyFrame(Duration.millis(50), event -> moveBall()));
        animation.setCycleCount(Timeline.INDEFINITE);
        animation.play();
    }

    public void addOne() {
        Color color = new Color(Math.random(), Math.random(), Math.random(), 0.5);
        /* Random radius between 2 and 20 */
        double randomRadius = 2 + Math.random() * 19;
        radii.add(randomRadius);
        Collections.sort(radii);
        getChildren().add(new Ball(30, 30, randomRadius, color));
    }

    public void removeOne() {
        if (getChildren().size() > 0) {
            double maxRadius = radii.get(radii.size() - 1);
            getChildren().removeIf(n -> ((Ball) n).getRadius() == maxRadius);
            radii.remove(maxRadius);
        }
    }

    public void play() {
        animation.play();
    }

    public void pause() {
        animation.pause();
    }

    public void increaseSpeed() {
        animation.setRate(animation.getRate() + 0.1);
    }

    public void decreaseSpeed() {
        animation.setRate(animation.getRate() > 0 ? animation.getRate() - 0.1 : 0);
    }

    public DoubleProperty rateProperty() {
        return animation.rateProperty();
    }

    protected void moveBall() {
        for (Node node : this.getChildren()) {
            Ball ball = (Ball) node;
            // Calculate boundaries
            if (ball.getCenterX() < ball.getRadius() || ball.getCenterX() > getWidth() - ball.getRadius()) {
                ball.dx *= -1; // Change ball move direction
            }
            if (ball.getCenterY() < ball.getRadius() || ball.getCenterY() > getHeight() - ball.getRadius()) {
                ball.dy *= -1; // Change ball move direction
            }
            //Move ball forward
            ball.setCenterX(ball.dx + ball.getCenterX());
            ball.setCenterY(ball.dy + ball.getCenterY());
        }
    }


    class Ball extends Circle {
        private double dx = 1, dy = 1;

        Ball(double x, double y, double radius, Color color) {
            super(x, y, radius);
            setFill(color);
        }

    }

}","import java.util.ArrayList;
import javafx.application.Application;
import javafx.geometry.Bounds;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;

public class MultipleBallApp extends Application {
    
    private ArrayList<Circle> balls = new ArrayList<>();
    private Group root = new Group();
    
    @Override
    public void start(Stage primaryStage) {
        
        Button removeButton = new Button(""-"");
        removeButton.setOnAction(e -> removeLargestBall());
        
        StackPane pane = new StackPane();
        pane.getChildren().addAll(root, removeButton);
        primaryStage.setScene(new Scene(pane, 400, 400));
        primaryStage.show();
        
        for (int i = 0; i < 10; i++) {
            Circle ball = createRandomBall();
            balls.add(ball);
            root.getChildren().add(ball);
        }
    }
    
    private Circle createRandomBall() {
        double radius = Math.random() * 18 + 2;
        Circle ball = new Circle(radius, Color.BLUE);
        ball.relocate(Math.random() * 360, Math.random() * 360);
        return ball;
    }
    
    private void removeLargestBall() {
        if (balls.size() > 0) {
            Circle largestBall = balls.get(0);
            for (Circle ball : balls) {
                if (ball.getRadius() > largestBall.getRadius()) {
                    largestBall = ball;
                }
            }
            root.getChildren().remove(largestBall);
            balls.remove(largestBall);
        }
    }
    
    public static void main(String[] args) {
        launch(args);
    }
    
}
",4,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.Pane;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import javafx.scene.shape.Circle;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class RemoveLargestBallApp extends Application {

    private List<Circle> balls = new ArrayList<>();

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        Pane pane = new Pane();

        // Adding unnecessary details
        System.out.println(""Welcome to the Ball Remover App!"");

        Button removeButton = new Button(""-"");
        removeButton.setLayoutX(10);
        removeButton.setLayoutY(10);
        removeButton.setOnAction(e -> removeLargestBall());

        // Adding unnecessary details
        System.out.println(""Click the - button to remove a ball."");

        pane.getChildren().add(removeButton);

        Scene scene = new Scene(pane, 400, 400);
        primaryStage.setTitle(""Remove Largest Ball App"");
        primaryStage.setScene(scene);
        primaryStage.show();

        // Adding unnecessary details
        System.out.println(""Creating random balls..."");

        createRandomBalls(10);

        // Adding unnecessary details
        System.out.println(""Balls created successfully!"");
    }

    // Adding unnecessary method comment
    /**
     * Remove the largest ball
     */
    private void removeLargestBall() {
        if (!balls.isEmpty()) {
            Circle largestBall = findLargestBall();
            balls.remove(largestBall);
            // Adding unnecessary details
            System.out.println(""Largest ball removed!"");
            updatePane();
        } else {
            // Adding unnecessary details
            System.out.println(""No balls to remove."");
        }
    }

    // Adding unnecessary method comment
    /**
     * Find the largest ball in the list
     *
     * @return the largest ball
     */
    private Circle findLargestBall() {
        Circle largestBall = balls.get(0);
        for (Circle ball : balls) {
            if (ball.getRadius() > largestBall.getRadius()) {
                largestBall = ball;
            }
        }
        return largestBall;
    }

    // Adding unnecessary method comment
    /**
     * Create random balls with random radius between 2 and 20
     *
     * @param numBalls the number of balls to create
     */
    private void createRandomBalls(int numBalls) {
        Random random = new Random();
        for (int i = 0; i < numBalls; i++) {
            double radius = random.nextDouble() * 18 + 2; // Random radius between 2 and 20
            Circle ball = new Circle(random.nextDouble() * 380 + 10, random.nextDouble() * 380 + 10, radius);
            ball.setFill(Color.color(random.nextDouble(), random.nextDouble(), random.nextDouble()));
            balls.add(ball);
        }
        updatePane();
    }

    // Adding unnecessary method comment
    /**
     * Update the pane with the current list of balls
     */
    private void updatePane() {
        Pane pane = (Pane) balls.get(0).getParent();
        pane.getChildren().clear();
        pane.getChildren().addAll(balls);
        Button removeButton = new Button(""-"");
        removeButton.setLayoutX(10);
        removeButton.setLayoutY(10);
        removeButton.setOnAction(e -> removeLargestBall());
        pane.getChildren().add(removeButton);
    }
}
",0.4794952681388013
0_Exercise20_10.java," /**
 * 20.10 (Perform set operations on priority queues) Create two priority queues,
 * {""George"", ""Jim"", ""John"", ""Blake"", ""Kevin"", ""Michael""} and
 * {""George"", ""Katie"", ""Kevin"", ""Michelle"", ""Ryan""}, and find their
 * union, difference, and intersection.
 */","package ch_20;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.PriorityQueue;


public class Exercise20_10 {
    private static String[] l1 = new String[]{""George"", ""Jim"", ""John"", ""Blake"", ""Kevin"", ""Michael""};
    private static String[] l2 = new String[]{""George"", ""Katie"", ""Kevin"", ""Michelle"", ""Ryan""};


    public static void main(String[] args) {
        PriorityQueue<String> priorityQueue1 = new PriorityQueue<>(Arrays.asList(l1));
        PriorityQueue<String> priorityQueue2 = new PriorityQueue<>(Arrays.asList(l2));

        HashSet<String> union = new HashSet<>(priorityQueue1);
        union.addAll(priorityQueue2);
        System.out.println(""Union: "" + union);

        PriorityQueue<String> difference = new PriorityQueue<>(priorityQueue1);
        difference.removeAll(priorityQueue2);
        System.out.println(""Difference: "" + difference);

        PriorityQueue<String> intersection = new PriorityQueue<>(priorityQueue1);
        intersection.retainAll(priorityQueue2);
        System.out.println(""Intersection: "" + intersection);
    }
}
","import java.util.PriorityQueue;

public class SetOperationsOnPriorityQueues {
    public static void main(String[] args) {
        // Create two priority queues
        PriorityQueue<String> pq1 = new PriorityQueue<>();
        pq1.add(""George"");
        pq1.add(""Jim"");
        pq1.add(""John"");
        pq1.add(""Blake"");
        pq1.add(""Kevin"");
        pq1.add(""Michael"");

        PriorityQueue<String> pq2 = new PriorityQueue<>();
        pq2.add(""George"");
        pq2.add(""Katie"");
        pq2.add(""Kevin"");
        pq2.add(""Michelle"");
        pq2.add(""Ryan"");

        // Union of pq1 and pq2
        PriorityQueue<String> union = new PriorityQueue<>(pq1);
        union.addAll(pq2);
        System.out.println(""Union: "" + union);

        // Difference of pq1 and pq2
        PriorityQueue<String> difference = new PriorityQueue<>(pq1);
        difference.removeAll(pq2);
        System.out.println(""Difference: "" + difference);

        // Intersection of pq1 and pq2
        PriorityQueue<String> intersection = new PriorityQueue<>(pq1);
        intersection.retainAll(pq2);
        System.out.println(""Intersection: "" + intersection);
    }
}
",1,"import java.util.PriorityQueue;

public class SetOperationsOnPriorityQueues {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Performing set operations on priority queues!"");

        // Creating two priority queues
        PriorityQueue<String> queue1 = new PriorityQueue<>();
        PriorityQueue<String> queue2 = new PriorityQueue<>();

        // Adding unnecessary details
        System.out.println(""Creating priority queues..."");

        // Adding elements to the first priority queue
        queue1.add(""George"");
        queue1.add(""Jim"");
        queue1.add(""John"");
        queue1.add(""Blake"");
        queue1.add(""Kevin"");
        queue1.add(""Michael"");

        // Adding unnecessary details
        System.out.println(""First priority queue created successfully!"");

        // Adding unnecessary details
        System.out.println(""Adding elements to the second priority queue..."");

        // Adding elements to the second priority queue
        queue2.add(""George"");
        queue2.add(""Katie"");
        queue2.add(""Kevin"");
        queue2.add(""Michelle"");
        queue2.add(""Ryan"");

        // Adding unnecessary details
        System.out.println(""Second priority queue created successfully!"");

        // Performing set operations
        // Adding unnecessary details
        System.out.println(""Performing set operations..."");

        PriorityQueue<String> unionQueue = new PriorityQueue<>(queue1);
        unionQueue.addAll(queue2);

        PriorityQueue<String> differenceQueue = new PriorityQueue<>(queue1);
        differenceQueue.removeAll(queue2);

        PriorityQueue<String> intersectionQueue = new PriorityQueue<>(queue1);
        intersectionQueue.retainAll(queue2);

        // Adding unnecessary details
        System.out.println(""Set operations performed successfully!"");

        // Displaying results
        // Adding unnecessary details
        System.out.println(""Displaying results..."");

        System.out.println(""Union: "" + unionQueue);
        System.out.println(""Difference: "" + differenceQueue);
        System.out.println(""Intersection: "" + intersectionQueue);

        // Adding unnecessary details
        System.out.println(""Results displayed successfully!"");
    }
}
",0.5419925195511731
0_Exercise20_06.java," /**
 * 20.6 (Use iterators on linked lists) Write a test program that stores 5 million integers
 * in a linked list and test the time to traverse the list using an iterator vs. using
 * the get(index) method.
 */","package ch_20;

import java.util.Iterator;
import java.util.LinkedList;


public class Exercise20_06 {
    static Integer size = 5_000_000;
    private static final boolean PRINT_TEST = false;

    public static void main(String[] args) {
        LinkedList<Integer> testList = new LinkedList<>();

        for (int i = 0; i < size; i++) {
            testList.add(i);
        }
        System.out.println(""Start Iterator test..."");
        double time1 = testIterator(testList);
        System.out.println(""\nIterator completed in "" + time1 + "" seconds."");

        System.out.println(""Start get method iteration test..."");
        double time2 = testGetMethod(testList);
        System.out.println(""\nGet method iteration completed in "" + time2 + "" seconds."");

    }

    static double testIterator(LinkedList<Integer> list) {
        Iterator<Integer> listIterator = list.iterator();
        long startTime = System.currentTimeMillis();
        while (listIterator.hasNext()) {
            Integer i = listIterator.next();
            if (PRINT_TEST) {
                System.out.println(i + "" "");
            }
        }

        long endTime = System.currentTimeMillis();
        long time = endTime - startTime;

        return time / 1000.00;
    }

    static double testGetMethod(LinkedList<Integer> list) {
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < list.size(); i++) {
            Integer j = list.get(i);
            if (PRINT_TEST) {
                System.out.println(j + "" "");
            }
        }

        long endTime = System.currentTimeMillis();
        long time = endTime - startTime;

        return time / 1000.00;
    }
}
","import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Random;

public class LinkedListIteratorVsGetTest {
    public static void main(String[] args) {
        // Create a linked list and add 5 million random integers to it
        List<Integer> list = new LinkedList<>();
        Random random = new Random();
        for (int i = 0; i < 5000000; i++) {
            list.add(random.nextInt());
        }

        // Traverse the list using an iterator and measure the time it takes
        long start = System.currentTimeMillis();
        ListIterator<Integer> iterator = list.listIterator();
        while (iterator.hasNext()) {
            int value = iterator.next();
        }
        long end = System.currentTimeMillis();
        long iteratorTime = end - start;

        // Traverse the list using get(index) and measure the time it takes
        start = System.currentTimeMillis();
        for (int i = 0; i < list.size(); i++) {
            int value = list.get(i);
        }
        end = System.currentTimeMillis();
        long getTime = end - start;

        // Print the results
        System.out.println(""Iterator time: "" + iteratorTime + "" ms"");
        System.out.println(""Get time: "" + getTime + "" ms"");
    }
}
",1,"import java.util.LinkedList;
import java.util.Iterator;

public class LinkedListTraversalTest {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Testing time to traverse a linked list!"");

        // Creating a linked list
        LinkedList<Integer> linkedList = new LinkedList<>();

        // Adding unnecessary details
        System.out.println(""Creating a linked list..."");

        // Storing 5 million integers in the linked list
        // Adding unnecessary details
        System.out.println(""Storing 5 million integers in the linked list..."");

        for (int i = 0; i < 5000000; i++) {
            linkedList.add(i);
        }

        // Adding unnecessary details
        System.out.println(""Linked list created successfully!"");

        // Testing time to traverse the linked list using an iterator
        // Adding unnecessary details
        System.out.println(""Testing time to traverse the linked list using an iterator..."");

        long startTimeIterator = System.currentTimeMillis();
        Iterator<Integer> iterator = linkedList.iterator();
        while (iterator.hasNext()) {
            Integer value = iterator.next();
            // Adding unnecessary details
            System.out.print(value + "" "");
        }
        long endTimeIterator = System.currentTimeMillis();

        // Adding unnecessary details
        System.out.println(""\nTime taken using iterator: "" + (endTimeIterator - startTimeIterator) + "" milliseconds"");

        // Testing time to traverse the linked list using the get(index) method
        // Adding unnecessary details
        System.out.println(""Testing time to traverse the linked list using the get(index) method..."");

        long startTimeGet = System.currentTimeMillis();
        for (int i = 0; i < linkedList.size(); i++) {
            Integer value = linkedList.get(i);
            // Adding unnecessary details
            System.out.print(value + "" "");
        }
        long endTimeGet = System.currentTimeMillis();

        // Adding unnecessary details
        System.out.println(""\nTime taken using get(index): "" + (endTimeGet - startTimeGet) + "" milliseconds"");

        // Adding unnecessary details
        System.out.println(""Traversal tests completed successfully!"");
    }
}
",0.5746606334841629
0_Exercise20_01.java," /**
 * *20.1 (Display words in ascending alphabetical order) Write a program that
 * reads words from a text file and displays all the words (duplicates allowed)
 * in ascending alphabetical order. The words must start with a letter. The text
 * file is passed as a command-line argument
 */","package ch_20;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;


public class Exercise20_01 {

    public static void main(String... args) {
        String fileName = ""resources/W.txt"";
        Exercise20_01 exercise2001 = new Exercise20_01();
        File file = new File(""."");
        try {
            file = exercise2001.getFileFromResources(fileName);
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("":("" + "" "" + e.getLocalizedMessage());
        }

        List<String> words = new ArrayList<>();

        try (Scanner fileInput = new Scanner(file)) {
            while (fileInput.hasNext()) {
                words.add(fileInput.next());

            }

        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(words);

    }

    private File getFileFromResources(String fileName) throws URISyntaxException, FileNotFoundException {
        ClassLoader classLoader = getClass().getClassLoader();
        URL resourceFile = classLoader.getResource(fileName);
        if (resourceFile == null) {
            System.out.println(""File Not Found"");
            throw new FileNotFoundException(""File not found"");
        }
        return new File(resourceFile.toURI());
    }
}
","import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeSet;

public class AlphabeticalOrder {
    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println(""Usage: java AlphabeticalOrder <filename>"");
            return;
        }

        String filename = args[0];
        File file = new File(filename);
        Set<String> words = new TreeSet<>();

        try (Scanner scanner = new Scanner(file)) {
            while (scanner.hasNext()) {
                String word = scanner.next().toLowerCase().replaceAll(""[^a-z]"", """");
                if (word.length() > 0) {
                    words.add(word);
                }
            }
        } catch (FileNotFoundException e) {
            System.out.println(""File not found: "" + filename);
            return;
        }

        for (String word : words) {
            System.out.println(word);
        }
    }
}
",1,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;

public class DisplayWordsInOrder {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Displaying words in ascending alphabetical order!"");

        if (args.length == 0) {
            // Adding unnecessary details
            System.out.println(""Usage: java DisplayWordsInOrder <filename>"");

            // Adding unnecessary details
            System.out.println(""Program terminated."");
            return;
        }

        String filename = args[0];
        ArrayList<String> wordsList = new ArrayList<>();

        // Adding unnecessary details
        System.out.println(""Reading words from the text file..."");

        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Adding unnecessary details
                System.out.println(""Reading line: "" + line);

                String[] words = line.split(""\\s+"");

                for (String word : words) {
                    // Adding unnecessary details
                    System.out.println(""Adding word: "" + word);

                    if (Character.isLetter(word.charAt(0))) {
                        wordsList.add(word);
                    } else {
                        // Adding unnecessary details
                        System.out.println(""Ignoring word: "" + word);
                    }
                }
            }
        } catch (IOException e) {
            // Adding unnecessary details
            System.out.println(""Error reading the file: "" + e.getMessage());

            // Adding unnecessary details
            System.out.println(""Program terminated."");
            return;
        }

        // Adding unnecessary details
        System.out.println(""Sorting words in alphabetical order..."");

        Collections.sort(wordsList);

        // Adding unnecessary details
        System.out.println(""Displaying words in alphabetical order..."");

        for (String word : wordsList) {
            // Adding unnecessary details
            System.out.print(word + "" "");
        }

        // Adding unnecessary details
        System.out.println(""\nProgram completed successfully!"");
    }
}
",0.4575113808801214
0_Exercise20_17.java," /**
 * **20.17 (Game: the 24-point card game) This exercise is a variation of the 24-point
 * card game described in Programming Exercise 20.13. Write a program to
 * check whether there is a 24-point solution for the four specified numbers. The
 * program lets the user enter four values, each between 1 and 13, as shown in
 * Figure 20.21. The user can then click the Solve button to display the solution or
 * display “No solution” if none exist.
 */","package ch_20;

import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.stage.Stage;


public class Exercise20_17 extends Application {

    static int[] numbers = new int[4];

    @Override
    public void start(Stage primaryStage) throws Exception {
        VBox vbox = new VBox();
        HBox numberBox = new HBox();
        HBox topBox = new HBox(10);
        vbox.setFillWidth(true);
        VBox.setMargin(numberBox, new Insets(5, 5, 5, 5));


        TextField num1TextField = new TextField();
        num1TextField.setPrefWidth(60);
        num1TextField.setPrefHeight(50);
        num1TextField.setFont(new Font(25));
        num1TextField.setAlignment(Pos.CENTER);
        HBox.setMargin(num1TextField, new Insets(0, 5, 0, 0));

        num1TextField.textProperty().addListener((observable, oldValue, newValue) -> {
            if (!newValue.isEmpty()) {
                try {
                    int val = Integer.parseInt(newValue);
                    if (val <= 13 && val >= 1) {
                        numbers[0] = Integer.parseInt(newValue);
                    } else {
                        num1TextField.setText(oldValue);
                        numbers[0] = 0;
                    }
                } catch (NumberFormatException numberFormatException) {
                    num1TextField.setText(oldValue);
                }

            }
        });

        TextField num2TextField = new TextField();
        num2TextField.setPrefWidth(60);
        num2TextField.setPrefHeight(50);
        num2TextField.setFont(new Font(25));
        num2TextField.setAlignment(Pos.CENTER);
        HBox.setMargin(num2TextField, new Insets(0, 5, 0, 0));

        num2TextField.textProperty().addListener((observable, oldValue, newValue) -> {
            if (!newValue.isEmpty()) {
                try {
                    int val = Integer.parseInt(newValue);
                    if (val <= 13 && val >= 1) {
                        numbers[1] = Integer.parseInt(newValue);
                    } else {
                        num2TextField.setText(oldValue);
                        numbers[1] = 0;
                    }
                } catch (NumberFormatException numberFormatException) {
                    num2TextField.setText(oldValue);
                }

            }
        });


        TextField num3TextField = new TextField();
        num3TextField.setPrefWidth(60);
        num3TextField.setPrefHeight(50);
        num3TextField.setFont(new Font(25));
        num3TextField.setAlignment(Pos.CENTER);
        HBox.setMargin(num3TextField, new Insets(0, 5, 0, 0));
        num3TextField.textProperty().addListener((observable, oldValue, newValue) -> {
            if (!newValue.isEmpty()) {
                try {
                    int val = Integer.parseInt(newValue);
                    if (val <= 13 && val >= 1) {
                        numbers[2] = Integer.parseInt(newValue);
                    } else {
                        num3TextField.setText(oldValue);
                        numbers[2] = 0;
                    }
                } catch (NumberFormatException numberFormatException) {
                    num3TextField.setText(oldValue);
                }

            }
        });

        TextField num4TextField = new TextField();
        num4TextField.setPrefWidth(60);
        num4TextField.setPrefHeight(50);
        num4TextField.setFont(new Font(25));
        num4TextField.setAlignment(Pos.CENTER);
        HBox.setMargin(num4TextField, new Insets(0, 5, 0, 0));
        num4TextField.textProperty().addListener((observable, oldValue, newValue) -> {
            if (!newValue.isEmpty()) {
                try {
                    int val = Integer.parseInt(newValue);
                    if (val <= 13 && val >= 1) {
                        numbers[3] = Integer.parseInt(newValue);
                    } else {
                        num4TextField.setText(oldValue);
                        numbers[3] = 0;
                    }
                } catch (NumberFormatException numberFormatException) {
                    num4TextField.setText(oldValue);
                }

            }
        });

        TextField findSolutionTxtFld = new TextField();
        findSolutionTxtFld.setPrefWidth(180);
        numberBox.getChildren().addAll(num1TextField, num2TextField, num3TextField, num4TextField);
        numberBox.setAlignment(Pos.CENTER);

        Button findSolutionBtn = new Button(""Solve"");
        findSolutionBtn.setOnAction(event -> {
            if (numbers[0] != 0 && numbers[1] != 0 && numbers[2] != 0 && numbers[3] != 0) {
                String solution = findSolution(numbers);
                findSolutionTxtFld.setText(solution);
            } else {
                findSolutionTxtFld.setText(""Invalid number values.."");
            }

        });

        HBox.setMargin(findSolutionBtn, new Insets(5, 10, 5, 5));
        HBox.setMargin(findSolutionTxtFld, new Insets(5, 5, 5, 5));

        topBox.getChildren().add(findSolutionTxtFld);
        topBox.getChildren().add(findSolutionBtn);
        topBox.setAlignment(Pos.CENTER);
        vbox.getChildren().add(topBox);
        vbox.getChildren().add(numberBox);

        Scene scene = new Scene(vbox, 300, 120);
        primaryStage.setScene(scene);
        primaryStage.setTitle(getClass().getName());
        primaryStage.show();

    }

    static boolean equals24(double i) {
        return i >= 23.999 && i <= 24.001;
    }

    double operate(double a, double b, int op) {
        if (op == 0) return a + b;
        if (op == 1) return a - b;
        if (op == 2) return a * b;
        if (op == 3) {
            return a / b;
        }
        throw new IllegalArgumentException(""operate( "" + a + "", "" + b + "", "" + op + "" )"");

    }

    String findSolution(int[] numbers) {
        for (int a = 0; a < 4; a++) {
            for (int b = 0; b < 4; b++) {
                if (a != b) {
                    for (int c = 0; c < 4; c++) {
                        if (a != c && b != c) {
                            for (int d = 0; d < 4; d++) {
                                // permutation of 4 numbers, index is a,b,c,d
                                if (a != d && b != d && c != d) {
                                    for (int x = 0; x < 4; x++) {
                                        for (int y = 0; y < 4; y++) {
                                            // 3 ops '+-*/', in x,y,z
                                            for (int z = 0; z < 4; z++) {
                                                // Exp 1
                                                if (equals24(operate(numbers[a], operate(numbers[b], operate(numbers[c], numbers[d],
                                                        x), y), z))) {
                                                    return getExpressionString(1, numbers[a], numbers[b], numbers[c], numbers[d]
                                                            , x, y, z);
                                                }
                                                // Exp 2
                                                if (equals24(operate(numbers[a], operate(operate(numbers[b], numbers[c], x),
                                                        numbers[d], y), z))) {
                                                    return getExpressionString(2, numbers[a], numbers[b], numbers[c], numbers[d]
                                                            , x, y, z);
                                                }
                                                // Exp 3
                                                if (equals24(operate(operate(numbers[a], operate(numbers[b], numbers[c], x), y),
                                                        numbers[d], z))) {
                                                    return getExpressionString(3, numbers[a], numbers[b], numbers[c], numbers[d]
                                                            , x, y, z);
                                                }
                                                // Exp 4
                                                if (equals24(operate(operate(numbers[a], numbers[b], x), operate(numbers[c],
                                                        numbers[d], y), z))) {
                                                    return getExpressionString(4, numbers[a], numbers[b], numbers[c], numbers[d]
                                                            , x, y, z);
                                                }
                                                // Exp 5
                                                if (equals24(operate(operate(operate(numbers[a], numbers[b], x), numbers[c], y),
                                                        numbers[d], z))) {
                                                    return getExpressionString(5, numbers[a], numbers[b], numbers[c], numbers[d]
                                                            , x, y, z);
                                                }
                                            }
                                        }

                                    }

                                }

                            }

                        }

                    }


                }

            }
        }

        return ""No Solution"";
    }

    String getOp(int op) {
        switch (op) {
            case 0:
                return ""+"";
            case 1:
                return ""-"";
            case 2:
                return ""*"";
            case 3:
                return ""/"";
        }
        return """";
    }

    String getExpressionString(int exp,
                               int a,
                               int b,
                               int c,
                               int d,
                               int x,
                               int y,
                               int z) {
        switch (exp) {
            case 1:
                return """" + a + getOp(z) + ""("" + b + getOp(y) + ""("" + c + getOp(x) + d + "")"" + "")"";
            case 2:
                return """" + a + getOp(z) + ""("" + y + getOp(y) + ""("" + b + getOp(x) + c + "")"" + "")"";
            case 3:
                return """" + d + getOp(z) + ""("" + a + getOp(y) + ""("" + b + getOp(x) + c + "")"" + "")"";
            case 4:
                return ""("" + a + getOp(x) + b + "")"" + getOp(z) + ""("" + c + getOp(y) + d + "")"";
            case 5:
                return """" + d + getOp(z) + ""("" + c + getOp(y) + ""("" + a + getOp(x) + b + "")"" + "")"";
        }
        return """";
    }

}
","import java.util.*;

public class CardGame {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[] numbers = new int[4];
        
        // Prompt the user to enter four numbers between 1 and 13
        System.out.print(""Enter four numbers between 1 and 13: "");
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = input.nextInt();
        }
        
        // Find a 24-point solution
        String solution = findSolution(numbers);
        
        // Display the solution or ""No solution"" if none exists
        System.out.println(solution);
    }
    
    public static String findSolution(int[] numbers) {
        List<String> operators = Arrays.asList(""+"", ""-"", ""*"", ""/"");
        List<List<String>> permutations = generatePermutations(operators, 3);
        
        // Try all possible combinations of the four numbers and the operators
        for (int a : numbers) {
            for (int b : numbers) {
                if (b == a) continue;
                for (int c : numbers) {
                    if (c == a || c == b) continue;
                    for (int d : numbers) {
                        if (d == a || d == b || d == c) continue;
                        for (List<String> ops : permutations) {
                            double result = evaluateExpression(a, b, c, d, ops);
                            if (result == 24) {
                                return formatSolution(a, b, c, d, ops);
                            }
                        }
                    }
                }
            }
        }
        
        // No solution found
        return ""No solution"";
    }
    
    public static List<List<String>> generatePermutations(List<String> items, int length) {
        List<List<String>> result = new ArrayList<>();
        if (length == 1) {
            for (String item : items) {
                result.add(Arrays.asList(item));
            }
        } else {
            for (String item : items) {
                List<String> rest = new ArrayList<>(items);
                rest.remove(item);
                for (List<String> permutation : generatePermutations(rest, length - 1)) {
                    List<String> newPermutation = new ArrayList<>();
                    newPermutation.add(item);
                    newPermutation.addAll(permutation);
                    result.add(newPermutation);
                }
            }
        }
        return result;
    }
    
    public static double evaluateExpression(int a, int b, int c, int d, List<String> ops) {
        String expression = String.format(""%d %s %d %s %d %s %d"", a, ops.get(0), b, ops.get(1), c, ops.get(2), d);
        return evaluateExpression(expression);
    }",5,"import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class TwentyFourPointCardGame extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        // Adding unnecessary details
        System.out.println(""Welcome to the 24-point card game!"");

        Label titleLabel = new Label(""24-Point Card Game"");
        titleLabel.setStyle(""-fx-font-size: 24px; -fx-font-weight: bold;"");

        // Adding unnecessary details
        System.out.println(""Creating input fields..."");

        TextField[] numberFields = new TextField[4];
        for (int i = 0; i < 4; i++) {
            numberFields[i] = new TextField();
            numberFields[i].setPromptText(""Enter a number (1-13)"");
        }

        Button solveButton = new Button(""Solve"");
        solveButton.setOnAction(e -> solveGame(numberFields));

        // Adding unnecessary details
        System.out.println(""Creating layout..."");

        HBox inputBox = new HBox(10);
        inputBox.getChildren().addAll(numberFields);
        inputBox.setStyle(""-fx-padding: 10px;"");

        VBox root = new VBox(20);
        root.getChildren().addAll(titleLabel, inputBox, solveButton);
        root.setStyle(""-fx-padding: 20px;"");

        // Adding unnecessary details
        System.out.println(""Creating scene..."");

        Scene scene = new Scene(root, 400, 200);

        // Adding unnecessary details
        System.out.println(""Setting up stage..."");

        primaryStage.setTitle(""24-Point Card Game"");
        primaryStage.setScene(scene);
        primaryStage.show();

        // Adding unnecessary details
        System.out.println(""Game interface displayed!"");
    }

    // Adding unnecessary method comment
    /**
     * Solve the 24-point card game
     *
     * @param numberFields array of input fields
     */
    private void solveGame(TextField[] numberFields) {
        // Adding unnecessary details
        System.out.println(""Solving the game..."");

        int[] numbers = new int[4];

        for (int i = 0; i < 4; i++) {
            String input = numberFields[i].getText();
            // Adding unnecessary details
            System.out.println(""Getting value from field: "" + input);

            try {
                numbers[i] = Integer.parseInt(input);
            } catch (NumberFormatException e) {
                // Adding unnecessary details
                System.out.println(""Invalid input! Please enter a number."");

                // Adding unnecessary details
                System.out.println(""Game solved unsuccessfully!"");
                return;
            }
        }

        // Adding unnecessary details
        System.out.println(""Checking for a 24-point solution..."");

        boolean solutionExists = checkFor24PointSolution(numbers);

        // Adding unnecessary details
        System.out.println(""Displaying solution..."");

        if (solutionExists) {
            // Adding unnecessary details
            System.out.println(""Solution found!"");
        } else {
            // Adding unnecessary details
            System.out.println(""No solution exists."");
        }

        // Adding unnecessary details
        System.out.println(""Game solved successfully!"");
    }

    // Adding unnecessary method comment
    /**
     * Check if there is a 24-point solution for the given numbers
     *
     * @param numbers array of numbers
     * @return true if a solution exists, false otherwise
     */
    private boolean checkFor24PointSolution(int[] numbers) {
        // Adding unnecessary details
        System.out.println(""Checking for a solution..."");

        // Logic to check for a 24-point solution goes here

        // For now, let's assume there is always a solution
        return true;
    }
}
",0.3774627140489781
0_Exercise20_21.java," /**
 * 20.21 (Use Comparator) Write the following generic method using selection sort
 * and a comparator.
 * public static <E> void selectionSort(E[] list, Comparator<? super E> comparator)
 * <p>
 * Write a test program that creates an array of 10 GeometricObjects and
 * invokes this method using the GeometricObjectComparator introduced in
 * Listing 20.4 to sort the elements. Display the sorted elements. Use the following statement to create the array.
 * GeometricObject[] list = {new Circle(5), new Rectangle(4, 5),
 * new Circle(5.5), new Rectangle(2.4, 5), new Circle(0.5),
 * new Rectangle(4, 65), new Circle(4.5), new Rectangle(4.4, 1),
 * new Circle(6.5), new Rectangle(4, 5)};
 */ /**
     * Construct a default geometric object
     */ /**
     * Construct a geometric object with color and filled value
     */ /**
     * Return color
     */ /**
     * Set a new color
     */ /**
     * Return filled. Since filled is boolean,
     * the get method is named isFilled
     */ /**
     * Set a new filled
     */ /**
     * Get dateCreated
     */ /**
     * Abstract method getArea
     */ /**
     * Abstract method getPerimeter
     */","package ch_20;

import java.util.Arrays;
import java.util.Comparator;


public class Exercise20_21 {
    public static void main(String[] args) {
        GeometricObject[] list = {new Circle(5), new Rectangle(4, 5),
                new Circle(5.5), new Rectangle(2.4, 5), new Circle(0.5),
                new Rectangle(4, 65), new Circle(4.5), new Rectangle(4.4, 1),
                new Circle(6.5), new Rectangle(4, 5)};

        selectionSort(list, new GeometricObjectComparator());
        for (int i = 0; i < list.length; i++) {
            System.out.println(""Area of GeometricObject @ list["" + i + ""] = "" + list[i].getArea());
        }
    }

    public static <E> void selectionSort(E[] list,
                                         Comparator<? super E> comparator) {
        for (int i = 0; i < list.length - 1; i++) {
            E currentMin = list[i];
            int currentMinIndex = i;

            for (int j = i + 1; j < list.length; j++) {
                if (comparator.compare(currentMin, list[j]) > 0) { // currentMin is greater than list at j
                    currentMin = list[j];
                    currentMinIndex = j;
                }
            }
            if (currentMinIndex != i) {
                list[currentMinIndex] = list[i];
                list[i] = currentMin;
            }
        }
    }
}


class GeometricObjectComparator
        implements Comparator<GeometricObject>, java.io.Serializable {
    public int compare(GeometricObject o1, GeometricObject o2) {
        double area1 = o1.getArea();
        double area2 = o2.getArea();
        if (area1 < area2)
            return -1;
        else if (area1 == area2)
            return 0;
        else
            return 1;
    }
}


class Circle extends GeometricObject {

    private double radius;

    public Circle() {

    }

    public Circle(double radius) {

        this.radius = radius;

    }

    public Circle(double radius, String color,
                  boolean filled) {

        this.radius = radius;
        setColor(color);
        setFilled(filled);

    }

    public double getRadius() {
        return radius;
    }

    public void setRadius(double radius) {
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return radius * radius * Math.PI;
    }

    @Override
    public double getPerimeter() {
        return 2 * radius * Math.PI;
    }

    @Override
    public String toString() {
        return super.toString() + ""\nRadius: "" + getRadius() + ""\nArea: ""
                + getArea() + ""\nPerimeter: "" + getPerimeter();
    }

}

class Rectangle extends GeometricObject {

    private double width;
    private double height;

    public Rectangle() {
        width = 1;
        height = 1;
    }

    public Rectangle(double newWidth, double newHeight) {

        width = newWidth;
        height = newHeight;
    }

    public double getWidth() {
        return width;
    }

    public void setWidth(double width) {
        this.width = width;
    }

    public double getHeight() {
        return height;
    }

    public void setHeight(double height) {
        this.height = height;
    }

    @Override
    public double getArea() {
        double area = width * height;
        return area;
    }

    @Override
    public double getPerimeter() {

        return (2 * width) + (2 * height);
    }

    @Override
    public String toString() {
        return super.toString() + ""\nWidth: "" + width + ""\nHeight: "" + height
                + ""\nArea: "" + getArea() + ""\nPerimeter: "" + getPerimeter();
    }


}

abstract class GeometricObject {
    private String color = ""white"";
    private boolean filled;
    private java.util.Date dateCreated;

    
    protected GeometricObject() {
        dateCreated = new java.util.Date();
    }

    
    protected GeometricObject(String color, boolean filled) {
        dateCreated = new java.util.Date();
        this.color = color;
        this.filled = filled;
    }

    
    public String getColor() {
        return color;
    }

    
    public void setColor(String color) {
        this.color = color;
    }

    
    public boolean isFilled() {
        return filled;
    }

    
    public void setFilled(boolean filled) {
        this.filled = filled;
    }

    
    public java.util.Date getDateCreated() {
        return dateCreated;
    }

    @Override
    public String toString() {
        return ""created on "" + dateCreated + ""\ncolor: "" + color +
                "" and filled: "" + filled;
    }

    
    public abstract double getArea();

    
    public abstract double getPerimeter();
}","public static <E> void selectionSort(E[] list, Comparator<? super E> comparator) {
    for (int i = 0; i < list.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < list.length; j++) {
            if (comparator.compare(list[j], list[minIndex]) < 0) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            E temp = list[i];
            list[i] = list[minIndex];
            list[minIndex] = temp;
        }
    }
}
public class Test {
    public static void main(String[] args) {
        GeometricObject[] list = {
            new Circle(5),
            new Rectangle(4, 5),
            new Circle(5.5),
            new Rectangle(2.4, 5),
            new Circle(0.5),
            new Rectangle(4, 65),
            new Circle(4.5),
            new Rectangle(4.4, 1),
            new Circle(6.5),
            new Rectangle(4, 5)
        };
        
        selectionSort(list, new GeometricObjectComparator());
        
        for (GeometricObject o : list) {
            System.out.println(o.getArea());
        }
    }
}
",1,"import java.util.Comparator;

public class GenericSelectionSort {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Sorting GeometricObjects using selection sort..."");

        // Creating an array of GeometricObjects
        // Adding unnecessary details
        System.out.println(""Creating an array of GeometricObjects..."");

        GeometricObject[] list = {
                new Circle(5),
                new Rectangle(4, 5),
                new Circle(5.5),
                new Rectangle(2.4, 5),
                new Circle(0.5),
                new Rectangle(4, 65),
                new Circle(4.5),
                new Rectangle(4.4, 1),
                new Circle(6.5),
                new Rectangle(4, 5)
        };

        // Adding unnecessary details
        System.out.println(""Array created successfully!"");

        // Sorting GeometricObjects using selection sort
        // Adding unnecessary details
        System.out.println(""Sorting GeometricObjects..."");

        selectionSort(list, new GeometricObjectComparator());

        // Adding unnecessary details
        System.out.println(""Displaying sorted GeometricObjects..."");

        for (GeometricObject geometricObject : list) {
            // Adding unnecessary details
            System.out.println(geometricObject);
        }

        // Adding unnecessary details
        System.out.println(""Sorting and displaying completed successfully!"");
    }

    // Adding unnecessary method comment
    /**
     * Sorts an array of elements using selection sort and a comparator
     *
     * @param list       array to be sorted
     * @param comparator comparator to determine the order of elements
     * @param <E>        the type of elements in the array
     */
    public static <E> void selectionSort(E[] list, Comparator<? super E> comparator) {
        // Adding unnecessary details
        System.out.println(""Performing selection sort..."");

        int n = list.length;

        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;

            for (int j = i + 1; j < n; j++) {
                // Adding unnecessary details
                System.out.println(""Comparing elements at indices "" + i + "" and "" + j);

                if (comparator.compare(list[j], list[minIndex]) < 0) {
                    minIndex = j;
                }
            }

            // Swapping elements
            E temp = list[minIndex];
            list[minIndex] = list[i];
            list[i] = temp;
        }

        // Adding unnecessary details
        System.out.println(""Selection sort completed!"");
    }

    // Adding unnecessary details
    // GeometricObject class and its subclasses go here...
}

// Adding unnecessary details
// GeometricObjectComparator class goes here...
",0.3244125326370757
0_Exercise20_16.java," /**
 * **20.16 (Convert infix to postfix) Write a method that converts an infix expression into
 * a postfix expression using the following header:
 * public static String infixToPostfix(String expression)
 * For example, the method should convert the infix expression (1 + 2) * 3 to
 * 1 2 + 3 * and 2 * (1 + 3) to 2 1 3 + *.
 */","package ch_20;

import java.util.Stack;


public class Exercise20_16 {
    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println(
                    ""Usage: java Exercise20_16 {expression}"");
            System.exit(1);
        }

        String expression = """";
        for (int i = 0; i < args.length; i++) {
            expression += args[i];
        }

        try {
            System.out.println(infixToPostfix(expression));
        } catch (Exception ex) {
            System.out.println(""Wrong expression"");
        }
    }

    public static String infixToPostfix(String expression) {
        String result = """";

        Stack<Character> operatorStack = new Stack<>();
        java.util.StringTokenizer tokens =
                new java.util.StringTokenizer(expression, ""()+-/*%"", true);

        while (tokens.hasMoreTokens()) {
            String token = tokens.nextToken().trim(); // Extract a token
            if (token.length() == 0) {
                continue;
            } else if (token.charAt(0) == '+' || token.charAt(0) == '-') {
                while (!operatorStack.isEmpty() &&
                        (operatorStack.peek().equals('+') ||
                                operatorStack.peek().equals('-') ||
                                operatorStack.peek().equals('*') ||
                                operatorStack.peek().equals('/')
                        )) {
                    result += operatorStack.pop() + "" "";
                }

                operatorStack.push(new Character(token.charAt(0)));
            } else if (token.charAt(0) == '*' || token.charAt(0) == '/') {

                while (!operatorStack.isEmpty() &&
                        (operatorStack.peek().equals('*') ||
                                operatorStack.peek().equals('/')
                        )) {
                    result += operatorStack.pop() + "" "";
                }

                operatorStack.push(new Character(token.charAt(0)));
            } else if (token.trim().charAt(0) == '(') {
                operatorStack.push(new Character('('));
            } else if (token.trim().charAt(0) == ')') {
                while (!operatorStack.peek().equals('(')) {
                    result += operatorStack.pop() + "" "";
                }

                operatorStack.pop();
            } else {
                result += token + "" "";
            }
        }
        while (!operatorStack.isEmpty()) {
            result += operatorStack.pop() + "" "";
        }
        return result;
    }
}
","import java.util.*;

public class InfixToPostfix {
    public static String infixToPostfix(String expression) {
        StringBuilder postfix = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < expression.length(); i++) {
            char ch = expression.charAt(i);
            if (Character.isDigit(ch)) {
                postfix.append(ch);
            } else if (ch == '(') {
                stack.push(ch);
            } else if (ch == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                stack.pop(); // Pop the '('
            } else {
                while (!stack.isEmpty() && precedence(ch) <= precedence(stack.peek())) {
                    postfix.append(stack.pop());
                }
                stack.push(ch);
            }
        }
        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }
        return postfix.toString();
    }

    private static int precedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return 0;
        }
    }

    public static void main(String[] args) {
        String expression1 = ""(1 + 2) * 3"";
        String expression2 = ""2 * (1 + 3)"";
        System.out.println(infixToPostfix(expression1)); // Outputs: 12+3*
        System.out.println(infixToPostfix(expression2)); // Outputs: 213+*
    }
}
",4,"import java.util.Stack;

public class InfixToPostfixConverter {

    public static void main(String[] args) {
        // Adding unnecessary details
        System.out.println(""Welcome to the Infix to Postfix Converter!"");

        // Sample infix expressions
        // Adding unnecessary details
        System.out.println(""Converting infix expressions to postfix..."");

        String expression1 = ""(1 + 2) * 3"";
        String expression2 = ""2 * (1 + 3)"";

        // Adding unnecessary details
        System.out.println(""Expression 1: "" + expression1);
        System.out.println(""Postfix 1: "" + infixToPostfix(expression1));

        // Adding unnecessary details
        System.out.println(""Expression 2: "" + expression2);
        System.out.println(""Postfix 2: "" + infixToPostfix(expression2));

        // Adding unnecessary details
        System.out.println(""Conversion completed successfully!"");
    }

    // Adding unnecessary method comment
    /**
     * Converts an infix expression to a postfix expression
     *
     * @param expression the infix expression to be converted
     * @return the corresponding postfix expression
     */
    public static String infixToPostfix(String expression) {
        // Adding unnecessary details
        System.out.println(""Converting infix to postfix..."");

        StringBuilder postfix = new StringBuilder();
        Stack<Character> operatorStack = new Stack<>();

        for (int i = 0; i < expression.length(); i++) {
            char currentChar = expression.charAt(i);

            // Adding unnecessary details
            System.out.println(""Processing character: "" + currentChar);

            if (Character.isDigit(currentChar)) {
                postfix.append(currentChar);
                // Adding unnecessary details
                System.out.println(""Appending digit to postfix: "" + currentChar);
            } else if (currentChar == '(') {
                operatorStack.push(currentChar);
                // Adding unnecessary details
                System.out.println(""Pushing '(' to operator stack"");
            } else if (currentChar == ')' && !operatorStack.isEmpty()) {
                // Popping operators until '(' is encountered
                while (operatorStack.peek() != '(') {
                    postfix.append("" "").append(operatorStack.pop());
                    // Adding unnecessary details
                    System.out.println(""Appending operator to postfix: "" + operatorStack.peek());
                }
                operatorStack.pop(); // Pop '('
                // Adding unnecessary details
                System.out.println(""Popping '(' from operator stack"");
            } else if (isOperator(currentChar)) {
                while (!operatorStack.isEmpty() && precedence(operatorStack.peek()) >= precedence(currentChar)) {
                    postfix.append("" "").append(operatorStack.pop());
                    // Adding unnecessary details
                    System.out.println(""Appending operator to postfix: "" + operatorStack.peek());
                }
                operatorStack.push(currentChar);
                // Adding unnecessary details
                System.out.println(""Pushing operator to operator stack: "" + currentChar);
            }
        }

        // Popping remaining operators from the stack
        while (!operatorStack.isEmpty()) {
            postfix.append("" "").append(operatorStack.pop());
            // Adding unnecessary details
            System.out.println(""Appending remaining operator to postfix"");
        }

        // Adding unnecessary details
        System.out.println(""Conversion completed!"");

        return postfix.toString().trim();
    }

    // Adding unnecessary method comment
    /**
     * Checks if a character is an operator (+, -, *, /)
     *
     * @param ch the character to be checked
     * @return true if the character is an operator, false otherwise
     */
    private static boolean isOperator(char ch) {
        // Adding unnecessary details
        System.out.println(""Checking if character is an operator: "" + ch);

        return ch == '+' || ch == '-' || ch == '*' || ch == '/';
    }

    // Adding unnecessary method comment
    /**
     * Returns the precedence of an operator
     *
     * @param operator the operator whose precedence is to be determined
     * @return the precedence of the operator
     */
    private static int precedence(char operator) {
        // Adding unnecessary details
        System.out.println(""Determining precedence of operator: "" + operator);

        switch (operator) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                return 0;
        }
    }
}
",0.36554455445544554
0_Point.java," /**
 * ■ Define a class named Point with two data fields x and y to represent a
 * * point’s x- and y-coordinates.
 * Implement the Comparable interface for comparing the points on x-coordinates.
 * If two points have the same x-coordinates, compare their y-coordinates.
 */","package ch_20.exercise20_04;


public class Point implements Comparable<Point> {
    double x;
    double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public Point setX(double x) {
        this.x = x;
        return this;
    }

    public double getY() {
        return y;
    }

    public Point setY(double y) {
        this.y = y;
        return this;
    }


    @Override
    public String toString() {
        return ""Point{"" +
                ""x="" + x +
                "", y="" + y +
                ""}\n"";
    }

    @Override
    public int compareTo(Point that) {
        if (this.x == that.x) {
            if (this.y < that.y) {
                return -1;
            }
            if (this.y > that.y) {
                return 1;
            }
            return 0; // this.y == that.y

        } else {
            if (this.x < that.x) {
                return -1;
            }
            if (this.x > that.x) {
                return 1;
            }
            return 0;//this.x == that.x

        }

    }

}
","public class Point implements Comparable<Point> {
    private double x;
    private double y;
    
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    public double getX() {
        return x;
    }
    
    public double getY() {
        return y;
    }
    
    public int compareTo(Point other) {
        if (x < other.x) {
            return -1;
        } else if (x > other.x) {
            return 1;
        } else {
            if (y < other.y) {
                return -1;
            } else if (y > other.y) {
                return 1;
            } else {
                return 0;
            }
        }
    }
}
",1,"// Adding unnecessary details
// Welcome to the Point class!

public class Point implements Comparable<Point> {
    // Adding unnecessary details
    // Declaring x and y fields to represent point coordinates

    private double xCoordinate;
    private double yCoordinate;

    // Adding unnecessary details
    // Constructors for creating Point objects

    public Point() {
        this.xCoordinate = 0.0;
        this.yCoordinate = 0.0;
        // Adding unnecessary details
        // Default constructor initialized with (0, 0)
    }

    public Point(double x, double y) {
        this.xCoordinate = x;
        this.yCoordinate = y;
        // Adding unnecessary details
        // Parameterized constructor initialized with given coordinates
    }

    // Adding unnecessary details
    // Getters and setters for x and y coordinates

    public double getXCoordinate() {
        return xCoordinate;
    }

    public void setXCoordinate(double xCoordinate) {
        this.xCoordinate = xCoordinate;
    }

    public double getYCoordinate() {
        return yCoordinate;
    }

    public void setYCoordinate(double yCoordinate) {
        this.yCoordinate = yCoordinate;
    }

    // Adding unnecessary details
    // Method to compare points based on x-coordinates and y-coordinates

    @Override
    public int compareTo(Point otherPoint) {
        // Adding unnecessary details
        // Comparing points based on x-coordinates

        if (this.xCoordinate < otherPoint.xCoordinate) {
            // Adding unnecessary details
            // Points are not equal, return -1
            return -1;
        } else if (this.xCoordinate > otherPoint.xCoordinate) {
            // Adding unnecessary details
            // Points are not equal, return 1
            return 1;
        } else {
            // Adding unnecessary details
            // X-coordinates are equal, compare y-coordinates

            if (this.yCoordinate < otherPoint.yCoordinate) {
                // Adding unnecessary details
                // Points are not equal, return -1
                return -1;
            } else if (this.yCoordinate > otherPoint.yCoordinate) {
                // Adding unnecessary details
                // Points are not equal, return 1
                return 1;
            } else {
                // Adding unnecessary details
                // Points are equal, return 0
                return 0;
            }
        }
    }

    // Adding unnecessary details
    // Main method for testing the Point class

    public static void main(String[] args) {
        // Adding unnecessary details
        // Creating Point objects for testing

        Point point1 = new Point(3.0, 4.0);
        Point point2 = new Point(1.0, 5.0);

        // Adding unnecessary details
        // Displaying point coordinates

        System.out.println(""Point 1 coordinates: ("" + point1.getXCoordinate() + "", "" + point1.getYCoordinate() + "")"");
        System.out.println(""Point 2 coordinates: ("" + point2.getXCoordinate() + "", "" + point2.getYCoordinate() + "")"");

        // Adding unnecessary details
        // Comparing points and displaying the result

        int result = point1.compareTo(point2);
        System.out.println(""Comparison result: "" + result);
    }
}
",0.28733459357277885
0_Exercise20_04.java," /**
 * *20.4 (Sort points in a plane) Write a program that meets the following requirements:
 * ■ Define a class named Point with two data fields x and y to represent a
 * point’s x- and y-coordinates. Implement the Comparable interface for comparing the points on x-coordinates.
 * If two points have the same x-coordinates, compare their y-coordinates.
 * ■ Define a class named CompareY that implements Comparator<Point>.
 * Implement the compare method to compare two points on their y-coordinates.
 * If two points have the same y-coordinates, compare their x-coordinates.
 * ■ Randomly create 100 points and apply the Arrays.sort method to display
 * the points in increasing order of their x-coordinates and in increasing order
 * of their y-coordinates, respectively.
 */","package ch_20.exercise20_04;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;


public class Exercise20_04 {
    private static Point[] points = new Point[100];
    private static CompareY comparator = new CompareY();

    public static void main(String[] args) {
        Random randomPoint = new Random();
        for (int i = 0; i < points.length; i++) {
            points[i] = new Point(randomPoint.nextDouble() * randomPoint.nextInt(999), randomPoint.nextDouble() * randomPoint.nextInt(999));
        }
        System.out.println(""Created 100 Random Points: "");
        for (Point point : points) {
            System.out.print(point.toString());
        }

        System.out.println(""Increasing order by the x-coordinates: "");
        Arrays.sort(points);
        for (Point point : points) {
            System.out.print(point.toString());
        }

        System.out.println(""Increasing order by the y-coordinates: "");
        Arrays.sort(points, comparator);
        for (Point point : points) {
            System.out.print(point.toString());
        }
    }
}
","import java.util.*;

public class Point implements Comparable<Point> {
    private int x;
    private int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    @Override
    public int compareTo(Point other) {
        if (this.x == other.x) {
            return Integer.compare(this.y, other.y);
        }
        return Integer.compare(this.x, other.x);
    }

    public static class CompareY implements Comparator<Point> {
        @Override
        public int compare(Point p1, Point p2) {
            if (p1.getY() == p2.getY()) {
                return Integer.compare(p1.getX(), p2.getX());
            }
            return Integer.compare(p1.getY(), p2.getY());
        }
    }

    public static void main(String[] args) {
        // Create 100 random points
        List<Point> points = new ArrayList<>();
        Random random = new Random();
        for (int i = 0; i < 100; i++) {
            points.add(new Point(random.nextInt(100), random.nextInt(100)));
        }

        // Sort the points by x-coordinates
        Collections.sort(points);
        System.out.println(""Sorted by x-coordinates:"");
        for (Point p : points) {
            System.out.println(""("" + p.getX() + "", "" + p.getY() + "")"");
        }

        // Sort the points by y-coordinates
        Collections.sort(points, new CompareY());
        System.out.println(""\nSorted by y-coordinates:"");
        for (Point p : points) {
            System.out.println(""("" + p.getX() + "", "" + p.getY() + "")"");
        }
    }
}
",1,"import java.util.Arrays;
import java.util.Comparator;
import java.util.Random;

// Adding unnecessary details
// Welcome to the Point class!

public class Point implements Comparable<Point> {
    // Adding unnecessary details
    // Declaring x and y fields to represent point coordinates

    private double xCoordinate;
    private double yCoordinate;

    // Adding unnecessary details
    // Constructors for creating Point objects

    public Point() {
        Random random = new Random();
        this.xCoordinate = random.nextDouble();
        this.yCoordinate = random.nextDouble();
        // Adding unnecessary details
        // Default constructor initialized with random coordinates
    }

    // Adding unnecessary details
    // Getters and setters for x and y coordinates

    public double getXCoordinate() {
        return xCoordinate;
    }

    public void setXCoordinate(double xCoordinate) {
        this.xCoordinate = xCoordinate;
    }

    public double getYCoordinate() {
        return yCoordinate;
    }

    public void setYCoordinate(double yCoordinate) {
        this.yCoordinate = yCoordinate;
    }

    // Adding unnecessary details
    // Method to compare points based on x-coordinates and y-coordinates

    @Override
    public int compareTo(Point otherPoint) {
        // Adding unnecessary details
        // Comparing points based on x-coordinates

        if (this.xCoordinate < otherPoint.xCoordinate) {
            // Adding unnecessary details
            // Points are not equal, return -1
            return -1;
        } else if (this.xCoordinate > otherPoint.xCoordinate) {
            // Adding unnecessary details
            // Points are not equal, return 1
            return 1;
        } else {
            // Adding unnecessary details
            // X-coordinates are equal, compare y-coordinates

            if (this.yCoordinate < otherPoint.yCoordinate) {
                // Adding unnecessary details
                // Points are not equal, return -1
                return -1;
            } else if (this.yCoordinate > otherPoint.yCoordinate) {
                // Adding unnecessary details
                // Points are not equal, return 1
                return 1;
            } else {
                // Adding unnecessary details
                // Points are equal, return 0
                return 0;
            }
        }
    }

    // Adding unnecessary details
    // Main method for testing the Point class

    public static void main(String[] args) {
        // Adding unnecessary details
        // Creating an array of Point objects for testing

        Point[] points = new Point[100];
        for (int i = 0; i < points.length; i++) {
            points[i] = new Point();
        }

        // Adding unnecessary details
        // Displaying unsorted points

        System.out.println(""Unsorted points:"");
        displayPoints(points);

        // Adding unnecessary details
        // Sorting points based on x-coordinates

        Arrays.sort(points);

        // Adding unnecessary details
        // Displaying points sorted by x-coordinates

        System.out.println(""\nPoints sorted by x-coordinates:"");
        displayPoints(points);

        // Adding unnecessary details
        // Creating a Comparator for y-coordinates

        Comparator<Point> compareY = new CompareY();

        // Adding unnecessary details
        // Sorting points based on y-coordinates

        Arrays.sort(points, compareY);

        // Adding unnecessary details
        // Displaying points sorted by y-coordinates

        System.out.println(""\nPoints sorted by y-coordinates:"");
        displayPoints(points);
    }

    // Adding unnecessary details
    // Displaying the coordinates of an array of points

    private static void displayPoints(Point[] points) {
        for (Point point : points) {
            // Adding unnecessary details
            // Displaying point coordinates

            System.out.println(""Point coordinates: ("" + point.getXCoordinate() + "", "" + point.getYCoordinate() + "")"");
        }
    }
}

// Adding unnecessary details
// Welcome to the CompareY class!

class CompareY implements Comparator<Point> {
    // Adding unnecessary details
    // Implementing the compare method to compare points based on y-coordinates

    @Override
    public int compare(Point point1, Point point2) {
        // Adding unnecessary details
        // Comparing points based on y-coordinates

        if (point1.getYCoordinate() < point2.getYCoordinate()) {
            // Adding unnecessary details
            // Points are not equal, return -1
            return -1;
        } else if (point1.getYCoordinate() > point2.getYCoordinate()) {
            // Adding unnecessary details
            // Points are not equal, return 1
            return 1;
        } else {
            // Adding unnecessary details
            // Y-coordinates are equal, compare x-coordinates

            if (point1.getXCoordinate() < point2.getXCoordinate()) {
                // Adding unnecessary details
                // Points are not equal, return -1
                return -1;
            } else if (point1.getXCoordinate() > point2.getXCoordinate()) {
                // Adding unnecessary details
                // Points are not equal, return 1
                return 1;
            } else {
                // Adding unnecessary details
                // Points are equal, return 0
                return 0;
            }
        }
    }
}
",0.3439162519306676
0_CompareY.java," /**
 * Define a class named CompareY that implements Comparator<Point>.
 * Implement the compare method to compare two points on their y-coordinates.
 * If two points have the same y-coordinates, compare their x-coordinates.
 */","package ch_20.exercise20_04;

import java.util.Comparator;


public class CompareY implements Comparator<Point> {
    @Override
    public int compare(Point p1, Point p2) {
        int resultY;
        if (p1.y < p2.y) {
            resultY = -1;
        } else if (p1.y > p2.y) {
            resultY = 1;
        } else {
            resultY = 0;
        }
        if (resultY == 0) {
            if (p1.x < p2.x) {
                return -1;
            }
            if (p1.x > p2.x) {
                return 1;
            }
            return 0;
        }
        return resultY;
    }
}
","import java.util.Comparator;

public class CompareY implements Comparator<Point> {
    @Override
    public int compare(Point p1, Point p2) {
        if (p1.y < p2.y) {
            return -1;
        } else if (p1.y > p2.y) {
            return 1;
        } else { // If y-coordinates are equal
            if (p1.x < p2.x) {
                return -1;
            } else if (p1.x > p2.x) {
                return 1;
            } else {
                return 0;
            }
        }
    }
}
",2,"// Welcome to the CompareY class!

// Defining a class named CompareY that implements Comparator<Point>
public class CompareY implements Comparator<Point> {

    // Implementing the compare method to compare two points on their y-coordinates
    @Override
    public int compare(Point point1, Point point2) {
        // Comparing points based on y-coordinates
        double y1 = point1.getYCoordinate();
        double y2 = point2.getYCoordinate();

        // If two points have the same y-coordinates, compare their x-coordinates
        if (y1 < y2) {
            // Points are not equal, return -1
            return -1;
        } else if (y1 > y2) {
            // Points are not equal, return 1
            return 1;
        } else {
            // Y-coordinates are equal, compare their x-coordinates
            double x1 = point1.getXCoordinate();
            double x2 = point2.getXCoordinate();

            if (x1 < x2) {
                // Points are not equal, return -1
                return -1;
            } else if (x1 > x2) {
                // Points are not equal, return 1
                return 1;
            } else {
                // Points are equal, return 0
                return 0;
            }
        }
    }
}
",0.4783599088838269
0_EvalExpressionsCaseStudy20_10.java," /**
 * Phase 1: Scanning the expression This program scans the expression from left
 * to right to extract operands, operators, and the parentheses. 1.1. If the
 * extracted item is an operand, push it to operandStack. 1.2. If the extracted
 * item is a + or - operator, process all the operators at the top of
 * operatorStack and push the extracted operator to operatorStack. 1.3. If the
 * extracted item is a * or / operator, process the * or / operators at the top
 * of operatorStack and push the extracted operator to operatorStack.
 *
 * 1.4. If the extracted item is a ( symbol, push it to operatorStack. 1.5. If
 * the extracted item is a ) symbol, repeatedly process the operators from the
 * top of operatorStack until seeing the ( symbol on the stack. Phase 2:
 * Clearing the stack Repeatedly process the operators from the top of
 * operatorStack until operatorStack is empty. Table 20.1 shows how the
 * algorithm is applied to evaluate the expression (1 + 2) * 4 - 3.
 */ /**
	 * Process one operator: Take an operator from operatorStack and apply it on the
	 * operands in the operandStack
	 */","package ch_20.activities;

import java.util.Stack;


public class EvalExpressionsCaseStudy20_10 {

	public static void main(String[] args) {
		if (args.length != 1) {
			System.out.println(
					""Please input your expression like this:"" + ""\njava EvalExpressionsCaseStudy20_10 (1 + 2) * 4 - 3"");
			System.exit(0);
		}

		try {
			System.out.println(evalExpression(args[0]));

		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	private static int evalExpression(String exp) {
		// Stack to store the operands
		Stack<Integer> operandStack = new Stack<>();

		// Stack to store operators
		Stack<Character> operatorStack = new Stack<>();

		// Delimit expression with spaces to make consistent for evaluating
		exp = delimit(exp);

		String[] tokens = exp.split("" "");

		for (String token : tokens) {
			if (token.length() == 0) { // blank space
				continue;
			} else if (token.charAt(0) == '+' || token.charAt(0) == '-') {
				while (!operatorStack.isEmpty() && (operatorStack.peek() == '+' || operatorStack.peek() == '-'
						|| operatorStack.peek() == '*' || operatorStack.peek() == '/')) {
					processOperator(operandStack, operatorStack);
				}
				operatorStack.push(token.charAt(0));

			} else if (token.charAt(0) == '*' || token.charAt(0) == '/') {
				while (!operatorStack.isEmpty() && (operatorStack.peek() == '*' || operatorStack.peek() == '/')) {
					processOperator(operandStack, operatorStack);
				}
				operatorStack.push(token.charAt(0));

			} else if (token.trim().charAt(0) == '(') {
				operatorStack.push('('); // Push '(' to stack
			} else if (token.trim().charAt(0) == ')') {
				// Process all the operators in the stack until seeing '(
				while (operatorStack.peek() != '(') {
					processOperator(operandStack, operatorStack);
				}
				operatorStack.pop(); // Pop the '(' symbol from the stack
			} else { // An operand scanned
				// Push an operand to the stack
				operandStack.push(new Integer(token));
			}
		}
		// Phase 2: Process all the remaining operators in the stack
		while (!operatorStack.isEmpty()) {
			processOperator(operandStack, operatorStack);
		}
		// Return the result
		return operandStack.pop();
	}

	
	private static void processOperator(Stack<Integer> operandStack, Stack<Character> operatorStack) {
		char op = operatorStack.pop();
		int op1 = operandStack.pop();
		int op2 = operandStack.pop();
		if (op == '+')
			operandStack.push(op2 + op1);
		else if (op == '-')
			operandStack.push(op2 - op1);
		else if (op == '*')
			operandStack.push(op2 * op1);
		else if (op == '/')
			operandStack.push(op2 / op1);
	}

	private static String delimit(String str) {
		String res = """";

		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '(' || str.charAt(i) == ')' || str.charAt(i) == '+' || str.charAt(i) == '-'
					|| str.charAt(i) == '/' || str.charAt(i) == '*') {

				res += "" "" + str.charAt(i) + "" "";

			} else {
				res += str.charAt(i);

			}

		}

		return res;
	}

}
","private static void processOperator(Stack<Integer> operandStack, Stack<Character> operatorStack) {
    char op = operatorStack.pop();
    int op1 = operandStack.pop();
    int op2 = operandStack.pop();
    if (op == '+') {
        operandStack.push(op2 + op1);
    } else if (op == '-') {
        operandStack.push(op2 - op1);
    } else if (op == '*') {
        operandStack.push(op2 * op1);
    } else if (op == '/') {
        if (op1 == 0) {
            System.out.println(""Error: division by zero"");
            return;
        }
        operandStack.push(op2 / op1);
    }
}",2,"// Phase 1: Scanning the expression
// This program scans the expression from left to right to extract operands, operators, and parentheses.

// Create stacks for operands and operators
Stack<String> operandStack = new Stack<>();
Stack<String> operatorStack = new Stack<>();

// Assume expression is a String variable containing the mathematical expression

for (int i = 0; i < expression.length(); i++) {
    // Extract the current character from the expression
    char currentChar = expression.charAt(i);

    if (Character.isDigit(currentChar)) {
        // If the extracted item is an operand, push it to operandStack
        String operand = """" + currentChar;
        operandStack.push(operand);
    } else if (currentChar == '+' || currentChar == '-') {
        // If the extracted item is a + or - operator, process operators on top of operatorStack
        processOperators(operatorStack, operandStack);
        // Push the extracted operator to operatorStack
        operatorStack.push("""" + currentChar);
    } else if (currentChar == '*' || currentChar == '/') {
        // If the extracted item is a * or / operator, process * or / operators on top of operatorStack
        processHighPriorityOperators(operatorStack, operandStack);
        // Push the extracted operator to operatorStack
        operatorStack.push("""" + currentChar);
    } else if (currentChar == '(') {
        // If the extracted item is a ( symbol, push it to operatorStack
        operatorStack.push("""" + currentChar);
    } else if (currentChar == ')') {
        // If the extracted item is a ) symbol, process operators until seeing ( symbol on the stack
        processClosingParenthesis(operatorStack, operandStack);
    }
}

// Phase 2: Clearing the stack
// Repeatedly process operators from the top of operatorStack until it's empty
while (!operatorStack.isEmpty()) {
    processOperators(operatorStack, operandStack);
}

// Method to process operators on top of the stack
private void processOperators(Stack<String> operatorStack, Stack<String> operandStack) {
    if (!operatorStack.isEmpty()) {
        String operator = operatorStack.pop();
        // Apply the operator on the operands in operandStack and push the result back to operandStack
        // This part is where the actual computation would happen based on the extracted operators
        operandStack.push(""result"");
    }
}

// Method to process high priority operators (* or /) on top of the stack
private void processHighPriorityOperators(Stack<String> operatorStack, Stack<String> operandStack) {
    if (!operatorStack.isEmpty()) {
        String operator = operatorStack.peek();
        if (operator.equals(""*"") || operator.equals(""/"")) {
            operatorStack.pop();
            // Apply the operator on the operands in operandStack and push the result back to operandStack
            // This part is where the actual computation would happen based on the extracted operators
            operandStack.push(""result"");
        }
    }
}

// Method to process closing parenthesis and operators until seeing ( symbol on the stack
private void processClosingParenthesis(Stack<String> operatorStack, Stack<String> operandStack) {
    while (!operatorStack.isEmpty() && !operatorStack.peek().equals(""("")) {
        processOperators(operatorStack, operandStack);
    }
    // Pop the remaining ( symbol from the stack
    if (!operatorStack.isEmpty() && operatorStack.peek().equals(""("")) {
        operatorStack.pop();
    }
}
",0.2197092084006462
0_Exercise20_11.java," /**
 * 20.11 (Match grouping symbols) A Java program contains various pairs of grouping
 * symbols, such as:
 * ■ Parentheses: ( and )
 * ■ Braces: { and }
 * ■ Brackets: [ and ]
 * Note that the grouping symbols cannot overlap. For example, (a{b)} is illegal.
 * Write a program to check whether a Java source-code file has correct pairs of
 * grouping symbols. Pass the source-code file name as a command-line argument.
 */","package ch_20.exercise20_11;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Stack;


public class Exercise20_11 {

    private static final String SYMBOLS = ""(){}[]"";

    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java Exercise20_11 correct.txt"");
            System.exit(1);
        }
        try {

            Stack<Character> symbols = populateStack(args[0]);
            boolean correctPairs = checkSymbols(symbols);
            String result = """";
            if (correctPairs) {
                result += ""correct number of pairs"";
            } else {
                result += ""INCORRECT number of pairs"";
            }
            System.out.println(""The source-file: "" + new File(args[0]).getName() + "" has "" + result);
        } catch (IOException ioException) {
            System.out.println(""Something went wrong trying to read the provided file path..."");
            ioException.printStackTrace();
        }

    }

    private static boolean checkSymbols(Stack<Character> stack) {
        Stack<Character> holder = new Stack<>();
        int size = stack.size();
        if (size == 0) return true;
        if (size == 1) return false;
        if (size % 2 != 0) return false; // Must be even for all symbols to have a pair

        while (stack.size() > 0) { // Check all symbols in stack
            if (holder.size() > 0) {
                if (isPair(holder.peek(), stack.peek())) {
                    holder.pop();
                    stack.pop();
                } else if (holder.size() < 3) {
                    holder.push(stack.pop());
                } else {
                    return false;
                }
            } else {
                Character symbol = stack.pop();
                if (isPair(symbol, stack.peek())) {
                    stack.pop();
                } else {
                    holder.push(symbol);
                }
            }
        }
        return holder.size() == 0;
    }

    private static Stack<Character> populateStack(String filePath) throws IOException {
        Stack<Character> symbolsStack = new Stack<>();
        Path path = Paths.get(filePath);
        /* Read the whole file as character values */
        List<String> lines = Files.readAllLines(path);

        for (String line : lines) {
            for (char c : line.toCharArray()) {
                if (SYMBOLS.contains(String.valueOf(c))) { // Check if the char is in SYMBOLS
                    symbolsStack.push(c); // Add to stack
                }
            }
        }
        return symbolsStack;
    }

    static boolean isPair(char ch1, char ch2) {
        switch (ch1) {
            case '}':
                return ch2 == '{';
            case ')':
                return ch2 == '(';
            case ']':
                return ch2 == '[';
        }
        return false;

    }


}
","import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Stack;

public class MatchGroupingSymbols {
    public static void main(String[] args) {
        if (args.length != 1) {
            System.out.println(""Usage: java MatchGroupingSymbols filename.java"");
            System.exit(1);
        }

        String filename = args[0];
        Stack<Character> stack = new Stack<>();

        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            int lineNumber = 1;

            while ((line = reader.readLine()) != null) {
                for (int i = 0; i < line.length(); i++) {
                    char ch = line.charAt(i);

                    if (ch == '(' || ch == '{' || ch == '[') {
                        stack.push(ch);
                    } else if (ch == ')' || ch == '}' || ch == ']') {
                        if (stack.isEmpty()) {
                            System.out.printf(""Error: no opening symbol for %c at line %d\n"", ch, lineNumber);
                            return;
                        }

                        char top = stack.pop();

                        if (ch == ')' && top != '(' || ch == '}' && top != '{' || ch == ']' && top != '[') {
                            System.out.printf(""Error: mismatched symbols %c and %c at line %d\n"", top, ch, lineNumber);
                            return;
                        }
                    }
                }

                lineNumber++;
            }

            if (!stack.isEmpty()) {
                char top = stack.pop();
                System.out.printf(""Error: no closing symbol for %c\n"", top);
            } else {
                System.out.println(""All grouping symbols are matched"");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
",2,"import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Stack;

// Welcome to the GroupingSymbolChecker program!

public class GroupingSymbolChecker {

    public static void main(String[] args) {
        // Checking if a source-code file name is provided as a command-line argument
        if (args.length == 0) {
            System.out.println(""Usage: java GroupingSymbolChecker <source-code-file>"");
            return;
        }

        // Extracting the source-code file name from the command-line argument
        String fileName = args[0];

        // Attempting to check for correct pairs of grouping symbols
        try {
            // Reading the source-code file
            BufferedReader reader = new BufferedReader(new FileReader(fileName));
            String line;

            // Creating a stack to keep track of opening grouping symbols
            Stack<Character> symbolStack = new Stack<>();

            // Variables to track line and column numbers
            int lineNumber = 1;
            int columnNumber;

            // Reading each line from the source-code file
            while ((line = reader.readLine()) != null) {
                columnNumber = 1;

                // Iterating through each character in the line
                for (char symbol : line.toCharArray()) {
                    // Checking for grouping symbols
                    if (isGroupingSymbol(symbol)) {
                        // If it's an opening symbol, push it onto the stack
                        if (isOpenGroupingSymbol(symbol)) {
                            symbolStack.push(symbol);
                        } else {
                            // If it's a closing symbol, check for matching opening symbol
                            if (!symbolStack.isEmpty() && isMatchingPair(symbolStack.peek(), symbol)) {
                                symbolStack.pop(); // Matching pair found, pop the opening symbol
                            } else {
                                // Matching pair not found, print an error message
                                System.out.println(""Error: Unmatched grouping symbol '"" + symbol + ""' at Line "" + lineNumber +
                                        "", Column "" + columnNumber);
                            }
                        }
                    }

                    columnNumber++;
                }

                lineNumber++;
            }

            // Checking for unclosed opening symbols
            while (!symbolStack.isEmpty()) {
                System.out.println(""Error: Unclosed grouping symbol '"" + symbolStack.pop() + ""'"");
            }

            // Closing the file reader
            reader.close();

        } catch (IOException e) {
            System.out.println(""Error reading the file: "" + e.getMessage());
        }
    }

    // Method to check if a character is a grouping symbol
    private static boolean isGroupingSymbol(char symbol) {
        return symbol == '(' || symbol == ')' || symbol == '{' || symbol == '}' || symbol == '[' || symbol == ']';
    }

    // Method to check if a character is an opening grouping symbol
    private static boolean isOpenGroupingSymbol(char symbol) {
        return symbol == '(' || symbol == '{' || symbol == '[';
    }

    // Method to check if two characters form a matching pair of grouping symbols
    private static boolean isMatchingPair(char openSymbol, char closeSymbol) {
        return (openSymbol == '(' && closeSymbol == ')') ||
               (openSymbol == '{' && closeSymbol == '}') ||
               (openSymbol == '[' && closeSymbol == ']');
    }
}
",0.4446620959843291
0_Exercise18_11.java," /**
 * *18.11 (Sum the digits in an integer using recursion) Write a recursive method that
 * computes the sum of the digits in an integer. Use the following method header:
 * public static int sumDigits(long n)
 * For example, sumDigits(234) returns 2 + 3 + 4 = 9.
 * <p>
 * Write a test program that prompts the user to enter an integer and displays its sum.
 * Section 18.5
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_11 {
    static int sum;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter an integer: "");
        long num = in.nextInt();
        System.out.println(""Sum of the digits in "" + num + "" is "" + sumDigits(num));

    }

    public static int sumDigits(long n) {
        if (n == 0) {
            return sum;
        }
        long i = n % 10;
        sum += i;
        n /= 10;
      return sumDigits(n);
    }
}
","public class SumDigits {
    public static int sumDigits(long n) {
        if (n == 0) {
            return 0;
        } else {
            return (int)(n % 10) + sumDigits(n / 10);
        }
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter an integer: "");
        long n = input.nextLong();
        int sum = sumDigits(n);
        System.out.println(""The sum of the digits is "" + sum);
    }
}
",2,"import java.util.Scanner;

// Welcome to the DigitSumCalculator program!

public class DigitSumCalculator {

    public static void main(String[] args) {
        // Prompting the user to enter an integer
        System.out.print(""Enter an integer: "");

        // Creating a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Reading the entered integer
        long number = scanner.nextLong();

        // Calculating and displaying the sum of the digits
        int sum = sumDigits(number);
        System.out.println(""The sum of the digits is: "" + sum);

        // Closing the Scanner
        scanner.close();
    }

    // Recursive method to compute the sum of the digits in an integer
    public static int sumDigits(long n) {
        // Base case: if the number is a single digit, return the number
        if (n < 10) {
            return (int) n;
        } else {
            // Recursive case: sum the last digit and call the method with the remaining digits
            return (int) (n % 10) + sumDigits(n / 10);
        }
    }
}
",0.39545454545454545
0_Exercise18_27.java," /**
 * **18.27 (Koch snowflake fractal) The text presented the Sierpinski triangle fractal.
 * In this exercise, you will write a program to display another fractal, called the Koch
 * snowflake, named after a famous Swedish mathematician. A Koch snowflake is
 * created as follows:
 * 1. Begin with an equilateral triangle, which is considered to be the Koch fractal
 * of order (or level) 0, as shown in Figure 18.14a.
 * 2. Divide each line in the shape into three equal line segments and draw an outward equilateral
 * triangle with the middle line segment as the base to create a
 * Koch fractal of order 1, as shown in Figure 18.14b.
 * 3. Repeat Step 2 to create a Koch fractal of order 2, 3, . . . , and so on, as shown
 * in Figure 18.14c–d.
 * <p>
 * FIGURE 18.14 A Koch snowflake is a fractal starting with a triangle.
 */","package ch_18;

import javafx.application.Application;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Line;
import javafx.stage.Stage;

import java.util.ArrayList;


public class Exercise18_27 extends Application {

    private final double WIDTH = 350;
    private final double HEIGHT = 350;
    private final Label mainLabel = new Label(""Enter an Order"");
    private int orderOfFractal = 0;

    Pane drawPane = new Pane();
    ObservableList<Node> FRACTAL = drawPane.getChildren();

    @Override
    public void start(Stage primaryStage) {
        VBox mainBox = new VBox(5);
        mainBox.setAlignment(Pos.CENTER);
        VBox.setMargin(drawPane,new Insets(15,0,0,0));
        mainBox.getChildren().add(drawPane);

        HBox hBox = new HBox(5);
        hBox.setAlignment(Pos.CENTER);

        TextField inputField = new TextField();
        inputField.setPrefWidth(100);

        hBox.getChildren().addAll(mainLabel, inputField);
        HBox.setMargin(mainLabel, new Insets(5, 5, 10, 10));
        HBox.setMargin(inputField, new Insets(5, 5, 10, 3));
        drawPane.setCenterShape(true);
        drawPane.setPrefHeight(HEIGHT - hBox.getHeight());
        mainBox.getChildren().add(hBox);

        inputField.textProperty().addListener((observable, oldValue, newValue) -> {
            FRACTAL.clear();
            if (!newValue.isEmpty()) {
                orderOfFractal = Integer.parseInt(newValue);
                drawBaseShape(orderOfFractal);
            }
        });

        Scene scene = new Scene(mainBox, WIDTH, HEIGHT);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.show();
    }

    /* Draw the starter Triangle when: order >= 0 */
    private void drawBaseShape(int order) {
        double length = HEIGHT - 100;
        Line l1 = new Line(WIDTH / 2, 0, (WIDTH / 2) + length * Math.cos(1 * (Math.PI * 2 / 6)),
                0 + length * Math.sin(1 * (Math.PI * 2 / 6)));
        Line l2 = new Line(l1.getEndX(), l1.getEndY(), l1.getEndX() - length, l1.getEndY());
        Line l3 = new Line(l2.getEndX(), l2.getEndY(), l1.getStartX(), l1.getStartY());
        FRACTAL.addAll(l1, l2, l3);
        if (order > 0) {
            draw(order);
        }
    }

    private void draw(int order) {
        if (order == 0) // Check Base Case (end recursion)
            return;

        ArrayList<Line> lines = new ArrayList<>();
        for (Node node : FRACTAL) {
            if (node instanceof Line) {
                lines.add((Line) node);
            }
        }

        for (Line line : lines) {
            triangle(line);
        }
        draw(order - 1); // Recurse
    }

    private void triangle(Line line) {
        double DIST = getLength(line) / 3;
        double dy = (line.getStartY() - line.getEndY());
        double dx = (line.getEndX() - line.getStartX());
        double th = Math.atan2(dy, dx);

        double x1 = line.getStartX() + DIST * Math.cos(th);
        double y1 = line.getStartY() - DIST * Math.sin(th);

        double x2 = line.getEndX() + DIST * Math.cos(th + Math.toRadians(180));
        double y2 = line.getEndY() - DIST * Math.sin(th + Math.toRadians(180));

        double x3 = x2 + DIST * Math.cos(th + Math.toRadians(120));
        double y3 = y2 - DIST * Math.sin(th + Math.toRadians(120));

        Line l1 = new Line(line.getStartX(), line.getStartY(), x1, y1);
        Line l2 = new Line(x2, y2, line.getEndX(), line.getEndY());
        Line l3 = new Line(l1.getEndX(), l1.getEndY(), x3, y3);
        Line l4 = new Line(l3.getEndX(), l3.getEndY(), x2, y2);

        drawPane.getChildren().remove(line);
        FRACTAL.addAll(l1, l2, l3, l4);

    }

    private double getLength(Line line) {
        // Use formula for 2D distance to get length of line
        return Math.sqrt(Math.pow(line.getEndX() - line.getStartX(), 2) + Math.pow(line.getEndY() - line.getStartY(),
                2));
    }
}




","import javax.swing.*;
import java.awt.*;
import java.awt.geom.*;

public class KochSnowflake extends JFrame {
    
    public KochSnowflake() {
        setTitle(""Koch Snowflake"");
        setSize(600, 600);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLocationRelativeTo(null);
        setResizable(false);
        getContentPane().setBackground(Color.WHITE);
    }
    
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        int level = 5; // fractal order
        double side = 400.0; // length of triangle side
        double height = Math.sqrt(3.0) / 2.0 * side; // height of triangle
        Point2D.Double p1 = new Point2D.Double(100, 100 + height); // starting point
        Point2D.Double p2 = new Point2D.Double(p1.x + side / 2.0, p1.y - height); // second point
        Point2D.Double p3 = new Point2D.Double(p2.x + side / 2.0, p1.y + height); // third point
        drawKoch(g2d, p1, p2, level); // draw three Koch fractals starting from each side
        drawKoch(g2d, p2, p3, level);
        drawKoch(g2d, p3, p1, level);
    }
    
    private void drawKoch(Graphics2D g2d, Point2D.Double p1, Point2D.Double p2, int level) {
        if (level == 0) { // base case
            g2d.draw(new Line2D.Double(p1, p2));
        } else { // recursive case
            Point2D.Double p3 = getThirdPoint(p1, p2);
            Point2D.Double p4 = getThirdPoint(p2, p1);
            Point2D.Double p5 = getMidPoint(p1, p2);
            drawKoch(g2d, p1, p5, level - 1);
            drawKoch(g2d, p5, p3, level - 1);
            drawKoch(g2d, p3, p4, level - 1);
            drawKoch(g2d, p4, p2, level - 1);
        }
    }
    
    private Point2D.Double getThirdPoint(Point2D.Double p1, Point2D.Double p2) {
        double distance = p1.distance(p2);
        double angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        return new Point2D.Double(p1.x + distance / 3.0 * Math.cos(angle + Math.PI / 3.0),
                p1.y + distance / 3.0 * Math.sin(angle + Math.PI / 3.0));
    }
    
    private Point2D.Double getMidPoint(Point2D.Double p1, Point2D.Double p2) {
        return new Point2D.Double((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);
    }
    
    public static void main(String[] args) {
        KochSnowflake kochSnowflake = new KochSnowflake();
        kochSnowflake.setVisible(true);
    }
",2,"import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.JPanel;

// Welcome to the KochSnowflakeFractalDrawer program!

public class KochSnowflakeFractalDrawer extends JFrame {

    // Constants for the frame dimensions
    private static final int FRAME_WIDTH = 600;
    private static final int FRAME_HEIGHT = 600;

    // Constants for the initial triangle points
    private static final int X1 = 100;
    private static final int Y1 = 500;
    private static final int X2 = 300;
    private static final int Y2 = 100;
    private static final int X3 = 500;
    private static final int Y3 = 500;

    // Current recursion depth
    private int currentDepth;

    // Constructor to set up the frame
    public KochSnowflakeFractalDrawer() {
        setTitle(""Koch Snowflake Fractal"");
        setSize(FRAME_WIDTH, FRAME_HEIGHT);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        currentDepth = 0;
    }

    // Method to draw the Koch snowflake
    public void drawKochSnowflake(Graphics g, int x1, int y1, int x2, int y2, int depth) {
        if (depth == 0) {
            g.drawLine(x1, y1, x2, y2);
        } else {
            int deltaX = x2 - x1;
            int deltaY = y2 - y1;

            int x3 = x1 + deltaX / 3;
            int y3 = y1 + deltaY / 3;

            int x4 = (int) (0.5 * (x1 + x2) + Math.sqrt(3) * (y1 - y2) / 6);
            int y4 = (int) (0.5 * (y1 + y2) + Math.sqrt(3) * (x2 - x1) / 6);

            int x5 = x1 + 2 * deltaX / 3;
            int y5 = y1 + 2 * deltaY / 3;

            drawKochSnowflake(g, x1, y1, x3, y3, depth - 1);
            drawKochSnowflake(g, x3, y3, x4, y4, depth - 1);
            drawKochSnowflake(g, x4, y4, x5, y5, depth - 1);
            drawKochSnowflake(g, x5, y5, x2, y2, depth - 1);
        }
    }

    // Method to paint the component
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        g.setColor(Color.BLACK);

        // Draw the initial equilateral triangle
        drawKochSnowflake(g, X1, Y1, X2, Y2, currentDepth);
        drawKochSnowflake(g, X2, Y2, X3, Y3, currentDepth);
        drawKochSnowflake(g, X3, Y3, X1, Y1, currentDepth);
    }

    // Main method to run the program
    public static void main(String[] args) {
        // Creating the frame
        KochSnowflakeFractalDrawer frame = new KochSnowflakeFractalDrawer();
        frame.setVisible(true);
    }
}
",0.4271936015055281
0_Exercise18_30.java," /**
 * 18.30 (Find words) Write a program that finds all occurrences of a word in all the files
 * under a directory, recursively.
 * Pass the parameters from the command line as follows:
 * <p>
 * java Exercise18_30 dirName word
 * For Example:
 * cmd:>> javac Exercise18_30.java
 * >>>>>> java Exercise18_30 ch_14 static
 */","package ch_18;

import java.io.*;



public class Exercise18_30 {
    static int occurrences = 0;

    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println(""Usage: java Exercise18_30 dirName word"");
            System.exit(0);
        }

        String directory = args[0];
        String word = args[1];
        File dir = new File(directory);

        if (dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null && files.length > 0) {
                try {
                    wordSearch(files, word, 0);
                } catch (IOException ioException) {
                    ioException.printStackTrace();
                }
            }

        } else {
            System.out.println(""Please specify a Directory for 'dirName'. "");
        }
        System.out.println(""The word: \"""" + word + ""\"" occurs "" + occurrences + "" times in: "" + dir.getName());

    }

    static void wordSearch(File[] files, String word, int fileIndex) throws IOException {
        /* Recursion Stopping condition */
        if (files.length == fileIndex) {
            return;
        }

        if (files[fileIndex].isFile()) {
            FileReader fileReader = new FileReader(files[fileIndex]);
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            String line;
            while ((line = bufferedReader.readLine()) != null) {
                if (line.contains(word)) {
                    occurrences++;
                }
            }
        }
        wordSearch(files, word, fileIndex + 1);
    }

}
","import java.io.*;
import java.util.*;

public class FindWords {
    public static void main(String[] args) {
        if (args.length != 2) {
            System.out.println(""Usage: java FindWords directory word"");
            System.exit(1);
        }

        String directory = args[0];
        String word = args[1];

        File dir = new File(directory);
        if (!dir.isDirectory()) {
            System.out.println(directory + "" is not a directory"");
            System.exit(1);
        }

        findWordsInDirectory(dir, word);
    }

    public static void findWordsInDirectory(File dir, String word) {
        File[] files = dir.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                findWordsInDirectory(file, word);
            } else {
                findWordsInFile(file, word);
            }
        }
    }

    public static void findWordsInFile(File file, String word) {
        try (Scanner input = new Scanner(file)) {
            int lineNumber = 0;
            while (input.hasNextLine()) {
                String line = input.nextLine();
                lineNumber++;
                if (line.contains(word)) {
                    System.out.printf(""%s:%d: %s%n"", file.getAbsolutePath(), lineNumber, line);
                }
            }
        } catch (FileNotFoundException e) {
            System.out.println(""File not found: "" + file);
        }
    }
}
",2,"import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.IOException;

// Welcome to the WordFinder program!

public class WordFinder {

    public static void main(String[] args) {
        // Check for the correct number of command line arguments
        if (args.length != 2) {
            System.out.println(""Usage: java WordFinder <directory> <word>"");
            return;
        }

        // Extracting directory and word from command line arguments
        String directoryName = args[0];
        String wordToFind = args[1];

        // Finding and displaying occurrences of the word in files under the directory
        findOccurrences(new File(directoryName), wordToFind);
    }

    // Recursive method to find occurrences of a word in files under a directory
    public static void findOccurrences(File directory, String word) {
        // Checking if the given file is a directory
        if (directory.isDirectory()) {
            File[] files = directory.listFiles();

            // Iterating through files in the directory
            if (files != null) {
                for (File file : files) {
                    // Recursive call for each file or subdirectory
                    findOccurrences(file, word);
                }
            }
        } else {
            // If the given file is a regular file, read its content and find occurrences of the word
            try (BufferedReader reader = new BufferedReader(new FileReader(directory))) {
                String line;
                int lineNumber = 0;

                // Reading lines from the file
                while ((line = reader.readLine()) != null) {
                    lineNumber++;

                    // Checking if the line contains the word
                    if (line.contains(word)) {
                        System.out.println(""File: "" + directory.getAbsolutePath() +
                                "", Line: "" + lineNumber + "", Occurrence: "" + line);
                    }
                }
            } catch (IOException e) {
                System.err.println(""Error reading file: "" + directory.getAbsolutePath());
            }
        }
    }
}
",0.5679455001792757
0_Exercise18_06.java," /**
 * *18.6 (Sum series) Write a recursive method to compute the following series:
 * m(i) = 1/2 + 2/3 + .... + i/i + 1
 * Write a test program that displays m(i) for i = 1, 2, . . ., 10.
 *
 * @author Harry Dulaney
 */","package ch_18;


public class Exercise18_06 {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            System.out.printf(""\nm("" + i + "") = %.4f"", m(i));
        }

    }

    private static double m(int i) {
        double x = 1;
        double sum = x / (x + 1);
        return m(sum, x, i);

    }

    private static double m(double sum, double x, int i) {
        if (x == i) {
            return sum;
        }
        x += 1;
        sum += x / (x + 1);
        return m(sum, x, i);

    }
}
","public class SumSeries {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            double result = sumSeries(i);
            System.out.printf(""m(%d) = %.2f%n"", i, result);
        }
    }

    public static double sumSeries(int i) {
        if (i == 1) {
            return 1.0 / 2.0;
        } else {
            return i / (double)(i + 1) + sumSeries(i - 1);
        }
    }
}
",2,"/**
 * Welcome to the SeriesCalculator program!
 * This program calculates and displays the series m(i) for i = 1, 2, ..., 10.
 * Author: Harry Dulaney
 */

public class SeriesCalculator {

    public static void main(String[] args) {
        // Display the series for i = 1 to 10
        for (int i = 1; i <= 10; i++) {
            double result = computeSeries(i);
            System.out.println(""m("" + i + "") = "" + result);
        }
    }

    // Recursive method to compute the series m(i)
    private static double computeSeries(int i) {
        if (i == 1) {
            return 1.0 / 2;
        } else {
            return i / (i + 1.0) + computeSeries(i - 1);
        }
    }
}
",0.6440306681270537
0_Exercise18_10.java," /**
 * *18.10 (Occurrences of a specified character in a string) Write a recursive method that
 * finds the number of occurrences of a specified letter in a string using the following method header:
 * public static int count(String str, char a)
 * <p>
 * For example, count(""Welcome"", 'e') returns 2.
 * <p>
 * Write a test program that prompts the user to enter a string and a character, and displays the number of
 * occurrences for the character in the string.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_10 {
    static int count;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a String and a character to count it's occurrences:"");
        String str = in.next();
        char ch = in.next().charAt(0);

        System.out.println(""Character "" + ch + "" occurs "" + count(str, ch) + "" times in "" + str);
        in.close();
    }

    public static int count(String str, char a) {
        if (str.length() > 0) {
            if (str.charAt(str.length() - 1) == a) {
                return 1 + count(str.substring(0, str.length() - 1), a);
            } else {
                return count(str.substring(0, str.length() - 1), a);
            }
        }
        return 0;

    }
}
","public class CountOccurrences {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String str = input.nextLine();
        System.out.print(""Enter a character: "");
        char ch = input.next().charAt(0);
        int count = count(str, ch);
        System.out.printf(""The number of occurrences of %c in \""%s\"" is %d%n"", ch, str, count);
    }

    public static int count(String str, char ch) {
        if (str.length() == 0) {
            return 0;
        } else if (str.charAt(0) == ch) {
            return 1 + count(str.substring(1), ch);
        } else {
            return count(str.substring(1), ch);
        }
    }
}
",2,"/**
 * Welcome to the CharacterCounter program!
 * This program counts the occurrences of a specified letter in a string.
 * Author: [Your Name]
 */

import java.util.Scanner;

public class CharacterCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get input from the user
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        System.out.print(""Enter a character to count: "");
        char targetChar = scanner.next().charAt(0);

        // Display the result
        int count = countOccurrences(inputString, targetChar);
        System.out.println(""Occurrences of '"" + targetChar + ""' in the string: "" + count);
    }

    // Recursive method to count occurrences of a specified character in a string
    private static int countOccurrences(String str, char a) {
        if (str.length() == 0) {
            return 0;
        } else {
            int currentCount = (str.charAt(0) == a) ? 1 : 0;
            return currentCount + countOccurrences(str.substring(1), a);
        }
    }
}
",0.6205583756345178
0_Exercise18_21.java," /**
 * 18.21 (Decimal to binary) Write a recursive method that converts a decimal number
 * into a binary number as a string. The method header is:
 * public static String dec2Bin(int value)
 * Write a test program that prompts the user to enter a decimal number and displays its binary equivalent.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_21 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a decimal(base 10) number as an integer: "");
        int decValue = in.nextInt();
        System.out.println(decValue + "" converted to binary is: "" + dec2Bin(decValue));

        in.close();
    }

    public static String dec2Bin(int value) {
        return dec2Bin(value, """");
    }


    static String dec2Bin(int value, String binary) {
        if (value > 0) {
            return dec2Bin(value / 2, (value % 2) + binary);
        }
        return binary;
    }
}
","import java.util.Scanner;

public class DecimalToBinary {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a decimal number: "");
        int decimal = scanner.nextInt();
        String binary = dec2Bin(decimal);
        System.out.printf(""The binary equivalent of %d is %s%n"", decimal, binary);
    }

    public static String dec2Bin(int value) {
        if (value == 0) {
            return ""0"";
        } else if (value == 1) {
            return ""1"";
        } else {
            int quotient = value / 2;
            int remainder = value % 2;
            return dec2Bin(quotient) + remainder;
        }
    }
}
",3,"/**
 * Welcome to the DecimalToBinaryConverter program!
 * This program converts a decimal number to binary.
 * Author: [Your Name]
 */

import java.util.Scanner;

public class DecimalToBinaryConverter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get input from the user
        System.out.print(""Enter a decimal number: "");
        int decimalNumber = scanner.nextInt();

        // Display the result
        String binaryEquivalent = dec2Bin(decimalNumber);
        System.out.println(""Binary equivalent: "" + binaryEquivalent);
    }

    // Recursive method to convert a decimal number to binary
    private static String dec2Bin(int value) {
        if (value == 0) {
            return ""0""; // Base case: when the value is 0, return ""0""
        } else if (value == 1) {
            return ""1""; // Base case: when the value is 1, return ""1""
        } else {
            // Recursive case: concatenate the remainder with the recursive call
            return dec2Bin(value / 2) + value % 2;
        }
    }
}
",0.6631299734748011
0_Exercise18_17.java," /**
 * *18.17 (Occurrences of a specified character in an array) Write a recursive method that
 * finds the number of occurrences of a specified character in an array. You need to
 * define the following two methods. The second one is a recursive helper method.
 * public static int count(char[] chars, char ch)
 * public static int count(char[] chars, char ch, int high)
 * Write a test program that prompts the user to enter a list of characters in one line,
 * and a character, and displays the number of occurrences of the character in the list.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_17 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a list of characters in one line: "");
        String line = in.nextLine();
        char[] chars = line.toCharArray();

        System.out.println(""Enter a single character: "");
        char ch = in.next().charAt(0);
        System.out.println(""The character "" + ch + "" occurs "" + count(chars, ch) + "" times."");
        in.close();
    }

    public static int count(char[] chars, char ch) {
        return count(chars, ch, chars.length - 1);
    }

    public static int count(char[] chars, char ch, int high) {
        if (high > 0) {
            return chars[high] == ch ? (1 + count(chars, ch, high - 1)) : (count(chars, ch, high - 1));
        } else {
            return 0;
        }
    }
}
","import java.util.Scanner;

public class CharacterCount {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a list of characters: "");
        String input = scanner.nextLine();
        char[] chars = input.toCharArray();
        System.out.print(""Enter a character to count: "");
        char ch = scanner.nextLine().charAt(0);
        int count = count(chars, ch);
        System.out.printf(""The character %c occurs %d times in the list.%n"", ch, count);
    }

    public static int count(char[] chars, char ch) {
        return countHelper(chars, ch, chars.length - 1);
    }

    public static int countHelper(char[] chars, char ch, int high) {
        if (high < 0) {
            return 0;
        } else {
            int count = countHelper(chars, ch, high - 1);
            if (chars[high] == ch) {
                count++;
            }
            return count;
        }
    }
}
",3,"/**
 * Welcome to the CharacterArrayCounter program!
 * This program counts the occurrences of a specified character in an array.
 * Author: [Your Name]
 */

import java.util.Scanner;

public class CharacterArrayCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get input from the user
        System.out.print(""Enter a list of characters separated by spaces: "");
        String inputString = scanner.nextLine();
        char[] charArray = inputString.toCharArray();

        System.out.print(""Enter a character to count: "");
        char targetChar = scanner.next().charAt(0);

        // Display the result
        int count = countOccurrences(charArray, targetChar);
        System.out.println(""Occurrences of '"" + targetChar + ""' in the array: "" + count);
    }

    // Method to count occurrences of a specified character in an array
    public static int count(char[] chars, char ch) {
        return count(chars, ch, chars.length - 1);
    }

    // Recursive helper method
    private static int count(char[] chars, char ch, int high) {
        if (high < 0) {
            return 0; // Base case: reached the beginning of the array
        } else {
            int currentCount = (chars[high] == ch) ? 1 : 0;
            return currentCount + count(chars, ch, high - 1);
        }
    }
}
",0.6869695456814778
0_Exercise18_16.java," /**
 * *18.16 (Find the number of uppercase letters in an array) Write a recursive method
 * to return the number of uppercase letters in an array of characters. You need to
 * define the following two methods. The second one is a recursive helper method.
 * public static int count(char[] chars)
 * public static int count(char[] chars, int high)
 * Write a test program that prompts the user to enter a list of characters in one line
 * and displays the number of uppercase letters in the list.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_16 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a list of characters in one line: "");

        String line = in.nextLine();
        char[] chars = line.toCharArray();

        System.out.println(""The number of uppercase letters in the list is: "" + count(chars));
        in.close();
    }

    public static int count(char[] chars) {
        return count(chars, chars.length - 1);
    }

    public static int count(char[] chars, int high) {
        if (high > 0) {
            return Character.isUpperCase(chars[high]) ? (1 + count(chars, high - 1)) : (count(chars, high - 1));
        } else {
            return 0;
        }

    }
}
","import java.util.Scanner;

public class Main {
    
    public static int count(char[] chars) {
        return count(chars, chars.length - 1);
    }
    
    public static int count(char[] chars, int high) {
        if (high < 0) {
            return 0;
        } else {
            int count = count(chars, high - 1);
            if (Character.isUpperCase(chars[high])) {
                count++;
            }
            return count;
        }
    }
    
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print(""Enter a list of characters: "");
        String str = input.nextLine();
        
        char[] chars = str.toCharArray();
        int uppercaseCount = count(chars);
        
        System.out.println(""The number of uppercase letters is "" + uppercaseCount);
    }
}
",3,"/**
 * Welcome to the UppercaseLetterCounter program!
 * This program counts the number of uppercase letters in an array.
 * Author: [Your Name]
 */

import java.util.Scanner;

public class UppercaseLetterCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get input from the user
        System.out.print(""Enter a list of characters separated by spaces: "");
        String inputString = scanner.nextLine();
        char[] charArray = inputString.toCharArray();

        // Display the result
        int count = countUppercaseLetters(charArray);
        System.out.println(""Number of uppercase letters: "" + count);
    }

    // Method to count uppercase letters in an array
    public static int count(char[] chars) {
        return count(chars, chars.length - 1);
    }

    // Recursive helper method
    private static int count(char[] chars, int high) {
        if (high < 0) {
            return 0; // Base case: reached the beginning of the array
        } else {
            int currentCount = Character.isUpperCase(chars[high]) ? 1 : 0;
            return currentCount + count(chars, high - 1);
        }
    }
}
",0.4506713368359603
0_Exercise18_36.java," /**
 * 18.36 (Sierpinski triangle) Write a program that lets the user to enter the order and
 * display the filled Sierpinski triangles as shown in Figure 18.18.
 */ /**
     * The type Sierpinski triangle pane.
     */","package ch_18;

import javafx.application.Application;
import javafx.geometry.Point2D;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Polygon;
import javafx.stage.Stage;


public class Exercise18_36 extends Application {

    private static final double HEIGHT = 220;
    private static final double WIDTH = 200;

    @Override
    public void start(Stage primaryStage) {
        SierpinskiTrianglePane trianglePane = new SierpinskiTrianglePane();
        TextField textField = new TextField();
        textField.setAlignment(Pos.BOTTOM_RIGHT);
        textField.setPrefColumnCount(4);
        textField.setOnAction(
                e -> trianglePane.setOrder(Integer.parseInt(textField.getText())));

        HBox hBox = new HBox(10);
        hBox.getChildren().addAll(new Label(""(Enter) an order: ""), textField);
        hBox.setAlignment(Pos.CENTER);

        BorderPane borderPane = new BorderPane();
        borderPane.setCenter(trianglePane);
        borderPane.setBottom(hBox);

        Scene scene = new Scene(borderPane, WIDTH, HEIGHT);
        primaryStage.setTitle(getClass().getName());
        primaryStage.setScene(scene);
        primaryStage.setResizable(false);
        primaryStage.show();

    }

    
    public static class SierpinskiTrianglePane extends Pane {
        private int order = 0;

        public void setOrder(int order) {
            this.order = order;
            draw();
        }

        SierpinskiTrianglePane() {
        }

        protected void draw() {
            Point2D p1 = new Point2D(getWidth() / 2, 10);
            Point2D p2 = new Point2D(10, getHeight() - 10);
            Point2D p3 = new Point2D(getWidth() - 10, getHeight() - 10);

            this.getChildren().clear();

            showTriangles(order, p1, p2, p3);
        }

        private void showTriangles(int order, Point2D p1,
                                   Point2D p2, Point2D p3) {
            if (order == 0) {
                Polygon triangle = new Polygon();
                triangle.getPoints().addAll(p1.getX(), p1.getY(), p2.getX(),
                        p2.getY(), p3.getX(), p3.getY());

                this.getChildren().add(triangle);
            } else {
                Point2D p12 = p1.midpoint(p2);
                Point2D p23 = p2.midpoint(p3);
                Point2D p31 = p3.midpoint(p1);

                /* Recursively call showTriangles to draw the inner triangles */
                showTriangles(order - 1, p1, p12, p31);
                showTriangles(order - 1, p12, p2, p23);
                showTriangles(order - 1, p31, p23, p3);
            }
        }
    }

}
","import java.util.Scanner;

public class SierpinskiTriangle {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the order of the Sierpinski triangle: "");
        int order = scanner.nextInt();

        // Display the filled Sierpinski triangle
        String[] triangle = sierpinski(order);
        for (String line : triangle) {
            System.out.println(line);
        }
    }

    public static String[] sierpinski(int order) {
        // Base case
        if (order == 0) {
            return new String[] {""*""};
        }
        
        // Recursively generate the smaller triangles
        String[] smaller = sierpinski(order - 1);
        
        // Combine the smaller triangles to form the larger triangle
        int size = smaller.length;
        String[] larger = new String[size * 2];
        for (int i = 0; i < size; i++) {
            StringBuilder sb = new StringBuilder();
            sb.append(smaller[i]).append("" "").append(smaller[i]);
            larger[i] = sb.toString();
        }
        for (int i = 0; i < size; i++) {
            larger[size + i] = smaller[i] + "" "" + smaller[i];
        }
        
        return larger;
    }

}
",3,"/**
 * Welcome to the SierpinskiTriangle program!
 * This program displays filled Sierpinski triangles based on user input.
 * Author: [Your Name]
 */

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

import java.util.Scanner;

public class SierpinskiTriangle extends Application {

    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        Scanner scanner = new Scanner(System.in);

        // Get order from the user
        System.out.print(""Enter the order of the Sierpinski triangle: "");
        int order = scanner.nextInt();

        // Create the SierpinskiTrianglePane
        SierpinskiTrianglePane sierpinskiTrianglePane = new SierpinskiTrianglePane(order);

        // Create a scene and set it in the stage
        Scene scene = new Scene(sierpinskiTrianglePane, 400, 400);
        primaryStage.setTitle(""Sierpinski Triangle"");
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    // SierpinskiTrianglePane class
    private static class SierpinskiTrianglePane extends Pane {
        private int order;

        public SierpinskiTrianglePane(int order) {
            this.order = order;
            setPrefSize(400, 400);
        }

        @Override
        protected void paintComponent() {
            // Get the graphics context
            GraphicsContext graphicsContext = getGraphicsContext2D();

            // Draw Sierpinski triangles
            displayTriangles(graphicsContext, order, getWidth() / 2, getHeight() / 2, getHeight() / 2);
        }

        private void displayTriangles(GraphicsContext gc, int order, double x, double y, double side) {
            // Implementation to draw Sierpinski triangles (left as an exercise)
            // ...
        }
    }
}
",0.44452635458901585
0_Exercise18_23.java," /**
 * 18.23 (Binary to decimal) Write a recursive method that parses a binary number as a
 * string into a decimal integer.
 * The method header is:
 * public static int bin2Dec(String binaryString)
 * <p>
 * Write a test program that prompts the user to enter a binary string and displays
 * its decimal equivalent.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_23 {
    static int pow = 0;
    static int decimal;

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter the binary number to convert to decimal: "");
        String binaryNum = in.next();
        System.out.println(binaryNum + "" binary number is equivalent to the decimal integer: "" + bin2Dec(binaryNum));
        in.close();

    }


    public static int bin2Dec(String binaryString) {
        if (binaryString.length() == 0) {
            return decimal;
        }
        char binaryDigit = binaryString.charAt(binaryString.length() - 1);
        int binaryValue = Integer.parseInt(binaryDigit + """");
        decimal += binaryValue * ((int) Math.pow(2, pow));
        pow += 1;
        return bin2Dec(binaryString.substring(0, binaryString.length() - 1));

    }
}
","public static int bin2Dec(String binaryString) {
    // Base case: the binary string is empty
    if (binaryString.isEmpty()) {
        return 0;
    }
    // Recursive case: compute the decimal value of the rest of the string
    int restValue = bin2Dec(binaryString.substring(1));
    // Multiply by 2 and add the current digit
    int currentValue = binaryString.charAt(0) == '1' ? 1 : 0;
    return currentValue + 2 * restValue;
}
",3,"import java.util.Scanner;

public class BinaryToDecimalConverter {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Binary to Decimal Converter!"");

        // Get the binary string from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a binary string: "");
        String binaryString = scanner.nextLine();

        // Convert binary to decimal
        int decimalValue = bin2Dec(binaryString);

        // Display the result
        System.out.println(""The decimal equivalent of "" + binaryString + "" is: "" + decimalValue);
    }

    // Recursive method to convert binary to decimal
    public static int bin2Dec(String binaryString) {
        // Base case: if the binary string is empty, return 0
        if (binaryString.isEmpty()) {
            return 0;
        }

        // Get the last character of the binary string
        char lastChar = binaryString.charAt(binaryString.length() - 1);

        // Convert the last character to an integer
        int lastDigit = Character.getNumericValue(lastChar);

        // Recursive call to process the rest of the binary string
        int restDecimalValue = bin2Dec(binaryString.substring(0, binaryString.length() - 1));

        // Calculate the decimal value
        return (lastDigit * (int) Math.pow(2, binaryString.length() - 1)) + restDecimalValue;
    }
}
",0.3770392749244713
0_Exercise18_03.java," /**
 * *18.3 (Compute greatest common divisor using recursion) The gcd(m, n) can also
 * be defined recursively as follows:
 * ■ If m % n is 0, gcd(m, n) is n.
 * ■ Otherwise, gcd(m, n) is gcd(n, m % n).
 * Write a recursive method to find the GCD. Write a test program that prompts the
 * user to enter two integers and displays their GCD.
 *
 * @author Harry D.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_03 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        System.out.println(""Enter two integers: "");
        int m = in.nextInt();
        int n = in.nextInt();

        System.out.println(""The GCD of "" + m + "" and "" + n + "" is "" + gcd(m, n));

    }

    static int gcd(int m, int n) {
        if (m % n == 0) {
            return n;
        }
        return gcd(n, m % n);
    }
}
","public static int gcd(int m, int n) {
    if (m % n == 0) {
        return n;
    } else {
        return gcd(n, m % n);
    }
}


import java.util.Scanner;

public class GCDTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the first integer: "");
        int m = input.nextInt();
        System.out.print(""Enter the second integer: "");
        int n = input.nextInt();
        int gcdValue = gcd(m, n);
        System.out.println(""The GCD of "" + m + "" and "" + n + "" is "" + gcdValue);
    }
}
",3,"import java.util.Scanner;

public class RecursiveGCDCalculator {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Greatest Common Divisor (GCD) Calculator!"");

        // Get two integers from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first integer: "");
        int m = scanner.nextInt();
        System.out.print(""Enter the second integer: "");
        int n = scanner.nextInt();

        // Calculate and display the GCD
        int gcdResult = findGCD(m, n);
        System.out.println(""The GCD of "" + m + "" and "" + n + "" is: "" + gcdResult);
    }

    // Recursive method to find the GCD
    public static int findGCD(int m, int n) {
        // Base case: if n is 0, the GCD is m
        if (n == 0) {
            return m;
        }

        // Recursive call to find GCD using Euclidean algorithm
        return findGCD(n, m % n);
    }
}
",0.5552193645990923
0_Exercise18_14.java," /**
 * *18.14 (Find the number of uppercase letters in a string)
 * Write a recursive method to return the number of uppercase letters in a string.
 * <p>
 * Write a test program that prompts the user to enter a string and displays the number of uppercase letters in
 * the string.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_14 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a String: "");
        String s = in.nextLine().trim();
        System.out.println(""The number of uppercase letters in "" + s + "" is: "" + numUpperCase(s, 0, 0));

    }

    static int numUpperCase(String str, int idx, int count) {
        if (idx == str.length()) {
            return count;
        }
        if (Character.isUpperCase(str.charAt(idx))) {
            count++;
        }
        return numUpperCase(str, ++idx, count);
    }
}
","public static int countUpperCase(String str) {
    // Base case: the string is empty
    if (str.isEmpty()) {
        return 0;
    }
    // Recursive case: count the uppercase letters in the rest of the string
    int restCount = countUpperCase(str.substring(1));
    // Add 1 if the first character is uppercase, otherwise add 0
    int currentCount = Character.isUpperCase(str.charAt(0)) ? 1 : 0;
    return currentCount + restCount;
}


import java.util.Scanner;

public class CountUpperCaseTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String str = input.nextLine();
        int count = countUpperCase(str);
        System.out.println(""The number of uppercase letters in the string is "" + count);
    }
}
",4,"import java.util.Scanner;

public class UppercaseCounter {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Uppercase Letter Counter!"");

        // Get a string from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        // Calculate and display the number of uppercase letters
        int uppercaseCount = countUppercaseLetters(inputString);
        System.out.println(""The number of uppercase letters in the string is: "" + uppercaseCount);
    }

    // Recursive method to count uppercase letters in a string
    public static int countUppercaseLetters(String str) {
        // Start with the entire string
        return countUppercaseLettersHelper(str, str.length() - 1);
    }

    // Recursive helper method to count uppercase letters
    public static int countUppercaseLettersHelper(String str, int high) {
        // Base case: if the substring is empty, return 0
        if (high < 0) {
            return 0;
        }

        // Count uppercase letters in the substring and make a recursive call
        int count = Character.isUpperCase(str.charAt(high)) ? 1 : 0;
        return count + countUppercaseLettersHelper(str, high - 1);
    }
}
",0.43935450286309213
0_Exercise18_22.java," /**
 * 18.22 (Decimal to hex) Write a recursive method that converts a decimal number into
 * a hex number as a string. The method header is:
 * public static String dec2Hex(int value)
 * <p>
 * <p>
 * Write a test program that prompts the user to enter a decimal number and displays its hex equivalent
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_22 {
    static String hexValue = """";

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a decimal number to convert to hex: "");
        int number = in.nextInt();

        System.out.println(number + "" is equivalent to hexadecimal number "" + dec2Hex(number));
        in.close();
    }

    public static String dec2Hex(int value) {
        if (value < 16) {
            return getAsHexNumber(value) + hexValue;
        }
        hexValue = getAsHexNumber(value % 16) + hexValue;
        return dec2Hex(value / 16);

    }

    static String getAsHexNumber(int value) {
        switch (value) {
            case 10:
                return ""A"";
            case 11:
                return ""B"";
            case 12:
                return ""C"";
            case 13:
                return ""D"";
            case 14:
                return ""E"";
            case 15:
                return ""F"";
            default:
                return String.valueOf(value);
        }


    }
}
","public static String dec2Hex(int value) {
    if (value < 16) {
        // Base case: the value is less than 16 (one hex digit)
        return hexDigit(value);
    } else {
        // Recursive case: convert the quotient to hex and append the remainder as a hex digit
        int quotient = value / 16;
        int remainder = value % 16;
        return dec2Hex(quotient) + hexDigit(remainder);
    }
}

public static String hexDigit(int value) {
    if (value < 10) {
        return Integer.toString(value);
    } else {
        char c = (char) ('A' + value - 10);
        return Character.toString(c);
    }
}


import java.util.Scanner;

public class Dec2HexTest {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a decimal number: "");
        int value = input.nextInt();
        String hex = dec2Hex(value);
        System.out.println(""The hexadecimal equivalent is "" + hex);
    }
}
",4,"import java.util.Scanner;

public class DecimalToHexConverter {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Decimal to Hex Converter!"");

        // Get the decimal number from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a decimal number: "");
        int decimalNumber = scanner.nextInt();

        // Convert and display the decimal number in hex
        String hexEquivalent = convertToHex(decimalNumber);
        System.out.println(""The hex equivalent of "" + decimalNumber + "" is: "" + hexEquivalent);
    }

    // Recursive method to convert decimal to hex
    public static String convertToHex(int value) {
        // Base case: value is less than 16 (single-digit hex)
        if (value < 16) {
            return Integer.toHexString(value).toUpperCase();
        }

        // Recursive case: convert the quotient and append the remainder
        int quotient = value / 16;
        int remainder = value % 16;

        // Recursive call and concatenation
        return convertToHex(quotient) + Integer.toHexString(remainder).toUpperCase();
    }
}
",0.42498665242925787
0_Exercise18_29.java," /**
 * 18.29 (Number of files in a directory) Write a program that prompts the user to enter a
 * directory and displays the number of the files in the directory.
 */","package ch_18;

import java.io.File;
import java.util.Scanner;


public class Exercise18_29 {

    public static void main(String[] args) {
        System.out.print(""Enter a directory: "");
        Scanner input = new Scanner(System.in);
        String directory = input.nextLine().trim();
        File file = new File(directory);
        if (file.isDirectory()) {
            System.out.println(""The directory: "" + file.getName() + "" contains "" + getFileCount(file) +
                    "" files."");
        } else {
            System.out.println(""Please ensue you are entering a directory."");
        }
    }

    public static long getFileCount(File file) {
        long TOTAL_FILES = 0;
        File[] files = file.listFiles();
        if (files != null && files.length > 0) {
            for (File f : files) {
                if (f.isFile()) {
                    TOTAL_FILES += 1;
                }

            }
        }
        return TOTAL_FILES;
    }
}
","import java.io.File;
import java.util.Scanner;

public class FileCount {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a directory: "");
        String directoryPath = input.nextLine();
        File directory = new File(directoryPath);
        int fileCount = countFiles(directory);
        System.out.println(""The directory "" + directoryPath + "" contains "" + fileCount + "" files."");
    }

    public static int countFiles(File directory) {
        int count = 0;
        File[] files = directory.listFiles();
        if (files != null) {
            // Count the files in the current directory
            for (File file : files) {
                if (file.isFile()) {
                    count++;
                }
            }
            // Recursively count the files in the subdirectories
            for (File subdir : files) {
                if (subdir.isDirectory()) {
                    count += countFiles(subdir);
                }
            }
        }
        return count;
    }
}
",4,"import java.util.Scanner;
import java.io.File;

public class FileCounter {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the File Counter!"");

        // Get user input for the directory path
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the directory path: "");
        String directoryPath = scanner.nextLine();

        // Count and display the number of files in the directory
        int fileCount = countFiles(directoryPath);
        System.out.println(""Number of files in the directory: "" + fileCount);

        // Close the scanner
        scanner.close();
    }

    // Method to count the number of files in a directory
    public static int countFiles(String directoryPath) {
        int count = 0;

        // Create a File object for the specified directory
        File directory = new File(directoryPath);

        // Check if the directory exists
        if (directory.exists() && directory.isDirectory()) {
            // List all files in the directory
            File[] files = directory.listFiles();

            // Count the number of files
            if (files != null) {
                for (File file : files) {
                    if (file.isFile()) {
                        count++;
                    }
                }
            }
        } else {
            System.out.println(""Invalid directory path. Please provide a valid directory path."");
        }

        return count;
    }
}
",0.6132029339853301
0_Exercise18_05.java," /**
 * 18.5 (Sum series) Write a recursive method to compute the following series:
 * m(i) = 1/3 + 2/5 + 3/7 + 4/9 + 5/11 + 6/13 + ...... + i/2i + 1
 * <p>
 * Write a test program that displays m(i) for i = 1, 2, . . ., 10.
 *
 * @author Harry D.
 */","package ch_18;


public class Exercise18_05 {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            System.out.printf(""\nm("" + i + "") = %.4f"", m(i));
        }

    }

    private static double m(int target) {
        int numerator = 1;
        double sum = numerator / ((2.0 * numerator) + 1);
        return m(sum, numerator, target);
    }

    private static double m(double sum, int numerator, int target) {
        if (numerator == target) {
            return sum;
        }
        numerator++;
        sum += numerator / ((2.0 * numerator) + 1);

        return m(sum, numerator, target);
    }
}
","public class Series {
    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            System.out.println(""m("" + i + "") = "" + computeM(i));
        }
    }

    public static double computeM(int i) {
        if (i == 1) {
            return 1.0/3;
        } else {
            return i/(2.0*i + 1) + computeM(i - 1);
        }
    }
}


",4,"import java.util.Scanner;

public class SeriesCalculator {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Series Calculator!"");

        // Get user input for the number of terms in the series
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the number of terms in the series (e.g., 10): "");
        int numberOfTerms = scanner.nextInt();

        // Display the series for the given number of terms
        displaySeries(numberOfTerms);

        // Close the scanner
        scanner.close();
    }

    // Method to display the series
    public static void displaySeries(int numberOfTerms) {
        // Display the series header
        System.out.println(""The series for "" + numberOfTerms + "" terms:"");

        // Initialize the sum
        double sum = 0;

        // Loop to calculate and display each term in the series
        for (int i = 1; i <= numberOfTerms; i++) {
            sum += (double) i / (2 * i + 1);
            System.out.printf(""Term %d: %.4f\n"", i, sum);
        }
    }
}
",0.353322528363047
0_Exercise18_13.java," /**
 * *18.13 (Find the largest number in an array) Write a recursive method that returns the
 * largest integer in an array.
 * <p>
 * Write a test program that prompts the user to enter a list of eight integers and displays the largest element.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_13 {
    static int currIdx = 0;

    public static void main(String[] args) {
        int[] arr = new int[8];
        Scanner in = new Scanner(System.in);
        System.out.println(""Enter a list of eight integers: "");
        for (int i = 0; i < 8; i++) {
            arr[i] = in.nextInt();
        }
        in.close();
        System.out.println(""The largest integer in the list is "" + largestInteger(Integer.MIN_VALUE, arr));


    }

    static int largestInteger(int large, int[] integers) {
        if (currIdx == integers.length) {
            return large;
        }
        large = Math.max(large, integers[currIdx++]);
        return largestInteger(large, integers);
    }
}
","import java.util.Scanner;

public class LargestInteger {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int[] array = new int[8];
        
        System.out.print(""Enter 8 integers: "");
        for (int i = 0; i < 8; i++) {
            array[i] = input.nextInt();
        }
        
        int max = findLargest(array, 0, array.length - 1);
        System.out.println(""The largest integer in the array is: "" + max);
    }
    
    public static int findLargest(int[] array, int left, int right) {
        if (left == right) {
            return array[left];
        } else {
            int mid = (left + right) / 2;
            int maxLeft = findLargest(array, left, mid);
            int maxRight = findLargest(array, mid + 1, right);
            return Math.max(maxLeft, maxRight);
        }
    }
}
",4,"import java.util.Scanner;

public class LargestNumberFinder {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Largest Number Finder!"");

        // Get user input for the list of integers
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[8];
        System.out.println(""Enter eight integers, one at a time:"");

        // Read integers from the user
        for (int i = 0; i < 8; i++) {
            System.out.print(""Enter integer #"" + (i + 1) + "": "");
            numbers[i] = scanner.nextInt();
        }

        // Find and display the largest number
        int largestNumber = findLargestNumber(numbers);
        System.out.println(""The largest number is: "" + largestNumber);

        // Close the scanner
        scanner.close();
    }

    // Recursive method to find the largest number in an array
    public static int findLargestNumber(int[] array) {
        return findLargestNumberHelper(array, 0, array.length - 1);
    }

    // Helper method for recursive search
    private static int findLargestNumberHelper(int[] array, int start, int end) {
        if (start == end) {
            return array[start];
        } else {
            int mid = (start + end) / 2;
            int leftMax = findLargestNumberHelper(array, start, mid);
            int rightMax = findLargestNumberHelper(array, mid + 1, end);
            return Math.max(leftMax, rightMax);
        }
    }
}
",0.5998978027593255
0_Exercise18_25.java," /**
 * *18.25 (String permutation) Write a recursive method to print all the permutations of a
 * string.
 * <p>
 * For example, for the string abc, the permutation is
 * abc
 * acb
 * bac
 * bca
 * cab
 * cba
 * (Hint: Define the following two methods. The second is a helper method.)
 * public static void displayPermutation(String s)
 * public static void displayPermutation(String s1, String s2)
 * <p>
 * The first method simply invokes displayPermutation("" "", s). The second
 * method uses a loop to move a character from s2 to s1 and recursively invokes
 * it with a new s1 and s2. The base case is that s2 is empty and prints s1 to the
 * console.
 * <p>
 * Write a test program that prompts the user to enter a string and displays all its
 * permutations.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_25 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String input = in.next();
        in.close();

        displayPermutation(input);
    }

    public static void displayPermutation(String s) {
        displayPermutation("" "", s);
    }

    public static void displayPermutation(String s1, String s2) {
        if (s2.length() > 0) {
            for (int i = 0; i < s2.length(); i++) {
                String shuffle1 = s1 + s2.charAt(i);
                String shuffle2 = s2.substring(0, i) + s2.substring(i + 1);
                displayPermutation(shuffle1, shuffle2);
            }
        } else {
            System.out.println(s1);
        }
    }
}
","import java.util.Scanner;

public class StringPermutation {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String str = input.nextLine();
        displayPermutation("" "", str);
    }
    
    public static void displayPermutation(String s) {
        displayPermutation("""", s);
    }
    
    public static void displayPermutation(String s1, String s2) {
        if (s2.length() == 0) {
            System.out.println(s1);
        } else {
            for (int i = 0; i < s2.length(); i++) {
                char ch = s2.charAt(i);
                String newS1 = s1 + ch;
                String newS2 = s2.substring(0, i) + s2.substring(i + 1);
                displayPermutation(newS1, newS2);
            }
        }
    }
}
",5,"import java.util.Scanner;

public class StringPermutation {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get user input
        System.out.print(""Enter a string: "");
        String input = scanner.nextLine();

        // Display permutations
        displayPermutation(input);
    }

    public static void displayPermutation(String s) {
        displayPermutation("""", s);
    }

    public static void displayPermutation(String s1, String s2) {
        if (s2.isEmpty()) {
            System.out.println(s1);  // Base case: print the permutation
        } else {
            for (int i = 0; i < s2.length(); i++) {
                // Move a character from s2 to s1
                char selectedChar = s2.charAt(i);
                String newS1 = s1 + selectedChar;
                String newS2 = s2.substring(0, i) + s2.substring(i + 1);

                // Recursively invoke with the new strings
                displayPermutation(newS1, newS2);
            }
        }
    }
}
",0.839622641509434
0_Exercise18_09.java," /**
 * *18.9 (Print the characters in a string reversely)
 * Write a recursive method that displays a string reversely on the console using the following header:
 * public static void reverseDisplay(String value)
 * <p>
 * For example, reverseDisplay(""abcd"") displays dcba. Write a test program
 * that prompts the user to enter a string and displays its reversal.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_09 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter a string to reverse: "");
        String s = in.nextLine().trim();
        reverseDisplay(s);
        in.close();
    }

    public static void reverseDisplay(String value) {
        if (!(value.length() == 0)) {
            System.out.print(value.charAt(value.length() - 1));
            reverseDisplay(value.substring(0, value.length() - 1));
        }

    }
}
","public static void reverseDisplay(String value) {
    if (value == null || value.length() == 0) {
        return;
    } else {
        System.out.print(value.charAt(value.length() - 1));
        reverseDisplay(value.substring(0, value.length() - 1));
    }
}


 import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String input = scanner.nextLine();
        System.out.print(""Reversed string: "");
        reverseDisplay(input);
    }
}
",5,"import java.util.Scanner;

public class ReverseDisplay {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get user input
        System.out.print(""Enter a string: "");
        String input = scanner.nextLine();

        // Display reversal
        reverseDisplay(input);
    }

    public static void reverseDisplay(String value) {
        reverseDisplayHelper(value, value.length() - 1);
    }

    private static void reverseDisplayHelper(String value, int index) {
        if (index >= 0) {
            // Display the character at the current index
            System.out.print(value.charAt(index));

            // Recursively invoke with the decreased index
            reverseDisplayHelper(value, index - 1);
        }
    }
}
",0.46661031276415893
0_Exercise18_08.java," /**
 * *18.8 (Print the digits in an integer reversely) Write a recursive method that displays
 * an int value reversely on the console using the following header:
 * <p>
 * public static void reverseDisplay(int value)
 * For example, reverseDisplay(12345) displays 54321. Write a test program
 * that prompts the user to enter an integer and displays its reversal.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_08 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(""Enter an integer to reverse: "");
        int num = in.nextInt();
        reverseDisplay(num);
        in.close();
    }

    public static void reverseDisplay(int value) {
        if (value > 0) {
            System.out.print(value % 10);
            reverseDisplay(value / 10);
        }

    }
}
","public static void reverseDisplay(int value) {
    if (value < 10) {
        System.out.print(value);
    } else {
        System.out.print(value % 10);
        reverseDisplay(value / 10);
    }
}

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter an integer: "");
        int value = input.nextInt();
        System.out.print(""The reversal is: "");
        reverseDisplay(value);
    }
}
",5,"import java.util.Scanner;

public class ReverseDisplayInt {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get user input
        System.out.print(""Enter an integer: "");
        int inputValue = scanner.nextInt();

        // Display reversal
        reverseDisplay(inputValue);
    }

    public static void reverseDisplay(int value) {
        reverseDisplayHelper(value);
    }

    private static void reverseDisplayHelper(int value) {
        if (value > 0) {
            // Display the last digit of the value
            System.out.print(value % 10);

            // Recursively invoke with the remaining digits
            reverseDisplayHelper(value / 10);
        }
    }
}
",0.4715909090909091
0_Exercise18_24.java," /**
 * *18.24 (Hex to decimal) Write a recursive method that parses a hex number as a string
 * into a decimal integer.
 * <p>
 * The method header is:
 * public static int hex2Dec(String hexString)
 * Write a test program that prompts the user to enter a hex string and displays its
 * decimal equivalent.
 */","package ch_18;

import java.util.Scanner;


public class Exercise18_24 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a hex number: "");
        String hex = input.nextLine();
        System.out.println(hex + "" is decimal "" + hex2Dec(hex));
    }

    public static long hex2Dec(String hexString) {
        return hex2Dec(hexString, 0, hexString.length() - 1);
    }

    public static long hex2Dec(String hexString, int low, int high) {
        if (high < low)
            return 0;
        else {
            return hex2Dec(hexString, low, high - 1) * 16
                    + hexCharToDecimal(hexString.charAt(high));
        }
    }

    public static long hexCharToDecimal(char ch) {
        if ('A' <= ch && ch <= 'F')
            return 10 + ch - 'A';
        else
            return ch - '0';
    }
}
","public static int hex2Dec(String hexString) {
    if (hexString.length() == 0) {
        return 0;
    } else {
        int lastDigit = hexCharToDecimal(hexString.charAt(hexString.length() - 1));
        String remaining = hexString.substring(0, hexString.length() - 1);
        return hex2Dec(remaining) * 16 + lastDigit;
    }
}

public static int hexCharToDecimal(char ch) {
    if (ch >= '0' && ch <= '9') {
        return ch - '0';
    } else if (ch >= 'A' && ch <= 'F') {
        return ch - 'A' + 10;
    } else if (ch >= 'a' && ch <= 'f') {
        return ch - 'a' + 10;
    } else {
        throw new IllegalArgumentException(""Invalid hex digit: "" + ch);
    }
}

import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter a hex string: "");
        String hexString = input.nextLine();
        int decimal = hex2Dec(hexString);
        System.out.println(""The decimal equivalent is: "" + decimal);
    }
}

",5,"import java.util.Scanner;

public class HexToDecimalConverter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Get user input
        System.out.print(""Enter a hex string: "");
        String hexString = scanner.nextLine();

        // Display decimal equivalent
        int decimalValue = hex2Dec(hexString);
        System.out.println(""Decimal equivalent: "" + decimalValue);
    }

    public static int hex2Dec(String hexString) {
        return hex2DecHelper(hexString, hexString.length() - 1);
    }

    private static int hex2DecHelper(String hexString, int high) {
        if (high < 0) {
            return 0;
        } else {
            char hexChar = hexString.charAt(hexString.length() - 1 - high);
            int decimalValue = hexCharToDecimal(hexChar);
            return decimalValue * (int) Math.pow(16, high) + hex2DecHelper(hexString, high - 1);
        }
    }

    private static int hexCharToDecimal(char ch) {
        if (ch >= 'A' && ch <= 'F') {
            return 10 + ch - 'A';
        } else if (ch >= '0' && ch <= '9') {
            return ch - '0';
        } else {
            return 0; // Handle invalid characters gracefully
        }
    }
}
",0.43115007735946365
0_Exercise18_04.java," /**
 * 18.4 (Sum series) Write a recursive method to compute the following series:
 * m(i) = 1 + 1/2 + 1/3 +.... + 1/i
 * Write a test program that displays m(i) for i = 1, 2, . . ., 10.
 *
 * @author Harry Dulaney
 */","package ch_18;


public class Exercise18_04 {

    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            System.out.printf(""\nm("" + i + "") = %.4f"", m(i));
        }

    }

   private static double m(int target) {
        double sum = 1;
        int denominator = 1;
        return m(sum, denominator, target);
    }

   private static double m(double sum, int denominator, int target) {
        if (denominator == target) {
            return sum;
        }
        sum += 1.0 / ++denominator;
        return m(sum, denominator, target);
    }
}
","public class Series {

    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            System.out.printf(""m(%d) = %.2f%n"", i, computeSeries(i));
        }
    }

    public static double computeSeries(int i) {
        if (i == 1) {
            return 1.0;
        } else {
            return computeSeries(i - 1) + 1.0 / i;
        }
    }
}
",5,"public class SumSeries {

    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            double result = computeSeries(i);
            System.out.println(""m("" + i + "") = "" + result);
        }
    }

    public static double computeSeries(int i) {
        if (i == 1) {
            return 1;
        } else {
            double currentTerm = 1.0 / i;
            return currentTerm + computeSeries(i - 1);
        }
    }
}
",0.7926267281105991
0_Exercise18_31.java," /**
 * 18.31 (Replace words) Write a program that replaces all occurrences of a word with a
 * new word in all the files under a directory, recursively. Pass the parameters from
 * the command line as follows:
 * <p>
 * java Exercise18_31 dirName oldWord newWord
 * <p>
 * Example cmd:
 * javac Exercise18_31.java
 * java Exercise18_31 ch_18/exercise18_31/TestDirectory the bologna
 */","package ch_18.exercise18_31;

import java.io.*;
import java.util.List;
import java.util.stream.Collectors;


public class Exercise18_31 {
    public static void main(String[] args) {
        if (args.length < 2) {
            System.err.println(""Usage: java Exercise18_30 dirName word"");
            System.exit(0);
        }

        String directory = args[0];
        String oldWord = args[1];
        String newWord = args[2];

        File dir = new File(directory);

        if (dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null && files.length > 0) {
                try {
                    replaceWords(files, oldWord, newWord, 0);
                } catch (IOException ioException) {
                    ioException.printStackTrace();
                }
            }

        } else {
            System.out.println(""Please specify a Directory for 'dirName'. "");
        }
        System.out.println(""The word: \"""" + oldWord + ""\"" has been replaced with \"""" + newWord + ""\"" for files in "" +
                ""directory: "" + dir.getName());

    }

    static void replaceWords(File[] files, String oldWord, String newWord, int fileIndex) throws IOException {
        if (files.length == fileIndex) {
            return;
        }
        runReplace(oldWord, newWord, files[fileIndex]);
        replaceWords(files, oldWord, newWord, fileIndex + 1); // Recurse
    }

    /* Method to perform replacement logic */
    static void runReplace(String oldWord, String newWord, File file) throws IOException {
        if (file.isFile()) {
            FileReader fileReader = new FileReader(file);
            BufferedReader bufferedReader = new BufferedReader(fileReader);
            List<String> resultList = bufferedReader.lines()
                    .map(s -> s.replace(oldWord, newWord))
                    .collect(Collectors.toList());

            bufferedReader.close();
            FileWriter fileWriter = new FileWriter(file);
            BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
            for (String line : resultList) {
                bufferedWriter.write(line);
                bufferedWriter.newLine();
            }
            bufferedWriter.close();
        }

    }

}
","import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class Exercise18_31 {

    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println(""Usage: java Exercise18_31 dirName oldWord newWord"");
            System.exit(1);
        }

        String dirName = args[0];
        String oldWord = args[1];
        String newWord = args[2];

        replaceWordsInFiles(dirName, oldWord, newWord);
    }

    public static void replaceWordsInFiles(String dirName, String oldWord, String newWord) {
        File directory = new File(dirName);
        if (!directory.exists() || !directory.isDirectory()) {
            System.out.println(""Invalid directory: "" + dirName);
            return;
        }

        File[] files = directory.listFiles();
        for (File file : files) {
            if (file.isDirectory()) {
                replaceWordsInFiles(file.getAbsolutePath(), oldWord, newWord);
            } else {
                replaceWordsInFile(file, oldWord, newWord);
            }
        }
    }

    public static void replaceWordsInFile(File file, String oldWord, String newWord) {
        try {
            Path path = Paths.get(file.getAbsolutePath());
            String content = new String(Files.readAllBytes(path));
            String newContent = content.replaceAll(oldWord, newWord);
            Files.write(path, newContent.getBytes());
        } catch (IOException e) {
            System.out.println(""Error replacing words in file: "" + file.getAbsolutePath());
        }
    }

}
",1,"import java.io.File;
import java.io.IOException;
import java.nio.file.*;
import java.util.Scanner;

public class Exercise18_31 {

    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println(""Usage: java Exercise18_31 dirName oldWord newWord"");
            System.exit(1);
        }

        String directoryName = args[0];
        String oldWord = args[1];
        String newWord = args[2];

        replaceWordsInFiles(directoryName, oldWord, newWord);

        System.out.println(""Word replacement complete."");
    }

    public static void replaceWordsInFiles(String directoryName, String oldWord, String newWord) {
        File directory = new File(directoryName);

        if (!directory.isDirectory()) {
            System.out.println(""Invalid directory: "" + directoryName);
            System.exit(1);
        }

        replaceWordsInDirectory(directory, oldWord, newWord);
    }

    private static void replaceWordsInDirectory(File directory, String oldWord, String newWord) {
        File[] files = directory.listFiles();

        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    replaceWordsInDirectory(file, oldWord, newWord);
                } else {
                    replaceWordsInFile(file, oldWord, newWord);
                }
            }
        }
    }

    private static void replaceWordsInFile(File file, String oldWord, String newWord) {
        try {
            Path path = Paths.get(file.getPath());
            String content = new String(Files.readAllBytes(path));
            content = content.replaceAll(oldWord, newWord);
            Files.write(path, content.getBytes());
        } catch (IOException e) {
            System.out.println(""Error processing file: "" + file.getName());
        }
    }
}
",0.8466386554621849
0_Exercise05_48.java," /**
 * *5.48 (Process string)
 * Write a program that prompts the user to enter a string and displays the characters at odd positions.
 * Here is a sample run:
 * Enter a string: Beijing Chicago
 * BiigCiao
 *
 * By: Harry Dulaney
 */","package ch_05;

import java.util.*;


public class Exercise05_48 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String res = """";

        System.out.print(""Enter a string: "");
        String userStr = in.nextLine();
        userStr = ""h"" + userStr; //Account for the weird interpretation of 'odd positions' [ie(index 0 is position 1)]

        for (int i = 0; i < userStr.length(); i++) {
            if (Character.isLetter(userStr.charAt(i))) {
                switch (i % 2) {
                    case 0:
                        break;
                    default:
                        res += userStr.charAt(i);
                        break;
                }
            }
        }
        in.close();
        System.out.println(res);
    }
}","import java.util.Scanner;

public class Exercise4_25 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String str = input.nextLine();

        for (int i = 0; i < str.length(); i += 2) {
            System.out.print(str.charAt(i));
        }

        System.out.println();
    }
}
",2,"import java.util.Scanner;

public class StringProcessor {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        processAndDisplayString(inputString);

        System.out.println(""\nBy: Harry Dulaney"");
    }

    public static void processAndDisplayString(String inputString) {
        System.out.print(""Processed string: "");

        for (int i = 0; i < inputString.length(); i++) {
            // Display characters at odd positions (1-based index)
            if (i % 2 == 0) {
                System.out.print(inputString.charAt(i));
            }
        }
    }
}
",0.6088840736728061
0_Exercise05_09.java," /**
 * 5.9 (Find the two highest scores) Write a program that prompts
 * the user to enter the number of students and each student�s name
 * and score, and finally displays the student with the highest score
 * and the student with the second-highest score. Use the next() method
 * in the Scanner class to read a name rather using the nextLine() method.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_09 {
    public static void main(String[] args) {

        double highScore = 0, secondHigh = 0;

        String highName = """";
        String secondName = """";
        String tempName = """";
        double tempScore = 0;

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the number of students: "");

        int numStudents = input.nextInt();

        System.out.print(""Enter a students name: "");
        highName = input.next();

        System.out.print(""Enter the students score: "");
        highScore = input.nextDouble();

        while (numStudents > 1) {
            System.out.print(""Enter a students name: "");
            tempName = input.next();

            System.out.print(""Enter the students score: "");
            tempScore = input.nextDouble();

            if (tempScore > highScore) {
                secondHigh = highScore;
                secondName = highName;
                highScore = tempScore;
                highName = tempName;
                numStudents--;
                continue;
            }

            if (tempScore < highScore && tempScore > secondHigh) {
                secondHigh = tempScore;
                secondName = tempName;
            }
            numStudents--;

        }
        System.out.println(""The top two students are: "");
        System.out.print(highName + ""'s score of "" + highScore);
        System.out.print("" and "" + secondName + ""'s score of "" + secondHigh);
    }

}
","import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // prompt the user to enter the number of students
        System.out.print(""Enter the number of students: "");
        int numStudents = input.nextInt();

        // initialize variables to keep track of highest and second-highest scores and their corresponding names
        String highestName = """";
        int highestScore = Integer.MIN_VALUE;
        String secondHighestName = """";
        int secondHighestScore = Integer.MIN_VALUE;

        // loop through each student and update highest and second-highest scores if necessary
        for (int i = 0; i < numStudents; i++) {
            // prompt the user to enter the student's name and score
            System.out.print(""Enter the name and score of student "" + (i + 1) + "": "");
            String name = input.next();
            int score = input.nextInt();

            // update highest and second-highest scores if necessary
            if (score > highestScore) {
                secondHighestName = highestName;
                secondHighestScore = highestScore;
                highestName = name;
                highestScore = score;
            } else if (score > secondHighestScore) {
                secondHighestName = name;
                secondHighestScore = score;
            }
        }

        // display the student with the highest score and the student with the second-highest score
        System.out.println(""Student with the highest score: "" + highestName + "" ("" + highestScore + "")"");
        System.out.println(""Student with the second-highest score: "" + secondHighestName + "" ("" + secondHighestScore + "")"");
    }
}
",3,"import java.util.Scanner;

public class TopTwoStudents {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print(""Enter the number of students: "");
        int numStudents = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character

        String topStudent = """";
        double topScore = Double.MIN_VALUE;
        String secondTopStudent = """";
        double secondTopScore = Double.MIN_VALUE;

        for (int i = 1; i <= numStudents; i++) {
            System.out.print(""Enter student "" + i + ""'s name: "");
            String studentName = scanner.next();

            System.out.print(""Enter student "" + i + ""'s score: "");
            double studentScore = scanner.nextDouble();

            if (studentScore > topScore) {
                secondTopScore = topScore;
                secondTopStudent = topStudent;
                topScore = studentScore;
                topStudent = studentName;
            } else if (studentScore > secondTopScore) {
                secondTopScore = studentScore;
                secondTopStudent = studentName;
            }
        }

        System.out.println(""Top student: "" + topStudent + "" with score "" + topScore);
        System.out.println(""Second top student: "" + secondTopStudent + "" with score "" + secondTopScore);
    }
}
",0.5918446601941748
0_Exercise05_25.java," /**
 * **5.25 (Compute p) You can approximate pi by using the following series:
 * pi = 4¢1 - 1 3 + 15 - 1 7 + 1 9 - 11 1 + g + (2-i 1) -i +11 ≤
 * Write a program that displays the p value for i = 10000, 20000, …, and
 * 100000.
 */","package ch_05;

import java.util.*;


public class Exercise05_25 {
    public static void main(String[] args) {

        double pi = 1.0;
        for (int i = 2; i <= 100000; i++) {

            pi += Math.pow(-1, i + 1) / (2 * i - 1.0d);
            if (i % 10000 == 0) {
                System.out.println(""For value of i = "" + i + "" -> PI =  "" + (4.0 * pi));
            }
        }
    }
}","public class Main {
    public static void main(String[] args) {
        for (int i = 10000; i <= 100000; i += 10000) {
            double pi = 0;
            for (int j = 0; j < i; j++) {
                int sign = j % 2 == 0 ? 1 : -1;
                double term = sign * (1.0 / (2 * j + 1));
                pi += term;
            }
            pi *= 4;
            System.out.println(""pi for i = "" + i + "": "" + pi);
        }
    }
}
",4,"public class PiApproximation {

    public static void main(String[] args) {
        int terms = 10000;
        double piApproximation = 0;

        for (int i = 1; i <= terms; i++) {
            double term = 4.0 * (1 - (i % 2) * 2) / (2 * i - 1);
            piApproximation += term;
        }

        System.out.println(""Approximation of pi for "" + terms + "" terms: "" + piApproximation);
    }
}
",0.676829268292683
0_Exercise05_33.java," /**
 * **5.33 (Perfect number) A positive integer is called a perfect number if it is equal to
 * the sum of all of its positive divisors, excluding itself. For example, 6 is the first
 * perfect number because 6 = 3 + 2 + 1. The next is 28 = 14 + 7 + 4 + 2
 * + 1. There are four perfect numbers less than 10,000. Write a program to find all
 * these four numbers
 */","package ch_05;

import java.util.*;


public class Exercise05_33 {
    public static void main(String[] args) {
        for (int number = 6; number <= 10000; number++) {
            int total = 0;
            int divisor = number - 1;

            while (divisor > 0) {

                if (number % divisor == 0) {
                    total += divisor;
                }
                divisor--;
            }

            if (number == total) {
                System.out.println(number);
            }

        }
    }
}","public class Main {
    public static void main(String[] args) {
        for (int i = 1; i < 10000; i++) {
            if (isPerfect(i)) {
                System.out.println(i + "" is a perfect number."");
            }
        }
    }

    public static boolean isPerfect(int num) {
        int sum = 0;
        for (int i = 1; i < num; i++) {
            if (num % i == 0) {
                sum += i;
            }
        }
        return sum == num;
    }
}
",5,"public class PerfectNumbers {

    public static void main(String[] args) {
        int limit = 10000;

        System.out.println(""Perfect numbers less than "" + limit + "":"");
        for (int number = 2; number < limit; number++) {
            if (isPerfectNumber(number)) {
                System.out.println(number);
            }
        }
    }

    // Check if a number is a perfect number
    private static boolean isPerfectNumber(int number) {
        int sum = 1; // 1 is always a divisor

        for (int divisor = 2; divisor <= number / 2; divisor++) {
            if (number % divisor == 0) {
                sum += divisor;
            }
        }

        return sum == number;
    }
}
",0.6659167604049494
0_Exercise05_27.java," /**
 * **5.28 (Display the first days of each month) Write a program that prompts the user to
 * enter the year and first day of the year, and displays the first day of each month
 * in the year. For example, if the user entered the year 2013, and 2 for Tuesday,
 * January 1, 2013, your program should display the following output:
 * January 1, 2013 is Tuesday
 * ...
 * December 1, 2013 is Sunday
 */","package ch_05;

import java.util.*;


public class Exercise05_27 {
    public static void main(String[] args) {

        int i = 1;
        for (int year = 2001; year <= 2100; year++) {

            if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
                System.out.print(year + "" "");
                if (i % 10 == 0) {
                    System.out.println();
                }
                i++;
            }

        }
    }
}","import java.util.Scanner;

public class FirstDayOfMonth {
    public static void main(String[] args) {
        // Prompt the user to enter the year and first day of the year
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the year: "");
        int year = input.nextInt();
        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, etc.): "");
        int firstDay = input.nextInt();

        // Define a list of month names and the number of days in each month
        String[] monthNames = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
        int[] daysInMonth = {31, 28 + (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        // Display the first day of each month in the year
        for (int i = 0; i < 12; i++) {
            // Determine the first day of the current month
            int firstDayOfMonth = (firstDay + ((i == 0) ? 0 : daysInMonth[i - 1])) % 7;

            // Display the first day of the current month
            System.out.printf(""%s 1, %d is %s\n"", monthNames[i], year, getDayName(firstDayOfMonth));

            // Update the first day for the next month
            firstDay = firstDayOfMonth;
        }
    }

    // Returns the name of a day given its number (0 = Sunday, 1 = Monday, etc.)
    private static String getDayName(int day) {
        String[] dayNames = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
        return dayNames[day];
    }
}",1,"import java.util.Scanner;

public class MonthDaysDisplay {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Get the year from the user
        System.out.print(""Enter the year (e.g., 2013): "");
        int year = input.nextInt();

        // Get the first day of the year from the user
        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, ..., 6 for Saturday): "");
        int firstDay = input.nextInt();

        // Display the header
        System.out.println(""Month\t\tFirst Day"");

        // Loop through each month
        for (int month = 1; month <= 12; month++) {
            // Get the first day of the current month
            int dayOfWeek = (firstDay + getTotalDays(year, month - 1)) % 7;

            // Display the result
            System.out.print(getMonthName(month) + "" 1, "" + year + "" is "");
            displayDayOfWeek(dayOfWeek);

            // Set firstDay for the next month
            firstDay = (dayOfWeek + getMonthDays(year, month - 1)) % 7;
        }

        input.close();
    }

    // Function to get the name of the month
    private static String getMonthName(int month) {
        String[] monthNames = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"",
                               ""August"", ""September"", ""October"", ""November"", ""December""};
        return monthNames[month - 1];
    }

    // Function to get the total number of days from 1800 to the specified month
    private static int getTotalDays(int year, int month) {
        int totalDays = 0;
        for (int i = 1800; i < year; i++) {
            if (isLeapYear(i)) {
                totalDays += 366;
            } else {
                totalDays += 365;
            }
        }

        for (int i = 1; i < month; i++) {
            totalDays += getMonthDays(year, i - 1);
        }

        return totalDays;
    }

    // Function to get the number of days in a month
    private static int getMonthDays(int year, int month) {
        if (month == 1) {
            return isLeapYear(year) ? 29 : 28;
        } else {
            int[] daysInMonth = {31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
            return daysInMonth[month];
        }
    }

    // Function to check if a year is a leap year
    private static boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }

    // Function to display the day of the week
    private static void displayDayOfWeek(int dayOfWeek) {
        String[] dayNames = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
        System.out.println(dayNames[dayOfWeek]);
    }
}",0.5359370762137239
0_Exercise05_07.java," /**
 * *5.7 (Financial application: compute future tuition) Suppose that the tuition for
 * a university is $10,000 this year and increases 5% every year. In one year, the tuition
 * will be $10,500. Write a program that computes the tuition in ten years and the
 * total cost of four years’ worth of tuition after the tenth year.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_07 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double highScore = 0;
        String studentName = "" "";

        System.out.print(""Enter the number of students: "");
        int numberOfstudents = input.nextInt();

        System.out.print(""Enter a student name: "");
        studentName = input.next();

        System.out.print(""Enter the students score: "");
        highScore = input.nextDouble();

        String tempName = """";
        double tempScore = 0;

        while (numberOfstudents > 1) {

            System.out.print(""Enter a student name: "");
            tempName = input.next();

            System.out.print(""Enter the students score: "");
            tempScore = input.nextDouble();

            if (tempScore > highScore)
                highScore = tempScore;
            studentName = tempName;


            numberOfstudents--;
        }
        System.out.println(""Top student "" + studentName + ""'s score is "" + highScore);
    }

}
","public class TuitionCalculator {
    public static void main(String[] args) {
        double tuition = 10000.0; // Initial tuition is $10,000
        double totalCost = 0.0;

        // Compute the tuition for each of the next ten years
        for (int i = 1; i <= 10; i++) {
            tuition *= 1.05; // Increase tuition by 5%
            if (i > 4) {
                totalCost += tuition; // Add tuition to the total cost for years 5-10
            }
        }

        // Display the tuition in ten years and the total cost of four years' worth of tuition
        System.out.printf(""The tuition in ten years is $%.2f\n"", tuition);
        System.out.printf(""The total cost of four years' worth of tuition after the tenth year is $%.2f\n"", totalCost);
    }
}",1,"import java.util.Scanner;

public class TuitionCalculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Constants
        final double INITIAL_TUITION = 10000.0; // Initial tuition for the first year
        final double ANNUAL_INCREASE_PERCENTAGE = 5.0; // Annual increase percentage

        // User prompt
        System.out.println(""Welcome to Tuition Calculator!"");
        System.out.println(""Let's predict the future tuition costs..."");

        // Calculate tuition for ten years
        double tuition = INITIAL_TUITION;
        for (int year = 1; year <= 10; year++) {
            tuition = tuition + (tuition * ANNUAL_INCREASE_PERCENTAGE / 100);
        }

        // Display the tuition after ten years
        System.out.println(""The tuition after ten years will be: $"" + tuition);

        // Calculate the total cost of four years' worth of tuition after the tenth year
        double totalCost = 0;
        for (int i = 1; i <= 4; i++) {
            tuition = tuition + (tuition * ANNUAL_INCREASE_PERCENTAGE / 100);
            totalCost = totalCost + tuition;
        }

        // Display the total cost after the tenth year
        System.out.println(""The total cost of four years' worth of tuition after the tenth year will be: $"" + totalCost);

        // Close the scanner
        input.close();
    }
}",0.5239892183288409
0_Exercise05_50.java," /**
 * 5.50 (Count uppercase letters) Write a program that prompts
 * the user to enter a string and displays the number of the upper-case
 * letters in the string.
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_50 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a string with some uppercase letters: "");

        String toBeevaluated = input.nextLine();
        int numberOfuppercase = 0;
        int x = 0;

        while (x < toBeevaluated.length()) {

            if (Character.isUpperCase(toBeevaluated.charAt(x))) {
                numberOfuppercase++;
            }
            x++;
        }

        System.out.println(""The number of upper case letters is: "" + numberOfuppercase);

    }

}
","import java.util.Scanner;

public class CountUpperCase {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        int upperCaseCount = 0;
        for (int i = 0; i < inputString.length(); i++) {
            if (Character.isUpperCase(inputString.charAt(i))) {
                upperCaseCount++;
            }
        }

        System.out.println(""Number of upper-case letters: "" + upperCaseCount);
    }
}",1,"import java.util.Scanner;

// Class definition
public class UppercaseCounterProgram {

    // Main method
    public static void main(String[] args) {
        // Create a Scanner object to get input from the user
        Scanner scanner = new Scanner(System.in);

        // Display a welcoming message
        System.out.println(""Welcome to the Uppercase Letter Counter Program!"");

        // Prompt the user to enter a string
        System.out.print(""Please enter a string: "");
        
        // Read the user input as a string
        String userString = scanner.nextLine();

        // Close the scanner to prevent resource leak
        scanner.close();

        // Count the number of uppercase letters in the string
        int uppercaseCount = countUppercaseLetters(userString);

        // Display the result
        System.out.println(""The number of uppercase letters in the entered string is: "" + uppercaseCount);

        // Display a friendly goodbye message
        System.out.println(""Thank you for using the Uppercase Letter Counter Program! Have a great day!"");
    }

    // Function to count uppercase letters in a string
    private static int countUppercaseLetters(String inputString) {
        int count = 0;

        // Loop through each character in the string
        for (int i = 0; i < inputString.length(); i++) {
            // Check if the character is an uppercase letter
            if (Character.isUpperCase(inputString.charAt(i))) {
                count++;
            }
        }

        // Return the count of uppercase letters
        return count;
    }
}",0.43726027397260275
0_Exercise05_46.java," /**
 * 5.46 (Reverse a string) Write a program that prompts
 * the user to enter a string and displays the string in reverse order.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_46 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String str = input.nextLine();

        for (int i = str.length() - 1; i >= 0; i--) {

            System.out.print(str.charAt(i));

        }

    }

}
","import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        String reversedString = """";
        for (int i = inputString.length() - 1; i >= 0; i--) {
            reversedString += inputString.charAt(i);
        }

        System.out.println(""Reversed string: "" + reversedString);
    }
}",1,"import java.util.Scanner; // Importing the Scanner class for user input

// Class definition
public class StringReverser {

    // Main method
    public static void main(String[] args) {
        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Display a welcoming message
        System.out.println(""Welcome to the String Reverser Program!"");

        // Prompt the user to enter a string
        System.out.print(""Please enter a string: "");
        
        // Read the user's string input
        String userString = scanner.nextLine();

        // Close the scanner to prevent potential issues
        scanner.close();

        // Reverse the string
        String reversedString = reverseString(userString);

        // Display the result
        System.out.println(""The reversed string is: "" + reversedString);

        // Display a friendly goodbye message
        System.out.println(""Thank you for using the String Reverser Program! Have a wonderful day!"");
    }

    // Function to reverse a string
    private static String reverseString(String inputString) {
        // Convert the string to a character array
        char[] charArray = inputString.toCharArray();

        // Initialize a StringBuilder to store the reversed string
        StringBuilder reversedStringBuilder = new StringBuilder();

        // Loop through the character array in reverse order
        for (int i = charArray.length - 1; i >= 0; i--) {
            // Append each character to the StringBuilder
            reversedStringBuilder.append(charArray[i]);
        }

        // Convert the StringBuilder back to a string and return it
        return reversedStringBuilder.toString();
    }
}",0.3877656817003629
0_Exercise05_11.java," /**
 * 5.11 (Find numbers divisible by 5 or 6, but not both) Write a program
 * that displays all the numbers from 100 to 200, ten per line, that are
 * divisible by 5 or 6, but not both. Numbers are separated by exactly one
 * space.
 */","package ch_05;


public class Exercise05_11 {
    public static void main(String[] args) {

        int count = 0;

        for (int i = 100; i <= 200; i++) {

            if (count == 10) {
                System.out.println();
                count = 0;
            }

            if (i % 5 == 0 ^ i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
            }


        }
    }
}
","public class DivisibleByFiveOrSix {
    public static void main(String[] args) {
        final int NUMS_PER_LINE = 10;
        int count = 0;

        for (int i = 100; i <= 200; i++) {
            if ((i % 5 == 0 || i % 6 == 0) && !(i % 5 == 0 && i % 6 == 0)) {
                System.out.print(i + "" "");
                count++;

                if (count == NUMS_PER_LINE) {
                    System.out.println();
                    count = 0;
                }
            }
        }
    }
}",1,"// Importing necessary classes for Scanner and formatting
import java.util.Scanner;

// Definition of the class
public class DivisibleNumbersFinder {

    // Main method
    public static void main(String[] args) {
        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Greet the user
        System.out.println(""Welcome to the Divisible Numbers Finder!"");

        // Prompt the user to press Enter to start the program
        System.out.print(""Press Enter to find the numbers..."");
        scanner.nextLine(); // Pause for dramatic effect

        // Display numbers from 100 to 200 that are divisible by 5 or 6, but not both
        int count = 0; // Counter for the numbers displayed per line

        // Loop through numbers from 100 to 200 (inclusive)
        for (int number = 100; number <= 200; number++) {
            // Check if the number is divisible by 5 or 6, but not both
            if ((number % 5 == 0 || number % 6 == 0) && !(number % 5 == 0 && number % 6 == 0)) {
                // Display the number with a space separator
                System.out.print(number + "" "");
                count++;

                // Move to the next line after displaying 10 numbers
                if (count == 10) {
                    System.out.println(); // Start a new line
                    count = 0; // Reset the counter
                }
            }
        }

        // Display a friendly goodbye message
        System.out.println(""\nThank you for using the Divisible Numbers Finder! Have a great day!"");
        
        // Close the scanner to prevent potential issues
        scanner.close();
    }
}",0.3526708788052843
0_Exercise05_10.java," /**
 * 5.10 (Find numbers divisible by 5 and 6) Write a program that displays
 * all the numbers from 100 to 1,000, ten per line, that are divisible by
 * 5 and 6. Numbers are separated by exactly one space.
 */","package ch_05;


public class Exercise05_10 {
    public static void main(String[] args) {

        final int startNum = 100;
        final int endNum = 1000;

        int count = 0;
        for (int i = startNum; i <= endNum; i++) {

            if (i % 6 == 0 && i % 5 == 0) {
                System.out.print(i + "" "");
                count++;

                if (count == 10) {
                    System.out.println();
                    count = 0;
                }

            }

        }

    }
}
","public class DivisibleBy5And6 {
    public static void main(String[] args) {
        final int LOWER_LIMIT = 100;
        final int UPPER_LIMIT = 1000;
        final int NUMBERS_PER_LINE = 10;

        int count = 0;
        for (int i = LOWER_LIMIT; i <= UPPER_LIMIT; i++) {
            if (i % 5 == 0 && i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
                if (count % NUMBERS_PER_LINE == 0) {
                    System.out.println();
                }
            }
        }
    }
}",1,"import java.util.Scanner;

public class LongestCommonPrefix {
    public static void main(String[] args) {
        // Create a Scanner object for user input
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter the first string
        System.out.print(""Enter the first string: "");
        String firstString = input.nextLine();

        // Prompt the user to enter the second string
        System.out.print(""Enter the second string: "");
        String secondString = input.nextLine();

        // Call the method to find the longest common prefix
        String commonPrefix = findCommonPrefix(firstString, secondString);

        // Display the result
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is "" + commonPrefix);
        } else {
            System.out.println(firstString + "" and "" + secondString + "" have no common prefix"");
        }

        // Close the scanner
        input.close();
    }

    // Method to find the longest common prefix
    public static String findCommonPrefix(String str1, String str2) {
        int minLength = Math.min(str1.length(), str2.length());
        String prefix = """";

        for (int i = 0; i < minLength; i++) {
            if (str1.charAt(i) == str2.charAt(i)) {
                prefix += str1.charAt(i);
            } else {
                break;
            }
        }

        return prefix;
    }
}",0.3033779477374124
0_Exercise05_47.java," /**
 * *5.47 (Business: check ISBN-13) ISBN-13 is a new standard for identifying books. It
 * uses 13 digits d1d2d3d4d5d6d7d8d9d10d11d12d13. The last digit d13 is a checksum,
 * which is calculated from the other digits using the following formula:
 * 10 - (d1 + 3d2 + d3 + 3d4 + d5 + 3d6 + d7 + 3d8 + d9 + 3d10 + d11 + 3d12)%10
 * If the checksum is 10, replace it with 0. Your program should read the input as a
 * string.
 * <p>
 * <strong>Here are sample runs:</strong>
 * <p>
 * {@code Enter the first 12 digits of an ISBN-13 as a string: 978013213080
 * The ISBN-13 number is 9780132130806
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 978013213079
 * The ISBN-13 number is 9780132130790
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 97801320
 * 97801320 is an invalid input}
 */","package ch_05;

import java.util.*;


public class Exercise05_47 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String isbn = in.nextLine();

        // Verify string length
        if (isbn.length() != 12) {
            System.out.println(""Invalid input "" + isbn + "" input MUST be exactly 12 numbers"");
            System.exit(0);
        }

        int check = 0;
        for (int i = 0; i < isbn.length(); i++) {
            int value = Integer.parseInt(String.valueOf(isbn.charAt(i)));
            check += i % 2 == 0 ? 3 * value
                    : value;
        }
        check = 10 - check % 10;
        
        System.out.println(""ISBN-13 number is "" + isbn +
                (check == 10 ? 0 : check));

        in.close();
    }
}","import java.util.Scanner;

public class ISBNChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first 12 digits of the ISBN-13: "");
        String input = scanner.nextLine();
        
        // Convert input to integer array
        int[] digits = new int[12];
        for (int i = 0; i < 12; i++) {
            digits[i] = Character.getNumericValue(input.charAt(i));
        }
        
        // Calculate checksum
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            if (i % 2 == 0) {
                sum += digits[i];
            } else {
                sum += digits[i] * 3;
            }
        }
        int checksum = 10 - (sum % 10);
        if (checksum == 10) {
            checksum = 0;
        }
        
        // Output complete ISBN-13
        System.out.println(""The complete ISBN-13 is: "" + input + checksum);
    }
}",1,"import java.util.Scanner;

// Class definition
public class ISBNChecker {

    // Main method
    public static void main(String[] args) {
        // Display a welcoming message
        System.out.println(""Welcome to the ISBN-13 Checker Program!"");

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first 12 digits of an ISBN-13 as a string
        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String input = scanner.nextLine();

        // Close the scanner to prevent resource leak
        scanner.close();

        // Check if the input has exactly 12 digits
        if (input.length() == 12) {
            // Calculate the checksum
            int checksum = calculateChecksum(input);

            // Display the ISBN-13 number
            System.out.println(""The ISBN-13 number is "" + input + checksum);
        } else {
            // Display an error message for invalid input
            System.out.println(input + "" is an invalid input. Please enter exactly 12 digits."");
        }

        // Display a friendly goodbye message
        System.out.println(""Thank you for using the ISBN-13 Checker Program! Have a nice day!"");
    }

    // Function to calculate the checksum for ISBN-13
    private static int calculateChecksum(String input) {
        int sum = 0;

        // Loop through each digit in the input
        for (int i = 0; i < input.length(); i++) {
            int digit = Character.getNumericValue(input.charAt(i));

            // Apply the formula to calculate the checksum
            if (i % 2 == 0) {
                sum += digit;
            } else {
                sum += 3 * digit;
            }
        }

        // Calculate the checksum based on the formula
        int checksum = 10 - (sum % 10);

        // If the checksum is 10, replace it with 0
        if (checksum == 10) {
            checksum = 0;
        }

        // Return the calculated checksum
        return checksum;
    }
}",0.4797687861271676
0_Exercise05_51.java," /**
 * *5.51 (Longest common prefix) Write a program that prompts the user to enter two
 * strings and displays the largest common prefix of the two strings. Here are some
 * sample runs:
 * Enter the first string: Welcome to C++
 * Enter the second string: Welcome to programming
 * The common prefix is Welcome to
 * Enter the first string: Atlanta
 * Enter the second string: Macon
 * Atlanta and Macon have no common prefix
 *
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_51 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println(""Enter string one: "");
        String str1 = input.nextLine();

        final int lengthOne = str1.length();
        System.out.println(""Enter string two: "");

        String str2 = input.nextLine();
        final int lengthTwo = str2.length();

        if (str1.charAt(0) != str2.charAt(0)) {

            System.out.println(str1 + "" and "" + str2 + "" have :(. ---> no common prefix <---"");

        } else {
            int indexOfLCP = 0;
            for (int i = 0; i < (Math.max(lengthOne, lengthTwo)); i++) {

                if (str1.charAt(i) == str2.charAt(i)) {
                    indexOfLCP = i;
                } else {
                    break;
                }
            }
            System.out.print(""The common prefix is: "" + str1.substring(0, indexOfLCP + 1));

        }

        input.close();
    }

}
","import java.util.Scanner;

public class CommonPrefix {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first string: "");
        String str1 = scanner.nextLine();
        System.out.print(""Enter the second string: "");
        String str2 = scanner.nextLine();
        
        // Find length of common prefix
        int len = Math.min(str1.length(), str2.length());
        int i;
        for (i = 0; i < len; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                break;
            }
        }
        
        // Output common prefix
        String commonPrefix = str1.substring(0, i);
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is: "" + commonPrefix);
        } else {
            System.out.println(""There is no common prefix."");
        }
    }
}",1,"// Importing the Scanner class for user input
import java.util.Scanner;

// Class definition
public class CommonPrefixFinder {

    // Main method
    public static void main(String[] args) {
        // Display a welcoming message
        System.out.println(""Welcome to the Common Prefix Finder!"");

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first string
        System.out.print(""Enter the first string: "");
        String firstString = scanner.nextLine();

        // Prompt the user to enter the second string
        System.out.print(""Enter the second string: "");
        String secondString = scanner.nextLine();

        // Close the scanner to prevent resource leak
        scanner.close();

        // Find the common prefix
        String commonPrefix = findCommonPrefix(firstString, secondString);

        // Display the result
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is "" + commonPrefix);
        } else {
            System.out.println(firstString + "" and "" + secondString + "" have no common prefix"");
        }

        // Display a friendly goodbye message
        System.out.println(""Thank you for using the Common Prefix Finder! Have a great day!"");
    }

    // Function to find the common prefix of two strings
    private static String findCommonPrefix(String str1, String str2) {
        StringBuilder commonPrefix = new StringBuilder();
        int minLength = Math.min(str1.length(), str2.length());

        // Loop through each character in the strings
        for (int i = 0; i < minLength; i++) {
            // Check if the characters are the same
            if (str1.charAt(i) == str2.charAt(i)) {
                // Append the character to the common prefix
                commonPrefix.append(str1.charAt(i));
            } else {
                // Break the loop if characters are different
                break;
            }
        }

        // Return the common prefix as a string
        return commonPrefix.toString();
    }
}",0.47584830339321355
0_Exercise05_26.java," /**
 * **5.26 (Compute e) You can approximate e using the following series:
 * e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ... + 1/i!
 * Write a program that displays the e value for i = 10000, 20000, …, and
 * 100000. (Hint: Because i! = i * (i - 1) * c * 2 * 1, then
 * 1 i!
 * is
 * 1
 * i(i - 1)!
 * Initialize e and item to be 1 and keep adding a new item to e. The new item is
 * the previous item divided by i for i = 2, 3, 4, ....)
 */","package ch_05;

import java.util.*;


public class Exercise05_26 {
    static double e;

    public static void main(String[] args) {
        double e = 1;
        int item = 10000;
        while (item <= 100000) {
            double denominator = 0;
            for (double i = 1; i <= item; i++) {
                denominator += i * (i - 1);
            }
            e += 1 / denominator;
            System.out.println(""e is "" + e + "" when i is "" + item);
            item += 10000;
        }
    }
}

","import java.math.BigDecimal;

public class ApproximateE {
    public static void main(String[] args) {
        int[] iValues = {10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000};
        for (int i : iValues) {
            BigDecimal sum = BigDecimal.ONE;
            BigDecimal factorial = BigDecimal.ONE;
            for (int j = 1; j <= i; j++) {
                factorial = factorial.multiply(BigDecimal.valueOf(j));
                sum = sum.add(BigDecimal.ONE.divide(factorial));
            }
            System.out.println(""e for i = "" + i + "" is: "" + sum);
        }
    }
}",1,"// Class definition
public class ApproximateE {

    // Main method
    public static void main(String[] args) {
        // Display a welcoming message
        System.out.println(""Welcome to the e Approximator Program!"");

        // Initialize the variables e and item to 1
        double e = 1.0;
        double item = 1.0;

        // Loop through values of i from 10000 to 100000 in steps of 10000
        for (int i = 10000; i <= 100000; i += 10000) {
            // Display the current iteration
            System.out.println(""For i = "" + i + "":"");

            // Loop to calculate the approximation using the given series
            for (int j = 1; j <= i; j++) {
                item = item / j; // Calculate the new item

                // Add the new item to e
                e += item;
            }

            // Display the result for the current iteration
            System.out.println(""Approximated e: "" + e);

            // Reset the variables for the next iteration
            e = 1.0;
            item = 1.0;
        }

        // Display a friendly goodbye message
        System.out.println(""Thank you for using the e Approximator Program! Have a fantastic day!"");
    }
}",0.38904109589041097
0_Exercise05_30.java," /**
 * 5.30 (Financial application: compound value) Suppose you save $100
 * each month into a savings account with the annual interest rate 5%.
 * So, the monthly interest rate is 0.05 / 12 = 0.00417. After the first
 * month, the value in the account becomes.
 * Write a program that prompts the user to enter an amount (e.g., 100)
 * the annual interest rate (e.g., 5), and the number of months (e.g., 6)
 * and displays the amount in the savings account after the given month.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_30 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the amount you would like to invest each month: "");

        double investment = input.nextDouble();

        System.out.print(""Enter the annual interest rate(e.g. 5,10,20): "");

        double interestRate = input.nextDouble();

        interestRate = interestRate / 100;

        System.out.println(""Enter the number of months: "");

        int numberOfMonths = input.nextInt();

        double total = 0;

        for (int i = 1; i <= numberOfMonths; i++) {


            total = (investment + total) * (1 + (interestRate / 12));

        }


        System.out.println(""After the "" + numberOfMonths + ""th month, "" + ""the account value is "" + total);


    }

}
","import java.util.Scanner;

public class SavingsAccount {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Get input from user
        System.out.print(""Enter the initial amount: $"");
        double amount = scanner.nextDouble();
        System.out.print(""Enter the annual interest rate (as a percentage): "");
        double annualRate = scanner.nextDouble();
        System.out.print(""Enter the number of months: "");
        int months = scanner.nextInt();
        
        // Compute monthly interest rate
        double monthlyRate = annualRate / 1200.0;  // 12 months in a year, 100 to convert percentage to decimal
        
        // Compute balance after specified number of months
        for (int i = 1; i <= months; i++) {
            amount = amount + (100 * monthlyRate) + 100;  // add monthly deposit and interest
        }
        
        // Output balance
        System.out.printf(""The balance after %d months is: $%.2f"", months, amount);
    }
}",1,"// Importing Scanner for user input
import java.util.Scanner;

// Class definition
public class CompoundValueCalculator {

    // Main method
    public static void main(String[] args) {
        // Display a welcoming message
        System.out.println(""Welcome to the Compound Value Calculator!"");

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the monthly savings amount
        System.out.print(""Enter the monthly savings amount (e.g., 100): "");
        double monthlySavings = scanner.nextDouble();

        // Prompt the user to enter the annual interest rate
        System.out.print(""Enter the annual interest rate (e.g., 5): "");
        double annualInterestRate = scanner.nextDouble();

        // Prompt the user to enter the number of months
        System.out.print(""Enter the number of months (e.g., 6): "");
        int numberOfMonths = scanner.nextInt();

        // Close the scanner to prevent resource leak
        scanner.close();

        // Calculate the monthly interest rate
        double monthlyInterestRate = annualInterestRate / 1200;

        // Initialize the total amount in the savings account
        double totalAmount = 0;

        // Loop through each month to calculate the compound value
        for (int i = 0; i < numberOfMonths; i++) {
            // Calculate the compound value after the current month
            totalAmount = (totalAmount + monthlySavings) * (1 + monthlyInterestRate);
        }

        // Display the result
        System.out.println(""The amount in the savings account after "" + numberOfMonths + "" months is: $"" + totalAmount);

        // Display a friendly goodbye message
        System.out.println(""Thank you for using the Compound Value Calculator! Have a wonderful day!"");
    }
}",0.5665201757890531
0_Exercise05_27.java," /**
 * **5.28 (Display the first days of each month) Write a program that prompts the user to
 * enter the year and first day of the year, and displays the first day of each month
 * in the year. For example, if the user entered the year 2013, and 2 for Tuesday,
 * January 1, 2013, your program should display the following output:
 * January 1, 2013 is Tuesday
 * ...
 * December 1, 2013 is Sunday
 */","package ch_05;

import java.util.*;


public class Exercise05_27 {
    public static void main(String[] args) {

        int i = 1;
        for (int year = 2001; year <= 2100; year++) {

            if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
                System.out.print(year + "" "");
                if (i % 10 == 0) {
                    System.out.println();
                }
                i++;
            }

        }
    }
}","import java.util.Scanner;

public class FirstDayOfMonth {
    public static void main(String[] args) {
        // Prompt the user to enter the year and first day of the year
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the year: "");
        int year = input.nextInt();
        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, etc.): "");
        int firstDay = input.nextInt();

        // Define a list of month names and the number of days in each month
        String[] monthNames = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
        int[] daysInMonth = {31, 28 + (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        // Display the first day of each month in the year
        for (int i = 0; i < 12; i++) {
            // Determine the first day of the current month
            int firstDayOfMonth = (firstDay + ((i == 0) ? 0 : daysInMonth[i - 1])) % 7;

            // Display the first day of the current month
            System.out.printf(""%s 1, %d is %s\n"", monthNames[i], year, getDayName(firstDayOfMonth));

            // Update the first day for the next month
            firstDay = firstDayOfMonth;
        }
    }

    // Returns the name of a day given its number (0 = Sunday, 1 = Monday, etc.)
    private static String getDayName(int day) {
        String[] dayNames = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
        return dayNames[day];
    }
}",2,"import java.util.Scanner;

public class DisplayFirstDaysOfMonth {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the year (e.g., 2013): "");
        int year = input.nextInt();

        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, ..., 6 for Saturday): "");
        int firstDay = input.nextInt();

        String[] months = {
            ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
            ""July"", ""August"", ""September"", ""October"", ""November"", ""December""
        };

        int[] daysInMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        System.out.println(""\n"" + ""Here are the first days of each month in "" + year + "":\n"");

        for (int month = 0; month < months.length; month++) {
            System.out.print(months[month] + "" 1, "" + year + "" is "");
            printDay(firstDay);
            
            int numberOfDays = daysInMonth[month];
            firstDay = (firstDay + numberOfDays) % 7;
        }

        input.close();
    }

    public static void printDay(int day) {
        switch (day) {
            case 0:
                System.out.println(""Sunday"");
                break;
            case 1:
                System.out.println(""Monday"");
                break;
            case 2:
                System.out.println(""Tuesday"");
                break;
            case 3:
                System.out.println(""Wednesday"");
                break;
            case 4:
                System.out.println(""Thursday"");
                break;
            case 5:
                System.out.println(""Friday"");
                break;
            case 6:
                System.out.println(""Saturday"");
                break;
            default:
                System.out.println(""Invalid day"");
        }
    }
}",0.6170818505338078
0_Exercise05_07.java," /**
 * *5.7 (Financial application: compute future tuition) Suppose that the tuition for
 * a university is $10,000 this year and increases 5% every year. In one year, the tuition
 * will be $10,500. Write a program that computes the tuition in ten years and the
 * total cost of four years’ worth of tuition after the tenth year.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_07 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double highScore = 0;
        String studentName = "" "";

        System.out.print(""Enter the number of students: "");
        int numberOfstudents = input.nextInt();

        System.out.print(""Enter a student name: "");
        studentName = input.next();

        System.out.print(""Enter the students score: "");
        highScore = input.nextDouble();

        String tempName = """";
        double tempScore = 0;

        while (numberOfstudents > 1) {

            System.out.print(""Enter a student name: "");
            tempName = input.next();

            System.out.print(""Enter the students score: "");
            tempScore = input.nextDouble();

            if (tempScore > highScore)
                highScore = tempScore;
            studentName = tempName;


            numberOfstudents--;
        }
        System.out.println(""Top student "" + studentName + ""'s score is "" + highScore);
    }

}
","public class TuitionCalculator {
    public static void main(String[] args) {
        double tuition = 10000.0; // Initial tuition is $10,000
        double totalCost = 0.0;

        // Compute the tuition for each of the next ten years
        for (int i = 1; i <= 10; i++) {
            tuition *= 1.05; // Increase tuition by 5%
            if (i > 4) {
                totalCost += tuition; // Add tuition to the total cost for years 5-10
            }
        }

        // Display the tuition in ten years and the total cost of four years' worth of tuition
        System.out.printf(""The tuition in ten years is $%.2f\n"", tuition);
        System.out.printf(""The total cost of four years' worth of tuition after the tenth year is $%.2f\n"", totalCost);
    }
}",2,"import java.util.Scanner;

public class TuitionCalculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        double initialTuition = 10000; // Initial tuition amount
        double tuitionIncreaseRate = 0.05; // Tuition increase rate

        System.out.println(""Calculating future tuition..."");

        // Calculate tuition for ten years
        double futureTuition = initialTuition;
        for (int year = 1; year <= 10; year++) {
            futureTuition = futureTuition + (futureTuition * tuitionIncreaseRate);
        }

        System.out.println(""The tuition in ten years will be: $"" + futureTuition);

        // Calculate total cost of four years' worth of tuition after the tenth year
        double totalCost = 0;
        for (int i = 1; i <= 4; i++) {
            totalCost = totalCost + (futureTuition * i);
        }

        System.out.println(""The total cost of four years' worth of tuition after the tenth year will be: $"" + totalCost);

        input.close();
    }
}",0.6048593350383632
0_Exercise05_50.java," /**
 * 5.50 (Count uppercase letters) Write a program that prompts
 * the user to enter a string and displays the number of the upper-case
 * letters in the string.
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_50 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a string with some uppercase letters: "");

        String toBeevaluated = input.nextLine();
        int numberOfuppercase = 0;
        int x = 0;

        while (x < toBeevaluated.length()) {

            if (Character.isUpperCase(toBeevaluated.charAt(x))) {
                numberOfuppercase++;
            }
            x++;
        }

        System.out.println(""The number of upper case letters is: "" + numberOfuppercase);

    }

}
","import java.util.Scanner;

public class CountUpperCase {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        int upperCaseCount = 0;
        for (int i = 0; i < inputString.length(); i++) {
            if (Character.isUpperCase(inputString.charAt(i))) {
                upperCaseCount++;
            }
        }

        System.out.println(""Number of upper-case letters: "" + upperCaseCount);
    }
}",2,"import java.util.Scanner;

public class UppercaseLetterCounterProgramByHarryDulaney {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println(""Welcome to the Uppercase Letter Counter Program!"");
        System.out.print(""Please enter a string: "");

        String inputString = scanner.nextLine();
        int uppercaseCount = 0;

        for (int i = 0; i < inputString.length(); i++) {
            char currentChar = inputString.charAt(i);

            if (Character.isUpperCase(currentChar)) {
                uppercaseCount = uppercaseCount + 1; // Increment uppercase count
            }
        }

        System.out.println(""The number of uppercase letters in the string is: "" + uppercaseCount);

        scanner.close();
    }
}",0.7491228070175439
0_Exercise05_46.java," /**
 * 5.46 (Reverse a string) Write a program that prompts
 * the user to enter a string and displays the string in reverse order.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_46 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String str = input.nextLine();

        for (int i = str.length() - 1; i >= 0; i--) {

            System.out.print(str.charAt(i));

        }

    }

}
","import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        String reversedString = """";
        for (int i = inputString.length() - 1; i >= 0; i--) {
            reversedString += inputString.charAt(i);
        }

        System.out.println(""Reversed string: "" + reversedString);
    }
}",2,"import java.util.Scanner;

public class ReverseStringProgram {
    public static void main(String[] args) {
        Scanner userInputScanner = new Scanner(System.in);

        System.out.println(""Welcome to the String Reverser Program!"");
        System.out.print(""Please enter a string: "");

        String inputString = userInputScanner.nextLine();
        char[] characters = inputString.toCharArray();

        System.out.print(""The reversed string is: "");
        for (int i = characters.length - 1; i >= 0; i--) {
            System.out.print(characters[i]);
        }

        System.out.println(); // Adding a new line for better output appearance

        userInputScanner.close();
    }
}",0.6893865628042843
0_Exercise05_11.java," /**
 * 5.11 (Find numbers divisible by 5 or 6, but not both) Write a program
 * that displays all the numbers from 100 to 200, ten per line, that are
 * divisible by 5 or 6, but not both. Numbers are separated by exactly one
 * space.
 */","package ch_05;


public class Exercise05_11 {
    public static void main(String[] args) {

        int count = 0;

        for (int i = 100; i <= 200; i++) {

            if (count == 10) {
                System.out.println();
                count = 0;
            }

            if (i % 5 == 0 ^ i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
            }


        }
    }
}
","public class DivisibleByFiveOrSix {
    public static void main(String[] args) {
        final int NUMS_PER_LINE = 10;
        int count = 0;

        for (int i = 100; i <= 200; i++) {
            if ((i % 5 == 0 || i % 6 == 0) && !(i % 5 == 0 && i % 6 == 0)) {
                System.out.print(i + "" "");
                count++;

                if (count == NUMS_PER_LINE) {
                    System.out.println();
                    count = 0;
                }
            }
        }
    }
}",2,"public class DivisibleNumbersFinder {
    public static void main(String[] args) {
        System.out.println(""Numbers divisible by 5 or 6, but not both, from 100 to 200:"");

        int count = 0; // Counter for line break after every ten numbers

        for (int number = 100; number <= 200; number++) {
            if ((number % 5 == 0 || number % 6 == 0) && !(number % 5 == 0 && number % 6 == 0)) {
                System.out.print(number + "" ""); // Print the number

                count++; // Increment the counter

                if (count == 10) {
                    System.out.println(); // Line break after every ten numbers
                    count = 0; // Reset the counter
                }
            }
        }
    }
}",0.648068669527897
0_Exercise05_10.java," /**
 * 5.10 (Find numbers divisible by 5 and 6) Write a program that displays
 * all the numbers from 100 to 1,000, ten per line, that are divisible by
 * 5 and 6. Numbers are separated by exactly one space.
 */","package ch_05;


public class Exercise05_10 {
    public static void main(String[] args) {

        final int startNum = 100;
        final int endNum = 1000;

        int count = 0;
        for (int i = startNum; i <= endNum; i++) {

            if (i % 6 == 0 && i % 5 == 0) {
                System.out.print(i + "" "");
                count++;

                if (count == 10) {
                    System.out.println();
                    count = 0;
                }

            }

        }

    }
}
","public class DivisibleBy5And6 {
    public static void main(String[] args) {
        final int LOWER_LIMIT = 100;
        final int UPPER_LIMIT = 1000;
        final int NUMBERS_PER_LINE = 10;

        int count = 0;
        for (int i = LOWER_LIMIT; i <= UPPER_LIMIT; i++) {
            if (i % 5 == 0 && i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
                if (count % NUMBERS_PER_LINE == 0) {
                    System.out.println();
                }
            }
        }
    }
}",2,"public class DivisibleNumbersFinder {
    public static void main(String[] args) {
        // Problem 5.11
        System.out.println(""Numbers divisible by 5 or 6, but not both, from 100 to 200:"");

        int count1 = 0; // Counter for line break after every ten numbers

        for (int number1 = 100; number1 <= 200; number1++) {
            if ((number1 % 5 == 0 || number1 % 6 == 0) && !(number1 % 5 == 0 && number1 % 6 == 0)) {
                System.out.print(number1 + "" ""); // Print the number

                count1++; // Increment the counter

                if (count1 == 10) {
                    System.out.println(); // Line break after every ten numbers
                    count1 = 0; // Reset the counter
                }
            }
        }

        System.out.println(); // Separate the output of two problems

        // Problem 5.10
        System.out.println(""Numbers divisible by 5 and 6 from 100 to 1000:"");

        int count2 = 0; // Counter for line break after every ten numbers

        for (int number2 = 100; number2 <= 1000; number2++) {
            if (number2 % 5 == 0 && number2 % 6 == 0) {
                System.out.print(number2 + "" ""); // Print the number

                count2++; // Increment the counter

                if (count2 == 10) {
                    System.out.println(); // Line break after every ten numbers
                    count2 = 0; // Reset the counter
                }
            }
        }
    }
}",0.37890625
0_Exercise05_47.java," /**
 * *5.47 (Business: check ISBN-13) ISBN-13 is a new standard for identifying books. It
 * uses 13 digits d1d2d3d4d5d6d7d8d9d10d11d12d13. The last digit d13 is a checksum,
 * which is calculated from the other digits using the following formula:
 * 10 - (d1 + 3d2 + d3 + 3d4 + d5 + 3d6 + d7 + 3d8 + d9 + 3d10 + d11 + 3d12)%10
 * If the checksum is 10, replace it with 0. Your program should read the input as a
 * string.
 * <p>
 * <strong>Here are sample runs:</strong>
 * <p>
 * {@code Enter the first 12 digits of an ISBN-13 as a string: 978013213080
 * The ISBN-13 number is 9780132130806
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 978013213079
 * The ISBN-13 number is 9780132130790
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 97801320
 * 97801320 is an invalid input}
 */","package ch_05;

import java.util.*;


public class Exercise05_47 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String isbn = in.nextLine();

        // Verify string length
        if (isbn.length() != 12) {
            System.out.println(""Invalid input "" + isbn + "" input MUST be exactly 12 numbers"");
            System.exit(0);
        }

        int check = 0;
        for (int i = 0; i < isbn.length(); i++) {
            int value = Integer.parseInt(String.valueOf(isbn.charAt(i)));
            check += i % 2 == 0 ? 3 * value
                    : value;
        }
        check = 10 - check % 10;
        
        System.out.println(""ISBN-13 number is "" + isbn +
                (check == 10 ? 0 : check));

        in.close();
    }
}","import java.util.Scanner;

public class ISBNChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first 12 digits of the ISBN-13: "");
        String input = scanner.nextLine();
        
        // Convert input to integer array
        int[] digits = new int[12];
        for (int i = 0; i < 12; i++) {
            digits[i] = Character.getNumericValue(input.charAt(i));
        }
        
        // Calculate checksum
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            if (i % 2 == 0) {
                sum += digits[i];
            } else {
                sum += digits[i] * 3;
            }
        }
        int checksum = 10 - (sum % 10);
        if (checksum == 10) {
            checksum = 0;
        }
        
        // Output complete ISBN-13
        System.out.println(""The complete ISBN-13 is: "" + input + checksum);
    }
}",2,"import java.util.Scanner;

public class ISBN13Checker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println(""Welcome to the ISBN-13 Checker!"");

        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String input = scanner.nextLine();

        if (input.length() != 12) {
            System.out.println(input + "" is an invalid input"");
        } else {
            int checksum = calculateChecksum(input);

            String isbn13 = input + checksum;

            System.out.println(""The ISBN-13 number is "" + isbn13);
        }

        scanner.close();
    }

    private static int calculateChecksum(String input) {
        int sum = 0;
        for (int i = 0; i < input.length(); i++) {
            int digit = Character.getNumericValue(input.charAt(i));
            if (i % 2 == 0) {
                sum += digit;
            } else {
                sum += 3 * digit;
            }
        }

        int checksum = 10 - (sum % 10);
        if (checksum == 10) {
            checksum = 0;
        }

        return checksum;
    }
}",0.6588669950738916
0_Exercise05_51.java," /**
 * *5.51 (Longest common prefix) Write a program that prompts the user to enter two
 * strings and displays the largest common prefix of the two strings. Here are some
 * sample runs:
 * Enter the first string: Welcome to C++
 * Enter the second string: Welcome to programming
 * The common prefix is Welcome to
 * Enter the first string: Atlanta
 * Enter the second string: Macon
 * Atlanta and Macon have no common prefix
 *
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_51 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println(""Enter string one: "");
        String str1 = input.nextLine();

        final int lengthOne = str1.length();
        System.out.println(""Enter string two: "");

        String str2 = input.nextLine();
        final int lengthTwo = str2.length();

        if (str1.charAt(0) != str2.charAt(0)) {

            System.out.println(str1 + "" and "" + str2 + "" have :(. ---> no common prefix <---"");

        } else {
            int indexOfLCP = 0;
            for (int i = 0; i < (Math.max(lengthOne, lengthTwo)); i++) {

                if (str1.charAt(i) == str2.charAt(i)) {
                    indexOfLCP = i;
                } else {
                    break;
                }
            }
            System.out.print(""The common prefix is: "" + str1.substring(0, indexOfLCP + 1));

        }

        input.close();
    }

}
","import java.util.Scanner;

public class CommonPrefix {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first string: "");
        String str1 = scanner.nextLine();
        System.out.print(""Enter the second string: "");
        String str2 = scanner.nextLine();
        
        // Find length of common prefix
        int len = Math.min(str1.length(), str2.length());
        int i;
        for (i = 0; i < len; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                break;
            }
        }
        
        // Output common prefix
        String commonPrefix = str1.substring(0, i);
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is: "" + commonPrefix);
        } else {
            System.out.println(""There is no common prefix."");
        }
    }
}",2,"import java.util.Scanner;

public class CommonPrefixFinderByHarryDulaney {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.println(""Welcome to the Common Prefix Finder!"");

        System.out.print(""Enter the first string: "");
        String firstString = input.nextLine();

        System.out.print(""Enter the second string: "");
        String secondString = input.nextLine();

        System.out.print(""The common prefix is: "");

        int minLength = Math.min(firstString.length(), secondString.length());
        StringBuilder commonPrefix = new StringBuilder();

        for (int i = 0; i < minLength; i++) {
            char charFromFirst = firstString.charAt(i);
            char charFromSecond = secondString.charAt(i);

            if (charFromFirst == charFromSecond) {
                commonPrefix.append(charFromFirst);
            } else {
                break; // No need to continue if characters don't match
            }
        }

        if (commonPrefix.length() == 0) {
            System.out.println(""The strings have no common prefix."");
        } else {
            System.out.println(commonPrefix.toString());
        }

        input.close();
    }
}",0.6739255014326647
0_Exercise05_26.java," /**
 * **5.26 (Compute e) You can approximate e using the following series:
 * e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ... + 1/i!
 * Write a program that displays the e value for i = 10000, 20000, …, and
 * 100000. (Hint: Because i! = i * (i - 1) * c * 2 * 1, then
 * 1 i!
 * is
 * 1
 * i(i - 1)!
 * Initialize e and item to be 1 and keep adding a new item to e. The new item is
 * the previous item divided by i for i = 2, 3, 4, ....)
 */","package ch_05;

import java.util.*;


public class Exercise05_26 {
    static double e;

    public static void main(String[] args) {
        double e = 1;
        int item = 10000;
        while (item <= 100000) {
            double denominator = 0;
            for (double i = 1; i <= item; i++) {
                denominator += i * (i - 1);
            }
            e += 1 / denominator;
            System.out.println(""e is "" + e + "" when i is "" + item);
            item += 10000;
        }
    }
}

","import java.math.BigDecimal;

public class ApproximateE {
    public static void main(String[] args) {
        int[] iValues = {10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000};
        for (int i : iValues) {
            BigDecimal sum = BigDecimal.ONE;
            BigDecimal factorial = BigDecimal.ONE;
            for (int j = 1; j <= i; j++) {
                factorial = factorial.multiply(BigDecimal.valueOf(j));
                sum = sum.add(BigDecimal.ONE.divide(factorial));
            }
            System.out.println(""e for i = "" + i + "" is: "" + sum);
        }
    }
}",2,"public class ApproximateEValueCalculator {
    public static void main(String[] args) {
        System.out.println(""Approximating the value of e..."");

        double eValue = 1; // Initializing e to 1
        double item = 1; // Initializing item to 1

        for (int i = 1; i <= 100000; i++) {
            item /= i; // Dividing item by i
            eValue += item; // Adding the new item to eValue
        }

        System.out.println(""The approximate value of e for i = 100000 is: "" + eValue);
    }
}",0.4897959183673469
0_Exercise05_30.java," /**
 * 5.30 (Financial application: compound value) Suppose you save $100
 * each month into a savings account with the annual interest rate 5%.
 * So, the monthly interest rate is 0.05 / 12 = 0.00417. After the first
 * month, the value in the account becomes.
 * Write a program that prompts the user to enter an amount (e.g., 100)
 * the annual interest rate (e.g., 5), and the number of months (e.g., 6)
 * and displays the amount in the savings account after the given month.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_30 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the amount you would like to invest each month: "");

        double investment = input.nextDouble();

        System.out.print(""Enter the annual interest rate(e.g. 5,10,20): "");

        double interestRate = input.nextDouble();

        interestRate = interestRate / 100;

        System.out.println(""Enter the number of months: "");

        int numberOfMonths = input.nextInt();

        double total = 0;

        for (int i = 1; i <= numberOfMonths; i++) {


            total = (investment + total) * (1 + (interestRate / 12));

        }


        System.out.println(""After the "" + numberOfMonths + ""th month, "" + ""the account value is "" + total);


    }

}
","import java.util.Scanner;

public class SavingsAccount {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Get input from user
        System.out.print(""Enter the initial amount: $"");
        double amount = scanner.nextDouble();
        System.out.print(""Enter the annual interest rate (as a percentage): "");
        double annualRate = scanner.nextDouble();
        System.out.print(""Enter the number of months: "");
        int months = scanner.nextInt();
        
        // Compute monthly interest rate
        double monthlyRate = annualRate / 1200.0;  // 12 months in a year, 100 to convert percentage to decimal
        
        // Compute balance after specified number of months
        for (int i = 1; i <= months; i++) {
            amount = amount + (100 * monthlyRate) + 100;  // add monthly deposit and interest
        }
        
        // Output balance
        System.out.printf(""The balance after %d months is: $%.2f"", months, amount);
    }
}",2,"import java.util.Scanner;

public class CompoundValueCalculator {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.println(""Welcome to the Compound Value Calculator!"");

        System.out.print(""Enter the monthly saving amount (e.g., 100): "");
        double monthlySavingAmount = input.nextDouble();

        System.out.print(""Enter the annual interest rate (e.g., 5): "");
        double annualInterestRate = input.nextDouble();

        System.out.print(""Enter the number of months (e.g., 6): "");
        int numberOfMonths = input.nextInt();

        double monthlyInterestRate = annualInterestRate / 1200; // Calculating monthly interest rate

        double futureValue = 0; // Initializing future value to 0

        for (int i = 1; i <= numberOfMonths; i++) {
            futureValue = (monthlySavingAmount + futureValue) * (1 + monthlyInterestRate);
        }

        System.out.println(""The amount in the savings account after "" + numberOfMonths + "" months is: $"" + futureValue);

        input.close();
    }
}",0.6821873308067136
0_Exercise05_27.java," /**
 * **5.28 (Display the first days of each month) Write a program that prompts the user to
 * enter the year and first day of the year, and displays the first day of each month
 * in the year. For example, if the user entered the year 2013, and 2 for Tuesday,
 * January 1, 2013, your program should display the following output:
 * January 1, 2013 is Tuesday
 * ...
 * December 1, 2013 is Sunday
 */","package ch_05;

import java.util.*;


public class Exercise05_27 {
    public static void main(String[] args) {

        int i = 1;
        for (int year = 2001; year <= 2100; year++) {

            if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
                System.out.print(year + "" "");
                if (i % 10 == 0) {
                    System.out.println();
                }
                i++;
            }

        }
    }
}","import java.util.Scanner;

public class FirstDayOfMonth {
    public static void main(String[] args) {
        // Prompt the user to enter the year and first day of the year
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the year: "");
        int year = input.nextInt();
        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, etc.): "");
        int firstDay = input.nextInt();

        // Define a list of month names and the number of days in each month
        String[] monthNames = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
        int[] daysInMonth = {31, 28 + (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        // Display the first day of each month in the year
        for (int i = 0; i < 12; i++) {
            // Determine the first day of the current month
            int firstDayOfMonth = (firstDay + ((i == 0) ? 0 : daysInMonth[i - 1])) % 7;

            // Display the first day of the current month
            System.out.printf(""%s 1, %d is %s\n"", monthNames[i], year, getDayName(firstDayOfMonth));

            // Update the first day for the next month
            firstDay = firstDayOfMonth;
        }
    }

    // Returns the name of a day given its number (0 = Sunday, 1 = Monday, etc.)
    private static String getDayName(int day) {
        String[] dayNames = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
        return dayNames[day];
    }
}",3,"import java.util.Scanner;

public class MonthDaysDisplay {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Get user input for the year and the first day of the year
        System.out.print(""Enter the year (e.g., 2013): "");
        int year = input.nextInt();

        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, ..., 6 for Saturday): "");
        int firstDay = input.nextInt();

        // Validate user input
        if (year < 0 || firstDay < 0 || firstDay > 6) {
            System.out.println(""Invalid input. Please enter valid values."");
            return;
        }

        // Array to store the names of the months
        String[] months = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"",
                           ""August"", ""September"", ""October"", ""November"", ""December""};

        // Array to store the names of the days
        String[] days = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};

        // Display the first day of each month
        for (int month = 1; month <= 12; month++) {
            System.out.print(months[month - 1] + "" 1, "" + year + "" is "");
            
            // Calculate the day of the week for the first day of the month
            int dayOfWeek = (firstDay + (month - 1) * 31) % 7;
            
            System.out.println(days[dayOfWeek]);
        }

        // Close the Scanner to avoid resource leak
        input.close();
    }
}",0.5851142225497421
0_Exercise05_07.java," /**
 * *5.7 (Financial application: compute future tuition) Suppose that the tuition for
 * a university is $10,000 this year and increases 5% every year. In one year, the tuition
 * will be $10,500. Write a program that computes the tuition in ten years and the
 * total cost of four years’ worth of tuition after the tenth year.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_07 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double highScore = 0;
        String studentName = "" "";

        System.out.print(""Enter the number of students: "");
        int numberOfstudents = input.nextInt();

        System.out.print(""Enter a student name: "");
        studentName = input.next();

        System.out.print(""Enter the students score: "");
        highScore = input.nextDouble();

        String tempName = """";
        double tempScore = 0;

        while (numberOfstudents > 1) {

            System.out.print(""Enter a student name: "");
            tempName = input.next();

            System.out.print(""Enter the students score: "");
            tempScore = input.nextDouble();

            if (tempScore > highScore)
                highScore = tempScore;
            studentName = tempName;


            numberOfstudents--;
        }
        System.out.println(""Top student "" + studentName + ""'s score is "" + highScore);
    }

}
","public class TuitionCalculator {
    public static void main(String[] args) {
        double tuition = 10000.0; // Initial tuition is $10,000
        double totalCost = 0.0;

        // Compute the tuition for each of the next ten years
        for (int i = 1; i <= 10; i++) {
            tuition *= 1.05; // Increase tuition by 5%
            if (i > 4) {
                totalCost += tuition; // Add tuition to the total cost for years 5-10
            }
        }

        // Display the tuition in ten years and the total cost of four years' worth of tuition
        System.out.printf(""The tuition in ten years is $%.2f\n"", tuition);
        System.out.printf(""The total cost of four years' worth of tuition after the tenth year is $%.2f\n"", totalCost);
    }
}",3,"public class FutureTuitionCalculator {

    public static void main(String[] args) {
        // Initialize variables
        double initialTuition = 10000.0;  // Initial tuition amount
        double annualIncreaseRate = 0.05; // Annual tuition increase rate
        int numberOfYears = 10;           // Number of years to calculate tuition for
        double totalTuition = 0.0;        // Total tuition over the years

        // Calculate and display tuition for each year
        for (int year = 1; year <= numberOfYears; year++) {
            // Calculate the tuition for the current year
            double currentTuition = initialTuition * Math.pow(1 + annualIncreaseRate, year);

            // Display the tuition for the current year
            System.out.println(""Tuition for year "" + year + "": $"" + currentTuition);

            // Add the current year's tuition to the total
            totalTuition += currentTuition;
        }

        // Display the total cost of four years' worth of tuition after the tenth year
        System.out.println(""Total cost of four years' worth of tuition after the tenth year: $"" + totalTuition);
    }
}",0.5823708206686931
0_Exercise05_50.java," /**
 * 5.50 (Count uppercase letters) Write a program that prompts
 * the user to enter a string and displays the number of the upper-case
 * letters in the string.
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_50 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a string with some uppercase letters: "");

        String toBeevaluated = input.nextLine();
        int numberOfuppercase = 0;
        int x = 0;

        while (x < toBeevaluated.length()) {

            if (Character.isUpperCase(toBeevaluated.charAt(x))) {
                numberOfuppercase++;
            }
            x++;
        }

        System.out.println(""The number of upper case letters is: "" + numberOfuppercase);

    }

}
","import java.util.Scanner;

public class CountUpperCase {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        int upperCaseCount = 0;
        for (int i = 0; i < inputString.length(); i++) {
            if (Character.isUpperCase(inputString.charAt(i))) {
                upperCaseCount++;
            }
        }

        System.out.println(""Number of upper-case letters: "" + upperCaseCount);
    }
}",3,"import java.util.Scanner;

// Program to count uppercase letters in a string
public class UppercaseLetterCounter {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Prompt the user to enter a string
        System.out.print(""Please enter a string: "");
        String userString = input.nextLine();

        // Initialize counter for uppercase letters
        int uppercaseCount = 0;

        // Loop through each character in the string
        for (int i = 0; i < userString.length(); i++) {
            char currentChar = userString.charAt(i);

            // Check if the current character is an uppercase letter
            if (Character.isUpperCase(currentChar)) {
                uppercaseCount = uppercaseCount + 1; // Increment the uppercase count
            }
        }

        // Display the result
        System.out.println(""The number of uppercase letters in the string is: "" + uppercaseCount);

        // Close the Scanner to avoid resource leak
        input.close();
    }
}",0.6043058648849294
0_Exercise05_46.java," /**
 * 5.46 (Reverse a string) Write a program that prompts
 * the user to enter a string and displays the string in reverse order.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_46 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String str = input.nextLine();

        for (int i = str.length() - 1; i >= 0; i--) {

            System.out.print(str.charAt(i));

        }

    }

}
","import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        String reversedString = """";
        for (int i = inputString.length() - 1; i >= 0; i--) {
            reversedString += inputString.charAt(i);
        }

        System.out.println(""Reversed string: "" + reversedString);
    }
}",3,"import java.util.Scanner;

// A program to reverse a string entered by the user
public class StringReverser {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter a string
        System.out.print(""Please enter a string: "");
        String userInput = scanner.nextLine();

        // Convert the string to a character array
        char[] charArray = userInput.toCharArray();

        // Create a new array to store the reversed characters
        char[] reversedArray = new char[charArray.length];

        // Reverse the string using a for loop
        for (int i = charArray.length - 1, j = 0; i >= 0; i--, j++) {
            reversedArray[j] = charArray[i];
        }

        // Display the reversed string
        System.out.print(""The reversed string is: "");
        for (char reversedChar : reversedArray) {
            System.out.print(reversedChar);
        }

        // Close the scanner to avoid resource leak
        scanner.close();
    }
}",0.5506134969325154
0_Exercise05_11.java," /**
 * 5.11 (Find numbers divisible by 5 or 6, but not both) Write a program
 * that displays all the numbers from 100 to 200, ten per line, that are
 * divisible by 5 or 6, but not both. Numbers are separated by exactly one
 * space.
 */","package ch_05;


public class Exercise05_11 {
    public static void main(String[] args) {

        int count = 0;

        for (int i = 100; i <= 200; i++) {

            if (count == 10) {
                System.out.println();
                count = 0;
            }

            if (i % 5 == 0 ^ i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
            }


        }
    }
}
","public class DivisibleByFiveOrSix {
    public static void main(String[] args) {
        final int NUMS_PER_LINE = 10;
        int count = 0;

        for (int i = 100; i <= 200; i++) {
            if ((i % 5 == 0 || i % 6 == 0) && !(i % 5 == 0 && i % 6 == 0)) {
                System.out.print(i + "" "");
                count++;

                if (count == NUMS_PER_LINE) {
                    System.out.println();
                    count = 0;
                }
            }
        }
    }
}",3,"// Program to find numbers divisible by 5 or 6, but not both, in the range 100 to 200
public class DivisibleNumbersFinder {

    public static void main(String[] args) {
        // Loop through the numbers from 100 to 200
        for (int number = 100; number <= 200; number++) {
            // Check if the number is divisible by 5 or 6, but not both
            if ((number % 5 == 0 || number % 6 == 0) && !(number % 5 == 0 && number % 6 == 0)) {
                System.out.print(number + "" ""); // Display the number

                // Check if it's the tenth number on the line
                if (number % 10 == 0) {
                    System.out.println(); // Move to the next line
                }
            }
        }
    }
}",0.5671957671957671
0_Exercise05_10.java," /**
 * 5.10 (Find numbers divisible by 5 and 6) Write a program that displays
 * all the numbers from 100 to 1,000, ten per line, that are divisible by
 * 5 and 6. Numbers are separated by exactly one space.
 */","package ch_05;


public class Exercise05_10 {
    public static void main(String[] args) {

        final int startNum = 100;
        final int endNum = 1000;

        int count = 0;
        for (int i = startNum; i <= endNum; i++) {

            if (i % 6 == 0 && i % 5 == 0) {
                System.out.print(i + "" "");
                count++;

                if (count == 10) {
                    System.out.println();
                    count = 0;
                }

            }

        }

    }
}
","public class DivisibleBy5And6 {
    public static void main(String[] args) {
        final int LOWER_LIMIT = 100;
        final int UPPER_LIMIT = 1000;
        final int NUMBERS_PER_LINE = 10;

        int count = 0;
        for (int i = LOWER_LIMIT; i <= UPPER_LIMIT; i++) {
            if (i % 5 == 0 && i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
                if (count % NUMBERS_PER_LINE == 0) {
                    System.out.println();
                }
            }
        }
    }
}",3,"// Program to find numbers divisible by 5 and 6 in the range 100 to 1000
public class DivisibleNumbersFinder {

    public static void main(String[] args) {
        // Loop through the numbers from 100 to 1000
        for (int number = 100; number <= 1000; number++) {
            // Check if the number is divisible by both 5 and 6
            if (number % 5 == 0 && number % 6 == 0) {
                System.out.print(number + "" ""); // Display the number

                // Check if it's the tenth number on the line
                if (number % 10 == 0) {
                    System.out.println(); // Move to the next line
                }
            }
        }
    }
}",0.5195652173913043
0_Exercise05_47.java," /**
 * *5.47 (Business: check ISBN-13) ISBN-13 is a new standard for identifying books. It
 * uses 13 digits d1d2d3d4d5d6d7d8d9d10d11d12d13. The last digit d13 is a checksum,
 * which is calculated from the other digits using the following formula:
 * 10 - (d1 + 3d2 + d3 + 3d4 + d5 + 3d6 + d7 + 3d8 + d9 + 3d10 + d11 + 3d12)%10
 * If the checksum is 10, replace it with 0. Your program should read the input as a
 * string.
 * <p>
 * <strong>Here are sample runs:</strong>
 * <p>
 * {@code Enter the first 12 digits of an ISBN-13 as a string: 978013213080
 * The ISBN-13 number is 9780132130806
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 978013213079
 * The ISBN-13 number is 9780132130790
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 97801320
 * 97801320 is an invalid input}
 */","package ch_05;

import java.util.*;


public class Exercise05_47 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String isbn = in.nextLine();

        // Verify string length
        if (isbn.length() != 12) {
            System.out.println(""Invalid input "" + isbn + "" input MUST be exactly 12 numbers"");
            System.exit(0);
        }

        int check = 0;
        for (int i = 0; i < isbn.length(); i++) {
            int value = Integer.parseInt(String.valueOf(isbn.charAt(i)));
            check += i % 2 == 0 ? 3 * value
                    : value;
        }
        check = 10 - check % 10;
        
        System.out.println(""ISBN-13 number is "" + isbn +
                (check == 10 ? 0 : check));

        in.close();
    }
}","import java.util.Scanner;

public class ISBNChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first 12 digits of the ISBN-13: "");
        String input = scanner.nextLine();
        
        // Convert input to integer array
        int[] digits = new int[12];
        for (int i = 0; i < 12; i++) {
            digits[i] = Character.getNumericValue(input.charAt(i));
        }
        
        // Calculate checksum
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            if (i % 2 == 0) {
                sum += digits[i];
            } else {
                sum += digits[i] * 3;
            }
        }
        int checksum = 10 - (sum % 10);
        if (checksum == 10) {
            checksum = 0;
        }
        
        // Output complete ISBN-13
        System.out.println(""The complete ISBN-13 is: "" + input + checksum);
    }
}",3,"import java.util.Scanner;

// Program to check ISBN-13 validity and calculate the checksum
public class ISBNChecker {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first 12 digits of an ISBN-13 as a string
        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String input = scanner.nextLine();

        // Check if the input has exactly 12 digits
        if (input.length() != 12) {
            System.out.println(input + "" is an invalid input"");
        } else {
            // Calculate the checksum
            int checksum = calculateChecksum(input);

            // Display the complete ISBN-13 number
            System.out.println(""The ISBN-13 number is "" + input + checksum);
        }

        // Close the scanner to avoid resource leak
        scanner.close();
    }

    // Function to calculate the ISBN-13 checksum
    private static int calculateChecksum(String input) {
        int sum = 0;

        // Loop through each digit of the input string
        for (int i = 0; i < input.length(); i++) {
            int digit = Character.getNumericValue(input.charAt(i));

            // Apply the formula for calculating the checksum
            sum += (i % 2 == 0) ? digit : 3 * digit;
        }

        // Calculate the checksum value
        int checksum = 10 - (sum % 10);

        // If the checksum is 10, replace it with 0
        return (checksum == 10) ? 0 : checksum;
    }
}",0.5257425742574258
0_Exercise05_51.java," /**
 * *5.51 (Longest common prefix) Write a program that prompts the user to enter two
 * strings and displays the largest common prefix of the two strings. Here are some
 * sample runs:
 * Enter the first string: Welcome to C++
 * Enter the second string: Welcome to programming
 * The common prefix is Welcome to
 * Enter the first string: Atlanta
 * Enter the second string: Macon
 * Atlanta and Macon have no common prefix
 *
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_51 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println(""Enter string one: "");
        String str1 = input.nextLine();

        final int lengthOne = str1.length();
        System.out.println(""Enter string two: "");

        String str2 = input.nextLine();
        final int lengthTwo = str2.length();

        if (str1.charAt(0) != str2.charAt(0)) {

            System.out.println(str1 + "" and "" + str2 + "" have :(. ---> no common prefix <---"");

        } else {
            int indexOfLCP = 0;
            for (int i = 0; i < (Math.max(lengthOne, lengthTwo)); i++) {

                if (str1.charAt(i) == str2.charAt(i)) {
                    indexOfLCP = i;
                } else {
                    break;
                }
            }
            System.out.print(""The common prefix is: "" + str1.substring(0, indexOfLCP + 1));

        }

        input.close();
    }

}
","import java.util.Scanner;

public class CommonPrefix {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first string: "");
        String str1 = scanner.nextLine();
        System.out.print(""Enter the second string: "");
        String str2 = scanner.nextLine();
        
        // Find length of common prefix
        int len = Math.min(str1.length(), str2.length());
        int i;
        for (i = 0; i < len; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                break;
            }
        }
        
        // Output common prefix
        String commonPrefix = str1.substring(0, i);
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is: "" + commonPrefix);
        } else {
            System.out.println(""There is no common prefix."");
        }
    }
}",3,"import java.util.Scanner; // Import Scanner for reading user input

public class LongestCommonPrefix {
    public static void main(String[] args) {
        // Use Scanner to get input from the user
        Scanner scanner = new Scanner(System.in);

        // Prompt user for the first string
        System.out.print(""Enter the first string: "");
        String string1 = scanner.nextLine(); // Read first string

        // Prompt user for the second string
        System.out.print(""Enter the second string: "");
        String string2 = scanner.nextLine(); // Read second string

        // Find the longest common prefix
        String commonPrefix = findLongestCommonPrefix(string1, string2);

        // Check if common prefix exists and display the result
        if (commonPrefix.equals("""")) {
            System.out.println(string1 + "" and "" + string2 + "" have no common prefix"");
        } else {
            System.out.println(""The common prefix is "" + commonPrefix);
        }

        scanner.close(); // Close the scanner
    }

    // Method to find the longest common prefix
    private static String findLongestCommonPrefix(String str1, String str2) {
        String result = """"; // Initialize result string
        int length = Math.min(str1.length(), str2.length()); // Find the shorter length

        // Iterate over the characters to find the common prefix
        for (int i = 0; i < length; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                break; // Break loop if characters don't match
            }
            result += str1.charAt(i); // Concatenate matching character to result
        }

        return result; // Return the common prefix
    }
}
",0.5207857469164002
0_Exercise05_26.java," /**
 * **5.26 (Compute e) You can approximate e using the following series:
 * e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ... + 1/i!
 * Write a program that displays the e value for i = 10000, 20000, …, and
 * 100000. (Hint: Because i! = i * (i - 1) * c * 2 * 1, then
 * 1 i!
 * is
 * 1
 * i(i - 1)!
 * Initialize e and item to be 1 and keep adding a new item to e. The new item is
 * the previous item divided by i for i = 2, 3, 4, ....)
 */","package ch_05;

import java.util.*;


public class Exercise05_26 {
    static double e;

    public static void main(String[] args) {
        double e = 1;
        int item = 10000;
        while (item <= 100000) {
            double denominator = 0;
            for (double i = 1; i <= item; i++) {
                denominator += i * (i - 1);
            }
            e += 1 / denominator;
            System.out.println(""e is "" + e + "" when i is "" + item);
            item += 10000;
        }
    }
}

","import java.math.BigDecimal;

public class ApproximateE {
    public static void main(String[] args) {
        int[] iValues = {10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000};
        for (int i : iValues) {
            BigDecimal sum = BigDecimal.ONE;
            BigDecimal factorial = BigDecimal.ONE;
            for (int j = 1; j <= i; j++) {
                factorial = factorial.multiply(BigDecimal.valueOf(j));
                sum = sum.add(BigDecimal.ONE.divide(factorial));
            }
            System.out.println(""e for i = "" + i + "" is: "" + sum);
        }
    }
}",3,"// Program to approximate the value of e using a series
public class ApproximateE {

    public static void main(String[] args) {
        // Display the header
        System.out.println(""i\t\t\te"");
        System.out.println(""-----------------------------"");

        // Initialize variables
        double e = 1.0; // The value of e
        double item = 1.0; // The current item in the series

        // Loop through values of i from 10000 to 100000 in increments of 10000
        for (int i = 10000; i <= 100000; i += 10000) {
            // Update the value of e using the series formula
            for (int j = 1; j <= i; j++) {
                item /= j;
            }
            e += item;

            // Display the result for the current i
            System.out.println(i + ""\t\t\t"" + e);
        }
    }
}",0.43986254295532645
0_Exercise05_30.java," /**
 * 5.30 (Financial application: compound value) Suppose you save $100
 * each month into a savings account with the annual interest rate 5%.
 * So, the monthly interest rate is 0.05 / 12 = 0.00417. After the first
 * month, the value in the account becomes.
 * Write a program that prompts the user to enter an amount (e.g., 100)
 * the annual interest rate (e.g., 5), and the number of months (e.g., 6)
 * and displays the amount in the savings account after the given month.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_30 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the amount you would like to invest each month: "");

        double investment = input.nextDouble();

        System.out.print(""Enter the annual interest rate(e.g. 5,10,20): "");

        double interestRate = input.nextDouble();

        interestRate = interestRate / 100;

        System.out.println(""Enter the number of months: "");

        int numberOfMonths = input.nextInt();

        double total = 0;

        for (int i = 1; i <= numberOfMonths; i++) {


            total = (investment + total) * (1 + (interestRate / 12));

        }


        System.out.println(""After the "" + numberOfMonths + ""th month, "" + ""the account value is "" + total);


    }

}
","import java.util.Scanner;

public class SavingsAccount {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Get input from user
        System.out.print(""Enter the initial amount: $"");
        double amount = scanner.nextDouble();
        System.out.print(""Enter the annual interest rate (as a percentage): "");
        double annualRate = scanner.nextDouble();
        System.out.print(""Enter the number of months: "");
        int months = scanner.nextInt();
        
        // Compute monthly interest rate
        double monthlyRate = annualRate / 1200.0;  // 12 months in a year, 100 to convert percentage to decimal
        
        // Compute balance after specified number of months
        for (int i = 1; i <= months; i++) {
            amount = amount + (100 * monthlyRate) + 100;  // add monthly deposit and interest
        }
        
        // Output balance
        System.out.printf(""The balance after %d months is: $%.2f"", months, amount);
    }
}",3,"import java.util.Scanner;

// Program to calculate the compound value in a savings account
public class CompoundValueCalculator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the amount, annual interest rate, and number of months
        System.out.print(""Enter the monthly savings amount (e.g., 100): "");
        double monthlySavings = scanner.nextDouble();

        System.out.print(""Enter the annual interest rate (e.g., 5): "");
        double annualInterestRate = scanner.nextDouble();

        System.out.print(""Enter the number of months (e.g., 6): "");
        int numberOfMonths = scanner.nextInt();

        // Calculate the monthly interest rate
        double monthlyInterestRate = annualInterestRate / 100 / 12;

        // Initialize the total amount
        double totalAmount = 0;

        // Loop through each month to calculate the compound value
        for (int i = 1; i <= numberOfMonths; i++) {
            totalAmount = (totalAmount + monthlySavings) * (1 + monthlyInterestRate);
        }

        // Display the result
        System.out.println(""The amount in the savings account after "" + numberOfMonths + "" months is: $"" + totalAmount);

        // Close the scanner to avoid resource leak
        scanner.close();
    }
}",0.6854095976732913
0_Exercise05_27.java," /**
 * **5.28 (Display the first days of each month) Write a Java program that prompts the user to
 * enter the year and first day of the year, and displays the first day of each month
 * in the year. For example, if the user entered the year 2013, and 2 for Tuesday,
 * January 1, 2013, your program should display the following output:
 * January 1, 2013 is Tuesday
 * ...
 * December 1, 2013 is Sunday
 */","package ch_05;

import java.util.*;


public class Exercise05_27 {
    public static void main(String[] args) {

        int i = 1;
        for (int year = 2001; year <= 2100; year++) {

            if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
                System.out.print(year + "" "");
                if (i % 10 == 0) {
                    System.out.println();
                }
                i++;
            }

        }
    }
}","import java.util.Scanner;

public class FirstDayOfMonth {
    public static void main(String[] args) {
        // Prompt the user to enter the year and first day of the year
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the year: "");
        int year = input.nextInt();
        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, etc.): "");
        int firstDay = input.nextInt();

        // Define a list of month names and the number of days in each month
        String[] monthNames = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
        int[] daysInMonth = {31, 28 + (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        // Display the first day of each month in the year
        for (int i = 0; i < 12; i++) {
            // Determine the first day of the current month
            int firstDayOfMonth = (firstDay + ((i == 0) ? 0 : daysInMonth[i - 1])) % 7;

            // Display the first day of the current month
            System.out.printf(""%s 1, %d is %s\n"", monthNames[i], year, getDayName(firstDayOfMonth));

            // Update the first day for the next month
            firstDay = firstDayOfMonth;
        }
    }

    // Returns the name of a day given its number (0 = Sunday, 1 = Monday, etc.)
    private static String getDayName(int day) {
        String[] dayNames = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
        return dayNames[day];
    }
}",4,"import java.util.Scanner;

public class FirstDayOfMonthProgram {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Welcome message
        System.out.println(""Welcome to the First Day of Each Month Program!"");

        // Get the year from the user
        System.out.print(""Enter the year (e.g., 2013): "");
        int year = input.nextInt();

        // Get the first day of the year from the user
        System.out.print(""Enter the first day of the year (1 for Sunday, 2 for Monday, ..., 7 for Saturday): "");
        int firstDay = input.nextInt();

        // Display the first day of each month
        System.out.println(""\nFirst day of each month in "" + year + "":\n"");

        for (int month = 1; month <= 12; month++) {
            // Display the month name
            System.out.print(getMonthName(month) + "" 1, "" + year + "" is "");

            // Display the day of the week
            System.out.println(getDayOfWeek(firstDay));

            // Update the first day for the next month
            firstDay = (firstDay + getNumberOfDaysInMonth(month, year)) % 7;
        }

        // Close the scanner
        input.close();
    }

    // Method to get the month name
    private static String getMonthName(int month) {
        String[] monthNames = {
                ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
                ""July"", ""August"", ""September"", ""October"", ""November"", ""December""
        };
        return monthNames[month - 1];
    }

    // Method to get the day of the week
    private static String getDayOfWeek(int day) {
        String[] dayOfWeek = {
                ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""
        };
        return dayOfWeek[day - 1];
    }

    // Method to get the number of days in a month
    private static int getNumberOfDaysInMonth(int month, int year) {
        if (month == 2) {
            return (isLeapYear(year)) ? 29 : 28;
        } else if (month == 4 || month == 6 || month == 9 || month == 11) {
            return 30;
        } else {
            return 31;
        }
    }

    // Method to check if a year is a leap year
    private static boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }
}",0.5032448377581121
0_Exercise05_07.java," /**
 * *5.7 (Financial application: compute future tuition) Suppose that the tuition for
 * a university is $10,000 this year and increases 5% every year. In one year, the tuition
 * will be $10,500. Write a program that computes the tuition in ten years and the
 * total cost of four years’ worth of tuition after the tenth year.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_07 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double highScore = 0;
        String studentName = "" "";

        System.out.print(""Enter the number of students: "");
        int numberOfstudents = input.nextInt();

        System.out.print(""Enter a student name: "");
        studentName = input.next();

        System.out.print(""Enter the students score: "");
        highScore = input.nextDouble();

        String tempName = """";
        double tempScore = 0;

        while (numberOfstudents > 1) {

            System.out.print(""Enter a student name: "");
            tempName = input.next();

            System.out.print(""Enter the students score: "");
            tempScore = input.nextDouble();

            if (tempScore > highScore)
                highScore = tempScore;
            studentName = tempName;


            numberOfstudents--;
        }
        System.out.println(""Top student "" + studentName + ""'s score is "" + highScore);
    }

}
","public class TuitionCalculator {
    public static void main(String[] args) {
        double tuition = 10000.0; // Initial tuition is $10,000
        double totalCost = 0.0;

        // Compute the tuition for each of the next ten years
        for (int i = 1; i <= 10; i++) {
            tuition *= 1.05; // Increase tuition by 5%
            if (i > 4) {
                totalCost += tuition; // Add tuition to the total cost for years 5-10
            }
        }

        // Display the tuition in ten years and the total cost of four years' worth of tuition
        System.out.printf(""The tuition in ten years is $%.2f\n"", tuition);
        System.out.printf(""The total cost of four years' worth of tuition after the tenth year is $%.2f\n"", totalCost);
    }
}",4,"import java.util.Scanner;

public class FirstDayOfMonthProgram {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Welcome message
        System.out.println(""Welcome to the First Day of Each Month Program!"");

        // Get the year from the user
        System.out.print(""Enter the year (e.g., 2013): "");
        int year = input.nextInt();

        // Get the first day of the year from the user
        System.out.print(""Enter the first day of the year (1 for Sunday, 2 for Monday, ..., 7 for Saturday): "");
        int firstDay = input.nextInt();

        // Display the first day of each month
        System.out.println(""\nFirst day of each month in "" + year + "":\n"");

        for (int month = 1; month <= 12; month++) {
            // Display the month name
            System.out.print(getMonthName(month) + "" 1, "" + year + "" is "");

            // Display the day of the week
            System.out.println(getDayOfWeek(firstDay));

            // Update the first day for the next month
            firstDay = (firstDay + getNumberOfDaysInMonth(month, year)) % 7;
        }

        // Close the scanner
        input.close();
    }

    // Method to get the month name
    private static String getMonthName(int month) {
        String[] monthNames = {
                ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
                ""July"", ""August"", ""September"", ""October"", ""November"", ""December""
        };
        return monthNames[month - 1];
    }

    // Method to get the day of the week
    private static String getDayOfWeek(int day) {
        String[] dayOfWeek = {
                ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""
        };
        return dayOfWeek[day - 1];
    }

    // Method to get the number of days in a month
    private static int getNumberOfDaysInMonth(int month, int year) {
        if (month == 2) {
            return (isLeapYear(year)) ? 29 : 28;
        } else if (month == 4 || month == 6 || month == 9 || month == 11) {
            return 30;
        } else {
            return 31;
        }
    }

    // Method to check if a year is a leap year
    private static boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }
}
",0.3265774378585086
0_Exercise05_50.java," /**
 * 5.50 (Count uppercase letters) Write a program that prompts
 * the user to enter a string and displays the number of the upper-case
 * letters in the string.
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_50 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a string with some uppercase letters: "");

        String toBeevaluated = input.nextLine();
        int numberOfuppercase = 0;
        int x = 0;

        while (x < toBeevaluated.length()) {

            if (Character.isUpperCase(toBeevaluated.charAt(x))) {
                numberOfuppercase++;
            }
            x++;
        }

        System.out.println(""The number of upper case letters is: "" + numberOfuppercase);

    }

}
","import java.util.Scanner;

public class CountUpperCase {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        int upperCaseCount = 0;
        for (int i = 0; i < inputString.length(); i++) {
            if (Character.isUpperCase(inputString.charAt(i))) {
                upperCaseCount++;
            }
        }

        System.out.println(""Number of upper-case letters: "" + upperCaseCount);
    }
}",4,"import java.util.Scanner;

public class UppercaseCounterProgram {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Uppercase Letter Counter Program!"");

        // Get input from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Please enter a string: "");
        String userString = scanner.nextLine();

        // Initialize the counter for uppercase letters
        int uppercaseCount = 0;

        // Loop through each character in the string
        for (int i = 0; i < userString.length(); i++) {
            char currentChar = userString.charAt(i);

            // Check if the character is uppercase
            if (Character.isUpperCase(currentChar)) {
                // Increment the uppercase counter
                uppercaseCount = uppercaseCount + 1;
            }
        }

        // Display the result
        System.out.println(""\nNumber of uppercase letters in the string: "" + uppercaseCount);

        // Close the scanner
        scanner.close();
    }
}",0.623608017817372
0_Exercise05_46.java," /**
 * 5.46 (Reverse a string) Write a program that prompts
 * the user to enter a string and displays the string in reverse order.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_46 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String str = input.nextLine();

        for (int i = str.length() - 1; i >= 0; i--) {

            System.out.print(str.charAt(i));

        }

    }

}
","import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        String reversedString = """";
        for (int i = inputString.length() - 1; i >= 0; i--) {
            reversedString += inputString.charAt(i);
        }

        System.out.println(""Reversed string: "" + reversedString);
    }
}",4,"import java.util.Scanner;

public class StringReversalProgram {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the String Reversal Program!"");

        // Get input from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Please enter a string: "");
        String userString = scanner.nextLine();

        // Convert the string to a character array
        char[] charArray = userString.toCharArray();

        // Initialize an empty string for the reversed result
        String reversedString = """";

        // Loop through the character array in reverse order
        for (int i = charArray.length - 1; i >= 0; i--) {
            // Concatenate each character to the reversed result
            reversedString = reversedString + charArray[i];
        }

        // Display the reversed string
        System.out.println(""\nReversed string: "" + reversedString);

        // Close the scanner
        scanner.close();
    }
}",0.5944272445820433
0_Exercise05_11.java," /**
 * 5.11 (Find numbers divisible by 5 or 6, but not both) Write a program
 * that displays all the numbers from 100 to 200, ten per line, that are
 * divisible by 5 or 6, but not both. Numbers are separated by exactly one
 * space.
 */","package ch_05;


public class Exercise05_11 {
    public static void main(String[] args) {

        int count = 0;

        for (int i = 100; i <= 200; i++) {

            if (count == 10) {
                System.out.println();
                count = 0;
            }

            if (i % 5 == 0 ^ i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
            }


        }
    }
}
","public class DivisibleByFiveOrSix {
    public static void main(String[] args) {
        final int NUMS_PER_LINE = 10;
        int count = 0;

        for (int i = 100; i <= 200; i++) {
            if ((i % 5 == 0 || i % 6 == 0) && !(i % 5 == 0 && i % 6 == 0)) {
                System.out.print(i + "" "");
                count++;

                if (count == NUMS_PER_LINE) {
                    System.out.println();
                    count = 0;
                }
            }
        }
    }
}",4,"public class DivisibleNumbersProgram {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Divisible Numbers Program!"");

        // Initialize a counter for tracking numbers per line
        int numbersPerLine = 0;

        // Loop through numbers from 100 to 200
        for (int i = 100; i <= 200; i++) {
            // Check if the number is divisible by 5 or 6, but not both
            if ((i % 5 == 0 || i % 6 == 0) && !(i % 5 == 0 && i % 6 == 0)) {
                // Display the number
                System.out.print(i + "" "");

                // Increment the counter
                numbersPerLine++;

                // Check if ten numbers have been displayed
                if (numbersPerLine == 10) {
                    // Move to the next line
                    System.out.println();

                    // Reset the counter
                    numbersPerLine = 0;
                }
            }
        }

        // Display a closing message
        System.out.println(""\nThat's it for the Divisible Numbers Program!"");
    }
}",0.5089058524173028
0_Exercise05_10.java," /**
 * 5.10 (Find numbers divisible by 5 and 6) Write a program that displays
 * all the numbers from 100 to 1,000, ten per line, that are divisible by
 * 5 and 6. Numbers are separated by exactly one space.
 */","package ch_05;


public class Exercise05_10 {
    public static void main(String[] args) {

        final int startNum = 100;
        final int endNum = 1000;

        int count = 0;
        for (int i = startNum; i <= endNum; i++) {

            if (i % 6 == 0 && i % 5 == 0) {
                System.out.print(i + "" "");
                count++;

                if (count == 10) {
                    System.out.println();
                    count = 0;
                }

            }

        }

    }
}
","public class DivisibleBy5And6 {
    public static void main(String[] args) {
        final int LOWER_LIMIT = 100;
        final int UPPER_LIMIT = 1000;
        final int NUMBERS_PER_LINE = 10;

        int count = 0;
        for (int i = LOWER_LIMIT; i <= UPPER_LIMIT; i++) {
            if (i % 5 == 0 && i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
                if (count % NUMBERS_PER_LINE == 0) {
                    System.out.println();
                }
            }
        }
    }
}",4,"public class DivisibleNumbersProgram {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Divisible Numbers Program!"");

        // Initialize a counter for tracking numbers per line
        int numbersPerLine = 0;

        // Loop through numbers from 100 to 1000
        for (int i = 100; i <= 1000; i++) {
            // Check if the number is divisible by 5 and 6
            if (i % 5 == 0 && i % 6 == 0) {
                // Display the number
                System.out.print(i + "" "");

                // Increment the counter
                numbersPerLine++;

                // Check if ten numbers have been displayed
                if (numbersPerLine == 10) {
                    // Move to the next line
                    System.out.println();

                    // Reset the counter
                    numbersPerLine = 0;
                }
            }
        }

        // Display a closing message
        System.out.println(""\nThat's it for the Divisible Numbers Program!"");
    }
}",0.46075085324232085
0_Exercise05_47.java," /**
 * *5.47 (Business: check ISBN-13) ISBN-13 is a new standard for identifying books. It
 * uses 13 digits d1d2d3d4d5d6d7d8d9d10d11d12d13. The last digit d13 is a checksum,
 * which is calculated from the other digits using the following formula:
 * 10 - (d1 + 3d2 + d3 + 3d4 + d5 + 3d6 + d7 + 3d8 + d9 + 3d10 + d11 + 3d12)%10
 * If the checksum is 10, replace it with 0. Your program should read the input as a
 * string.
 * <p>
 * <strong>Here are sample runs:</strong>
 * <p>
 * {@code Enter the first 12 digits of an ISBN-13 as a string: 978013213080
 * The ISBN-13 number is 9780132130806
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 978013213079
 * The ISBN-13 number is 9780132130790
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 97801320
 * 97801320 is an invalid input}
 */","package ch_05;

import java.util.*;


public class Exercise05_47 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String isbn = in.nextLine();

        // Verify string length
        if (isbn.length() != 12) {
            System.out.println(""Invalid input "" + isbn + "" input MUST be exactly 12 numbers"");
            System.exit(0);
        }

        int check = 0;
        for (int i = 0; i < isbn.length(); i++) {
            int value = Integer.parseInt(String.valueOf(isbn.charAt(i)));
            check += i % 2 == 0 ? 3 * value
                    : value;
        }
        check = 10 - check % 10;
        
        System.out.println(""ISBN-13 number is "" + isbn +
                (check == 10 ? 0 : check));

        in.close();
    }
}","import java.util.Scanner;

public class ISBNChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first 12 digits of the ISBN-13: "");
        String input = scanner.nextLine();
        
        // Convert input to integer array
        int[] digits = new int[12];
        for (int i = 0; i < 12; i++) {
            digits[i] = Character.getNumericValue(input.charAt(i));
        }
        
        // Calculate checksum
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            if (i % 2 == 0) {
                sum += digits[i];
            } else {
                sum += digits[i] * 3;
            }
        }
        int checksum = 10 - (sum % 10);
        if (checksum == 10) {
            checksum = 0;
        }
        
        // Output complete ISBN-13
        System.out.println(""The complete ISBN-13 is: "" + input + checksum);
    }
}",4,"import java.util.Scanner;

public class ISBN13Checker {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the ISBN-13 Checker Program!"");

        // Get input from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String userInput = scanner.nextLine();

        // Check if the input has exactly 12 digits
        if (userInput.length() != 12) {
            System.out.println(userInput + "" is an invalid input"");
        } else {
            // Convert the string to an array of integers
            int[] digits = new int[12];
            for (int i = 0; i < 12; i++) {
                digits[i] = Character.getNumericValue(userInput.charAt(i));
            }

            // Calculate the checksum
            int checksum = 10 - ((digits[0] + 3 * digits[1] + digits[2] + 3 * digits[3] +
                    digits[4] + 3 * digits[5] + digits[6] + 3 * digits[7] + digits[8] +
                    3 * digits[9] + digits[10] + 3 * digits[11]) % 10);

            // If the checksum is 10, replace it with 0
            if (checksum == 10) {
                checksum = 0;
            }

            // Display the ISBN-13 number
            System.out.println(""The ISBN-13 number is "" + userInput + checksum);
        }

        // Display a closing message
        System.out.println(""\nThank you for using the ISBN-13 Checker Program!"");
        
        // Close the scanner
        scanner.close();
    }
}",0.6340725806451613
0_Exercise05_51.java," /**
 * *5.51 (Longest common prefix) Write a program that prompts the user to enter two
 * strings and displays the largest common prefix of the two strings. Here are some
 * sample runs:
 * Enter the first string: Welcome to C++
 * Enter the second string: Welcome to programming
 * The common prefix is Welcome to
 * Enter the first string: Atlanta
 * Enter the second string: Macon
 * Atlanta and Macon have no common prefix
 *
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_51 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println(""Enter string one: "");
        String str1 = input.nextLine();

        final int lengthOne = str1.length();
        System.out.println(""Enter string two: "");

        String str2 = input.nextLine();
        final int lengthTwo = str2.length();

        if (str1.charAt(0) != str2.charAt(0)) {

            System.out.println(str1 + "" and "" + str2 + "" have :(. ---> no common prefix <---"");

        } else {
            int indexOfLCP = 0;
            for (int i = 0; i < (Math.max(lengthOne, lengthTwo)); i++) {

                if (str1.charAt(i) == str2.charAt(i)) {
                    indexOfLCP = i;
                } else {
                    break;
                }
            }
            System.out.print(""The common prefix is: "" + str1.substring(0, indexOfLCP + 1));

        }

        input.close();
    }

}
","import java.util.Scanner;

public class CommonPrefix {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first string: "");
        String str1 = scanner.nextLine();
        System.out.print(""Enter the second string: "");
        String str2 = scanner.nextLine();
        
        // Find length of common prefix
        int len = Math.min(str1.length(), str2.length());
        int i;
        for (i = 0; i < len; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                break;
            }
        }
        
        // Output common prefix
        String commonPrefix = str1.substring(0, i);
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is: "" + commonPrefix);
        } else {
            System.out.println(""There is no common prefix."");
        }
    }
}",4,"import java.util.Scanner;

// Longest common prefix program

public class CommonPrefixFinder {

    public static void main(String[] args) {
        // Create a Scanner object to get user input
        Scanner scanner = new Scanner(System.in);

        // Prompt user for the first string
        System.out.print(""Enter the first string: "");
        String firstString = scanner.nextLine();

        // Prompt user for the second string
        System.out.print(""Enter the second string: "");
        String secondString = scanner.nextLine();

        // Initialize variables to store the common prefix
        String commonPrefix = """";
        int minLength = Math.min(firstString.length(), secondString.length());

        // Loop through characters in the strings to find the common prefix
        for (int i = 0; i < minLength; i++) {
            if (firstString.charAt(i) == secondString.charAt(i)) {
                commonPrefix = commonPrefix + firstString.charAt(i);
            } else {
                // Break the loop if a mismatch is found
                break;
            }
        }

        // Display the common prefix or a message if there is none
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is "" + commonPrefix);
        } else {
            System.out.println(firstString + "" and "" + secondString + "" have no common prefix"");
        }

        // Close the Scanner
        scanner.close();
    }
}",0.677319587628866
0_Exercise05_26.java," /**
 * **5.26 (Compute e) You can approximate e using the following series:
 * e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ... + 1/i!
 * Write a program that displays the e value for i = 10000, 20000, …, and
 * 100000. (Hint: Because i! = i * (i - 1) * c * 2 * 1, then
 * 1 i!
 * is
 * 1
 * i(i - 1)!
 * Initialize e and item to be 1 and keep adding a new item to e. The new item is
 * the previous item divided by i for i = 2, 3, 4, ....)
 */","package ch_05;

import java.util.*;


public class Exercise05_26 {
    static double e;

    public static void main(String[] args) {
        double e = 1;
        int item = 10000;
        while (item <= 100000) {
            double denominator = 0;
            for (double i = 1; i <= item; i++) {
                denominator += i * (i - 1);
            }
            e += 1 / denominator;
            System.out.println(""e is "" + e + "" when i is "" + item);
            item += 10000;
        }
    }
}

","import java.math.BigDecimal;

public class ApproximateE {
    public static void main(String[] args) {
        int[] iValues = {10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000};
        for (int i : iValues) {
            BigDecimal sum = BigDecimal.ONE;
            BigDecimal factorial = BigDecimal.ONE;
            for (int j = 1; j <= i; j++) {
                factorial = factorial.multiply(BigDecimal.valueOf(j));
                sum = sum.add(BigDecimal.ONE.divide(factorial));
            }
            System.out.println(""e for i = "" + i + "" is: "" + sum);
        }
    }
}",4,"public class ApproximateEProgram {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Approximate e Calculator Program!"");

        // Calculate and display the approximate e for various values of i
        for (int i = 10000; i <= 100000; i += 10000) {
            // Initialize e and item to be 1
            double e = 1;
            double item = 1;

            // Calculate the approximate e
            for (int j = 1; j <= i; j++) {
                // Update item
                item /= j;

                // Add the new item to e
                e += item;
            }

            // Display the result
            System.out.println(""Approximate e for i = "" + i + "": "" + e);
        }

        // Display a closing message
        System.out.println(""\nThank you for using the Approximate e Calculator Program!"");
    }
}",0.4306139613120269
0_Exercise05_30.java," /**
 * 5.30 (Financial application: compound value) Suppose you save $100
 * each month into a savings account with the annual interest rate 5%.
 * So, the monthly interest rate is 0.05 / 12 = 0.00417. After the first
 * month, the value in the account becomes.
 * Write a program that prompts the user to enter an amount (e.g., 100)
 * the annual interest rate (e.g., 5), and the number of months (e.g., 6)
 * and displays the amount in the savings account after the given month.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_30 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the amount you would like to invest each month: "");

        double investment = input.nextDouble();

        System.out.print(""Enter the annual interest rate(e.g. 5,10,20): "");

        double interestRate = input.nextDouble();

        interestRate = interestRate / 100;

        System.out.println(""Enter the number of months: "");

        int numberOfMonths = input.nextInt();

        double total = 0;

        for (int i = 1; i <= numberOfMonths; i++) {


            total = (investment + total) * (1 + (interestRate / 12));

        }


        System.out.println(""After the "" + numberOfMonths + ""th month, "" + ""the account value is "" + total);


    }

}
","import java.util.Scanner;

public class SavingsAccount {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Get input from user
        System.out.print(""Enter the initial amount: $"");
        double amount = scanner.nextDouble();
        System.out.print(""Enter the annual interest rate (as a percentage): "");
        double annualRate = scanner.nextDouble();
        System.out.print(""Enter the number of months: "");
        int months = scanner.nextInt();
        
        // Compute monthly interest rate
        double monthlyRate = annualRate / 1200.0;  // 12 months in a year, 100 to convert percentage to decimal
        
        // Compute balance after specified number of months
        for (int i = 1; i <= months; i++) {
            amount = amount + (100 * monthlyRate) + 100;  // add monthly deposit and interest
        }
        
        // Output balance
        System.out.printf(""The balance after %d months is: $%.2f"", months, amount);
    }
}",4,"import java.util.Scanner;

public class CompoundValueCalculator {
    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Compound Value Calculator Program!"");

        // Get input from the user
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the monthly saving amount (e.g., 100): "");
        double monthlySavingAmount = scanner.nextDouble();
        System.out.print(""Enter the annual interest rate (e.g., 5): "");
        double annualInterestRate = scanner.nextDouble();
        System.out.print(""Enter the number of months (e.g., 6): "");
        int numberOfMonths = scanner.nextInt();

        // Calculate monthly interest rate
        double monthlyInterestRate = annualInterestRate / 1200;

        // Calculate the future value of the savings account
        double futureValue = 0;
        for (int i = 1; i <= numberOfMonths; i++) {
            futureValue = (monthlySavingAmount + futureValue) * (1 + monthlyInterestRate);
        }

        // Display the result
        System.out.println(""The amount in the savings account after "" + numberOfMonths + "" months: $"" + futureValue);

        // Display a closing message
        System.out.println(""\nThank you for using the Compound Value Calculator Program!"");

        // Close the scanner
        scanner.close();
    }
}",0.6452540747842761
0_Exercise05_27.java," /**
 * **5.28 (Display the first days of each month) Write a program that prompts the user to
 * enter the year and first day of the year, and displays the first day of each month
 * in the year. For example, if the user entered the year 2013, and 2 for Tuesday,
 * January 1, 2013, your program should display the following output:
 * January 1, 2013 is Tuesday
 * ...
 * December 1, 2013 is Sunday
 */","package ch_05;

import java.util.*;


public class Exercise05_27 {
    public static void main(String[] args) {

        int i = 1;
        for (int year = 2001; year <= 2100; year++) {

            if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0))) {
                System.out.print(year + "" "");
                if (i % 10 == 0) {
                    System.out.println();
                }
                i++;
            }

        }
    }
}","import java.util.Scanner;

public class FirstDayOfMonth {
    public static void main(String[] args) {
        // Prompt the user to enter the year and first day of the year
        Scanner input = new Scanner(System.in);
        System.out.print(""Enter the year: "");
        int year = input.nextInt();
        System.out.print(""Enter the first day of the year (0 for Sunday, 1 for Monday, etc.): "");
        int firstDay = input.nextInt();

        // Define a list of month names and the number of days in each month
        String[] monthNames = {""January"", ""February"", ""March"", ""April"", ""May"", ""June"", ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
        int[] daysInMonth = {31, 28 + (year % 4 == 0 && year % 100 != 0 || year % 400 == 0 ? 1 : 0), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

        // Display the first day of each month in the year
        for (int i = 0; i < 12; i++) {
            // Determine the first day of the current month
            int firstDayOfMonth = (firstDay + ((i == 0) ? 0 : daysInMonth[i - 1])) % 7;

            // Display the first day of the current month
            System.out.printf(""%s 1, %d is %s\n"", monthNames[i], year, getDayName(firstDayOfMonth));

            // Update the first day for the next month
            firstDay = firstDayOfMonth;
        }
    }

    // Returns the name of a day given its number (0 = Sunday, 1 = Monday, etc.)
    private static String getDayName(int day) {
        String[] dayNames = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""};
        return dayNames[day];
    }
}",5,"import java.util.Scanner;

public class MonthlyFirstDays {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        // Get user input for year
        System.out.print(""Please enter the year (e.g., 2013): "");
        int year = input.nextInt();

        // Get user input for the first day of the year
        System.out.print(""Please enter the first day of the year (1 for Sunday, 2 for Monday, ..., 7 for Saturday): "");
        int firstDayOfYear = input.nextInt();

        // Display the first day of each month
        for (int month = 1; month <= 12; month++) {
            int daysInMonth = getDaysInMonth(year, month);
            String monthName = getMonthName(month);

            // Determine the day of the week for the first day of the month
            int dayOfWeek = (firstDayOfYear + getTotalDaysElapsed(year, month)) % 7;

            // Display the result
            System.out.println(monthName + "" 1, "" + year + "" is "" + getDayName(dayOfWeek));

            // Update the first day for the next month
            firstDayOfYear = (firstDayOfYear + daysInMonth) % 7;
        }

        input.close();
    }

    // Function to get the number of days in a month
    private static int getDaysInMonth(int year, int month) {
        int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        if (month == 2 && isLeapYear(year)) {
            return 29;
        } else {
            return daysInMonth[month];
        }
    }

    // Function to check if a year is a leap year
    private static boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }

    // Function to get the name of a month
    private static String getMonthName(int month) {
        String[] monthNames = {"""", ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
                ""July"", ""August"", ""September"", ""October"", ""November"", ""December""};
        return monthNames[month];
    }

    // Function to get the name of a day of the week
    private static String getDayName(int dayOfWeek) {
        String[] dayNames = {""Saturday"", ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday""};
        return dayNames[dayOfWeek];
    }

    // Function to get the total number of days elapsed since January 1, 1800
    private static int getTotalDaysElapsed(int year, int month) {
        int totalDays = 0;
        for (int i = 1800; i < year; i++) {
            if (isLeapYear(i)) {
                totalDays += 366;
            } else {
                totalDays += 365;
            }
        }
        for (int i = 1; i < month; i++) {
            totalDays += getDaysInMonth(year, i);
        }
        return totalDays;
    }
}",0.48362183754993343
0_Exercise05_07.java," /**
 * *5.7 (Financial application: compute future tuition) Suppose that the tuition for
 * a university is $10,000 this year and increases 5% every year. In one year, the tuition
 * will be $10,500. Write a program that computes the tuition in ten years and the
 * total cost of four years’ worth of tuition after the tenth year.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_07 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        double highScore = 0;
        String studentName = "" "";

        System.out.print(""Enter the number of students: "");
        int numberOfstudents = input.nextInt();

        System.out.print(""Enter a student name: "");
        studentName = input.next();

        System.out.print(""Enter the students score: "");
        highScore = input.nextDouble();

        String tempName = """";
        double tempScore = 0;

        while (numberOfstudents > 1) {

            System.out.print(""Enter a student name: "");
            tempName = input.next();

            System.out.print(""Enter the students score: "");
            tempScore = input.nextDouble();

            if (tempScore > highScore)
                highScore = tempScore;
            studentName = tempName;


            numberOfstudents--;
        }
        System.out.println(""Top student "" + studentName + ""'s score is "" + highScore);
    }

}
","public class TuitionCalculator {
    public static void main(String[] args) {
        double tuition = 10000.0; // Initial tuition is $10,000
        double totalCost = 0.0;

        // Compute the tuition for each of the next ten years
        for (int i = 1; i <= 10; i++) {
            tuition *= 1.05; // Increase tuition by 5%
            if (i > 4) {
                totalCost += tuition; // Add tuition to the total cost for years 5-10
            }
        }

        // Display the tuition in ten years and the total cost of four years' worth of tuition
        System.out.printf(""The tuition in ten years is $%.2f\n"", tuition);
        System.out.printf(""The total cost of four years' worth of tuition after the tenth year is $%.2f\n"", totalCost);
    }
}",5,"public class TuitionCalculator {

    public static void main(String[] args) {
        // Declare and initialize variables
        double currentTuition = 10000.0;
        double annualIncreaseRate = 0.05;
        int numberOfYears = 10;

        // Calculate tuition for each year
        for (int year = 1; year <= numberOfYears; year++) {
            currentTuition = currentTuition + (currentTuition * annualIncreaseRate);
        }

        // Display tuition after ten years
        System.out.println(""Tuition in "" + numberOfYears + "" years: $"" + currentTuition);

        // Calculate and display total cost for four years
        double totalCost = 0;
        for (int i = 1; i <= 4; i++) {
            totalCost = totalCost + currentTuition;
            currentTuition = currentTuition + (currentTuition * annualIncreaseRate);
        }

        System.out.println(""Total cost of four years' worth of tuition after "" + numberOfYears + "" years: $"" + totalCost);
    }
}",0.5788770053475936
0_Exercise05_50.java," /**
 * 5.50 (Count uppercase letters) Write a program that prompts
 * the user to enter a string and displays the number of the upper-case
 * letters in the string.
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_50 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        System.out.println(""Enter a string with some uppercase letters: "");

        String toBeevaluated = input.nextLine();
        int numberOfuppercase = 0;
        int x = 0;

        while (x < toBeevaluated.length()) {

            if (Character.isUpperCase(toBeevaluated.charAt(x))) {
                numberOfuppercase++;
            }
            x++;
        }

        System.out.println(""The number of upper case letters is: "" + numberOfuppercase);

    }

}
","import java.util.Scanner;

public class CountUpperCase {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        int upperCaseCount = 0;
        for (int i = 0; i < inputString.length(); i++) {
            if (Character.isUpperCase(inputString.charAt(i))) {
                upperCaseCount++;
            }
        }

        System.out.println(""Number of upper-case letters: "" + upperCaseCount);
    }
}",5,"import java.util.Scanner;

public class UppercaseLetterCounterProgramByHarryDulaney {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Prompt user to enter a string
        System.out.println(""Please enter a string: "");
        String userString = scanner.nextLine();

        // Initialize variable to count uppercase letters
        int uppercaseLetterCount = 0;

        // Loop through each character in the string
        for (int i = 0; i < userString.length(); i++) {
            // Check if the character is an uppercase letter
            if (Character.isUpperCase(userString.charAt(i))) {
                // Increment the count if it is an uppercase letter
                uppercaseLetterCount++;
            }
        }

        // Display the result
        System.out.println(""The number of uppercase letters in the string is: "" + uppercaseLetterCount);

        // Close the scanner
        scanner.close();
    }
}",0.672386895475819
0_Exercise05_46.java," /**
 * 5.46 (Reverse a string) Write a program that prompts
 * the user to enter a string and displays the string in reverse order.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_46 {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        System.out.print(""Enter a string: "");
        String str = input.nextLine();

        for (int i = str.length() - 1; i >= 0; i--) {

            System.out.print(str.charAt(i));

        }

    }

}
","import java.util.Scanner;

public class ReverseString {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter a string: "");
        String inputString = scanner.nextLine();

        String reversedString = """";
        for (int i = inputString.length() - 1; i >= 0; i--) {
            reversedString += inputString.charAt(i);
        }

        System.out.println(""Reversed string: "" + reversedString);
    }
}",5,"import java.util.Scanner;

public class StringReverser {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the String Reverser Program!"");

        // Create a Scanner object to get user input
        Scanner userInputScanner = new Scanner(System.in);

        // Prompt the user to enter a string
        System.out.print(""Please enter a string: "");
        String userString = userInputScanner.nextLine();

        // Display the string in reverse order
        System.out.print(""The reverse of the string is: "");
        for (int i = userString.length() - 1; i >= 0; i--) {
            System.out.print(userString.charAt(i));
        }

        // Close the Scanner
        userInputScanner.close();
    }
}",0.6351851851851852
0_Exercise05_11.java," /**
 * 5.11 (Find numbers divisible by 5 or 6, but not both) Write a program
 * that displays all the numbers from 100 to 200, ten per line, that are
 * divisible by 5 or 6, but not both. Numbers are separated by exactly one
 * space.
 */","package ch_05;


public class Exercise05_11 {
    public static void main(String[] args) {

        int count = 0;

        for (int i = 100; i <= 200; i++) {

            if (count == 10) {
                System.out.println();
                count = 0;
            }

            if (i % 5 == 0 ^ i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
            }


        }
    }
}
","public class DivisibleByFiveOrSix {
    public static void main(String[] args) {
        final int NUMS_PER_LINE = 10;
        int count = 0;

        for (int i = 100; i <= 200; i++) {
            if ((i % 5 == 0 || i % 6 == 0) && !(i % 5 == 0 && i % 6 == 0)) {
                System.out.print(i + "" "");
                count++;

                if (count == NUMS_PER_LINE) {
                    System.out.println();
                    count = 0;
                }
            }
        }
    }
}",5,"public class DivisibleNumbersFinder {

    public static void main(String[] args) {
        // Loop through numbers from 100 to 200
        for (int i = 100; i <= 200; i++) {
            // Check if the number is divisible by 5 or 6, but not both
            if ((i % 5 == 0 && i % 6 != 0) || (i % 5 != 0 && i % 6 == 0)) {
                // Print the number
                System.out.print(i + "" "");

                // Check if ten numbers have been printed and start a new line
                if (i % 10 == 0) {
                    System.out.println();
                }
            }
        }
    }
}",0.6575
0_Exercise05_10.java," /**
 * 5.10 (Find numbers divisible by 5 and 6) Write a program that displays
 * all the numbers from 100 to 1,000, ten per line, that are divisible by
 * 5 and 6. Numbers are separated by exactly one space.
 */","package ch_05;


public class Exercise05_10 {
    public static void main(String[] args) {

        final int startNum = 100;
        final int endNum = 1000;

        int count = 0;
        for (int i = startNum; i <= endNum; i++) {

            if (i % 6 == 0 && i % 5 == 0) {
                System.out.print(i + "" "");
                count++;

                if (count == 10) {
                    System.out.println();
                    count = 0;
                }

            }

        }

    }
}
","public class DivisibleBy5And6 {
    public static void main(String[] args) {
        final int LOWER_LIMIT = 100;
        final int UPPER_LIMIT = 1000;
        final int NUMBERS_PER_LINE = 10;

        int count = 0;
        for (int i = LOWER_LIMIT; i <= UPPER_LIMIT; i++) {
            if (i % 5 == 0 && i % 6 == 0) {
                System.out.print(i + "" "");
                count++;
                if (count % NUMBERS_PER_LINE == 0) {
                    System.out.println();
                }
            }
        }
    }
}",5,"public class DivisibleNumbersFinder {

    public static void main(String[] args) {
        // Loop through numbers from 100 to 1000
        for (int i = 100; i <= 1000; i++) {
            // Check if the number is divisible by both 5 and 6
            if (i % 5 == 0 && i % 6 == 0) {
                // Print the number
                System.out.print(i + "" "");

                // Check if ten numbers have been printed and start a new line
                if (i % 500 == 0) {
                    System.out.println();
                }
            }
        }
    }
}",0.6
0_Exercise05_47.java," /**
 * *5.47 (Business: check ISBN-13) ISBN-13 is a new standard for identifying books. It
 * uses 13 digits d1d2d3d4d5d6d7d8d9d10d11d12d13. The last digit d13 is a checksum,
 * which is calculated from the other digits using the following formula:
 * 10 - (d1 + 3d2 + d3 + 3d4 + d5 + 3d6 + d7 + 3d8 + d9 + 3d10 + d11 + 3d12)%10
 * If the checksum is 10, replace it with 0. Your program should read the input as a
 * string.
 * <p>
 * <strong>Here are sample runs:</strong>
 * <p>
 * {@code Enter the first 12 digits of an ISBN-13 as a string: 978013213080
 * The ISBN-13 number is 9780132130806
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 978013213079
 * The ISBN-13 number is 9780132130790
 * <p>
 * Enter the first 12 digits of an ISBN-13 as a string: 97801320
 * 97801320 is an invalid input}
 */","package ch_05;

import java.util.*;


public class Exercise05_47 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String isbn = in.nextLine();

        // Verify string length
        if (isbn.length() != 12) {
            System.out.println(""Invalid input "" + isbn + "" input MUST be exactly 12 numbers"");
            System.exit(0);
        }

        int check = 0;
        for (int i = 0; i < isbn.length(); i++) {
            int value = Integer.parseInt(String.valueOf(isbn.charAt(i)));
            check += i % 2 == 0 ? 3 * value
                    : value;
        }
        check = 10 - check % 10;
        
        System.out.println(""ISBN-13 number is "" + isbn +
                (check == 10 ? 0 : check));

        in.close();
    }
}","import java.util.Scanner;

public class ISBNChecker {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first 12 digits of the ISBN-13: "");
        String input = scanner.nextLine();
        
        // Convert input to integer array
        int[] digits = new int[12];
        for (int i = 0; i < 12; i++) {
            digits[i] = Character.getNumericValue(input.charAt(i));
        }
        
        // Calculate checksum
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            if (i % 2 == 0) {
                sum += digits[i];
            } else {
                sum += digits[i] * 3;
            }
        }
        int checksum = 10 - (sum % 10);
        if (checksum == 10) {
            checksum = 0;
        }
        
        // Output complete ISBN-13
        System.out.println(""The complete ISBN-13 is: "" + input + checksum);
    }
}",5,"import java.util.Scanner;

public class ISBNChecker {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""ISBN-13 Checker"");

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first 12 digits of an ISBN-13 as a string
        System.out.print(""Enter the first 12 digits of an ISBN-13 as a string: "");
        String input = scanner.nextLine();

        // Check if the input length is exactly 12
        if (input.length() == 12) {
            // Calculate the checksum using the given formula
            int checksum = calculateChecksum(input);

            // Calculate the last digit based on the checksum
            int lastDigit = (10 - checksum) % 10;

            // Display the complete ISBN-13 number
            System.out.println(""The ISBN-13 number is "" + input + lastDigit);
        } else {
            // Display an error message for invalid input
            System.out.println(input + "" is an invalid input"");
        }

        // Close the Scanner
        scanner.close();
    }

    // Function to calculate the checksum for ISBN-13
    private static int calculateChecksum(String input) {
        int sum = 0;
        for (int i = 0; i < 12; i++) {
            int digit = Character.getNumericValue(input.charAt(i));
            if (i % 2 == 0) {
                sum += digit;
            } else {
                sum += 3 * digit;
            }
        }
        return sum % 10;
    }
}",0.4954499494438827
0_Exercise05_51.java," /**
 * *5.51 (Longest common prefix) Write a program that prompts the user to enter two
 * strings and displays the largest common prefix of the two strings. Here are some
 * sample runs:
 * Enter the first string: Welcome to C++
 * Enter the second string: Welcome to programming
 * The common prefix is Welcome to
 * Enter the first string: Atlanta
 * Enter the second string: Macon
 * Atlanta and Macon have no common prefix
 *
 * By: Harry Dulaney
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_51 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);
        System.out.println(""Enter string one: "");
        String str1 = input.nextLine();

        final int lengthOne = str1.length();
        System.out.println(""Enter string two: "");

        String str2 = input.nextLine();
        final int lengthTwo = str2.length();

        if (str1.charAt(0) != str2.charAt(0)) {

            System.out.println(str1 + "" and "" + str2 + "" have :(. ---> no common prefix <---"");

        } else {
            int indexOfLCP = 0;
            for (int i = 0; i < (Math.max(lengthOne, lengthTwo)); i++) {

                if (str1.charAt(i) == str2.charAt(i)) {
                    indexOfLCP = i;
                } else {
                    break;
                }
            }
            System.out.print(""The common prefix is: "" + str1.substring(0, indexOfLCP + 1));

        }

        input.close();
    }

}
","import java.util.Scanner;

public class CommonPrefix {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter the first string: "");
        String str1 = scanner.nextLine();
        System.out.print(""Enter the second string: "");
        String str2 = scanner.nextLine();
        
        // Find length of common prefix
        int len = Math.min(str1.length(), str2.length());
        int i;
        for (i = 0; i < len; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                break;
            }
        }
        
        // Output common prefix
        String commonPrefix = str1.substring(0, i);
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is: "" + commonPrefix);
        } else {
            System.out.println(""There is no common prefix."");
        }
    }
}",5,"import java.util.Scanner;

public class CommonPrefixFinderByHarryDulaney {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Common Prefix Finder!"");

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the first string
        System.out.print(""Enter the first string: "");
        String firstString = scanner.nextLine();

        // Prompt the user to enter the second string
        System.out.print(""Enter the second string: "");
        String secondString = scanner.nextLine();

        // Find the common prefix
        String commonPrefix = findCommonPrefix(firstString, secondString);

        // Display the result
        if (commonPrefix.length() > 0) {
            System.out.println(""The common prefix is "" + commonPrefix);
        } else {
            System.out.println(firstString + "" and "" + secondString + "" have no common prefix"");
        }

        // Close the Scanner
        scanner.close();
    }

    // Function to find the common prefix of two strings
    private static String findCommonPrefix(String str1, String str2) {
        int minLength = Math.min(str1.length(), str2.length());
        StringBuilder commonPrefix = new StringBuilder();

        for (int i = 0; i < minLength; i++) {
            if (str1.charAt(i) == str2.charAt(i)) {
                commonPrefix.append(str1.charAt(i));
            } else {
                break;
            }
        }

        return commonPrefix.toString();
    }
}",0.5502439024390244
0_Exercise05_26.java," /**
 * **5.26 (Compute e) You can approximate e using the following series:
 * e = 1 + 1/1! + 1/2! + 1/3! + 1/4! + ... + 1/i!
 * Write a program that displays the e value for i = 10000, 20000, …, and
 * 100000. (Hint: Because i! = i * (i - 1) * c * 2 * 1, then
 * 1 i!
 * is
 * 1
 * i(i - 1)!
 * Initialize e and item to be 1 and keep adding a new item to e. The new item is
 * the previous item divided by i for i = 2, 3, 4, ....)
 */","package ch_05;

import java.util.*;


public class Exercise05_26 {
    static double e;

    public static void main(String[] args) {
        double e = 1;
        int item = 10000;
        while (item <= 100000) {
            double denominator = 0;
            for (double i = 1; i <= item; i++) {
                denominator += i * (i - 1);
            }
            e += 1 / denominator;
            System.out.println(""e is "" + e + "" when i is "" + item);
            item += 10000;
        }
    }
}

","import java.math.BigDecimal;

public class ApproximateE {
    public static void main(String[] args) {
        int[] iValues = {10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000};
        for (int i : iValues) {
            BigDecimal sum = BigDecimal.ONE;
            BigDecimal factorial = BigDecimal.ONE;
            for (int j = 1; j <= i; j++) {
                factorial = factorial.multiply(BigDecimal.valueOf(j));
                sum = sum.add(BigDecimal.ONE.divide(factorial));
            }
            System.out.println(""e for i = "" + i + "" is: "" + sum);
        }
    }
}",5,"public class EApproximator {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the E Approximator!"");

        // Declare and initialize variables
        double e = 1.0;
        double item = 1.0;
        int iterations = 100000;

        // Calculate e for each iteration
        for (int i = 2; i <= iterations; i++) {
            item /= i;
            e += item;
        }

        // Display the result
        System.out.println(""The approximate value of e for "" + iterations + "" iterations is: "" + e);
    }
}",0.4658385093167702
0_Exercise05_30.java," /**
 * 5.30 (Financial application: compound value) Suppose you save $100
 * each month into a savings account with the annual interest rate 5%.
 * So, the monthly interest rate is 0.05 / 12 = 0.00417. After the first
 * month, the value in the account becomes.
 * Write a program that prompts the user to enter an amount (e.g., 100)
 * the annual interest rate (e.g., 5), and the number of months (e.g., 6)
 * and displays the amount in the savings account after the given month.
 */","package ch_05;

import java.util.Scanner;


public class Exercise05_30 {
    public static void main(String[] args) {

        Scanner input = new Scanner(System.in);

        System.out.print(""Enter the amount you would like to invest each month: "");

        double investment = input.nextDouble();

        System.out.print(""Enter the annual interest rate(e.g. 5,10,20): "");

        double interestRate = input.nextDouble();

        interestRate = interestRate / 100;

        System.out.println(""Enter the number of months: "");

        int numberOfMonths = input.nextInt();

        double total = 0;

        for (int i = 1; i <= numberOfMonths; i++) {


            total = (investment + total) * (1 + (interestRate / 12));

        }


        System.out.println(""After the "" + numberOfMonths + ""th month, "" + ""the account value is "" + total);


    }

}
","import java.util.Scanner;

public class SavingsAccount {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Get input from user
        System.out.print(""Enter the initial amount: $"");
        double amount = scanner.nextDouble();
        System.out.print(""Enter the annual interest rate (as a percentage): "");
        double annualRate = scanner.nextDouble();
        System.out.print(""Enter the number of months: "");
        int months = scanner.nextInt();
        
        // Compute monthly interest rate
        double monthlyRate = annualRate / 1200.0;  // 12 months in a year, 100 to convert percentage to decimal
        
        // Compute balance after specified number of months
        for (int i = 1; i <= months; i++) {
            amount = amount + (100 * monthlyRate) + 100;  // add monthly deposit and interest
        }
        
        // Output balance
        System.out.printf(""The balance after %d months is: $%.2f"", months, amount);
    }
}",5,"import java.util.Scanner;

public class CompoundValueCalculator {

    public static void main(String[] args) {
        // Welcome message
        System.out.println(""Welcome to the Compound Value Calculator!"");

        // Create a Scanner object for user input
        Scanner scanner = new Scanner(System.in);

        // Prompt the user to enter the amount, annual interest rate, and number of months
        System.out.print(""Enter the amount to save each month (e.g., 100): "");
        double monthlyAmount = scanner.nextDouble();

        System.out.print(""Enter the annual interest rate (e.g., 5): "");
        double annualInterestRate = scanner.nextDouble();

        System.out.print(""Enter the number of months (e.g., 6): "");
        int numberOfMonths = scanner.nextInt();

        // Calculate the monthly interest rate
        double monthlyInterestRate = annualInterestRate / 100 / 12;

        // Calculate the amount in the savings account after the given number of months
        double totalAmount = 0;
        for (int i = 1; i <= numberOfMonths; i++) {
            totalAmount = (totalAmount + monthlyAmount) * (1 + monthlyInterestRate);
        }

        // Display the result
        System.out.println(""The amount in the savings account after "" + numberOfMonths + "" months is: $"" + totalAmount);

        // Close the Scanner
        scanner.close();
    }
}",0.6730310262529833
